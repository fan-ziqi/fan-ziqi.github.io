# 16-指针

什么是指针？**指针是一个整数，一种存储内存地址的数字。**指针只是一个数字而已，不要想太多。指针的类型对指针来说是毫无意义的，只能说是这个地址的数据被假设为我们给的类型。指针类型并不会改变指针的实质，指针只是一个内存地址，一个数字而已。 

首先我们创建一个最纯粹的空指针，我并不关心这个指针的类型，因为我只想保存一个内存地址。

```cpp
void* ptr = nullptr;
```

其中`nullptr`代表空指针的意思，也可写成NULL。但不可写成0，因为当内存地址为0的时候程序会崩溃。

每个变量都有一个内存地址，使用引用`&`运算符（reference）得到这个变量的内存地址。创建一个变量名为var，使用ptr存放var的内存地址：

```cpp
int var = 8;
void* ptr = &var;
```

如果此时加断点调试，可以看到`var`的值为`8`，`ptr`的值为`0xef045ff954`，这是一个十六进制的数字，即为var变量的内存地址。我们在内存中转到这个地址，可以看到`08 00 00 00`，就是`var`的值`8`（int占用4个字节）。

指针的类型对指针无关紧要，将`void`改为`int`，再次在内存中转到此地址，效果是完全一样的。指针的类型只在读写时有作用，跟指针本身是完全无关的。**指针只是一个整数**而已。

如果我们想读写指针指向的数据，需要使用逆向引用`*`运算符（dereference）。在指针前加上`*`即可读取这个指针指向的数据。如前例，ptr为var的指针，使用`*ptr = 10`即可将var的值改为10。但是此时会报错，因为此时指针为void空指针，计算机并不知道这个“10”需要多少字节的数据，自然而然无法将其写入。所以此时需要指定字节数，即将前文改为`int* ptr = &var;`。记住，类型跟指针毫无关系，类型的目的只是告诉编译器在读写时应该寻找几个字节。此时重新运行程序可以看到var的值被成功修改为10。

如果需要分配一些空间，可以这么操作：

```cpp
//new char[8]分配了8个字节的内存，并返回一个指向那块内存开始的指针。
char* buffer = new char[8];
//使用memset函数用指定的数据填充一个内存块：第一个参数为内存块开始的指针，第二个值为要填充的值，第三个参数为大小。
memset(buffer, 0, 8);
```

调试程序，转到buffer地址，可以看到`00 00 00 00   00 00 00 00`。之后需要释放这个内存，使用`delete[] buffer;`

指针也是一个变量，因此指针也可以指向指针。

```cpp
char** ptr = &buffer;
```

查看内存：buffer的值为`0x193a7d41b60`。ptr的值为`0x843b7ffb30`，即为buffer指针存放的地址。跳转进去可以看到`60 1b d4 a7   93 01 00 00`，这也就是buffer的值。（计算机中存储顺序为倒序）

------

**文章作者:** [范子琦](https://github.com/fan-ziqi)

**文章链接:** https://www.fanziqi.site/categories/C/

**版权声明:** 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议。转载请注明来自 [范子琦的博客](http://www.fanziqi.site/)！