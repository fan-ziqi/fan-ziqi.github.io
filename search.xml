<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chrome多设备书签同步方案</title>
    <url>/posts/a53da602.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Chrome多设备书签同步方案"><a href="#Chrome多设备书签同步方案" class="headerlink" title="Chrome多设备书签同步方案"></a>Chrome多设备书签同步方案</h1><p>众所周知因为某些原因Chrome无法与它的服务器正常通讯,这就影响到了我们书签的同步,这里介绍一个插件,将书签同步到GitHub或GItee上.</p>
<p>项目地址: ↓ </p>
<p><a href="https://github.com/CLDeveloping/chrome-bookmark">Github项目</a> | <a href="https://gitee.com/CLCoding/chrome-bookmark">Gitee项目</a></p>
<ul>
<li>将项目整个下载下来,解压缩,在浏览器地址栏输入：<code>chrome://extensions/</code>，进入扩展程序管理界面</li>
<li>点击【加载已解压的扩展程序】-&gt; 选择项目根目录，导入源码文件夹</li>
<li>这里只介绍GitHub操作.进入自己的GitHub创建一个私有项目,随便命名</li>
<li>获取Github项目<a href="https://github.com/settings/tokens">私有访问Token</a>（如何获取：Github -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token）选择repo,时间选无限,将生成的token拷贝下来,这个只会出现一次,最好拿小本本记下来</li>
<li>点击书签工具配置,将仓库地址和token填入,选择保存配置</li>
<li>重新点击书签图标工具，就可以选择上传或者下载书签了</li>
</ul>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium Designer导出Gerber文件的一般步骤</title>
    <url>/posts/a1423033.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Altium-Designer导出Gerber文件的一般步骤"><a href="#Altium-Designer导出Gerber文件的一般步骤" class="headerlink" title="Altium Designer导出Gerber文件的一般步骤"></a>Altium Designer导出Gerber文件的一般步骤</h1><p>PCB画完之后，需要生成Gerber文件提交给PCB工厂进行生产，本文将介绍生成Gerber的一般步骤</p>
<h2 id="一、导出非机械层"><a href="#一、导出非机械层" class="headerlink" title="一、导出非机械层"></a>一、导出非机械层</h2><h3 id="1-1-”文件“-gt-”制造输出“-gt-“Gerber-Files”"><a href="#1-1-”文件“-gt-”制造输出“-gt-“Gerber-Files”" class="headerlink" title="1.1 ”文件“ -&gt; ”制造输出“ -&gt; “Gerber Files”"></a>1.1 ”文件“ -&gt; ”制造输出“ -&gt; “Gerber Files”</h3><p>（“File”-&gt;“Fabrication Outputs”-&gt;“Gerber Files”）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-1.png" alt="image-20210806221126738"></p>
<h3 id="1-2-通用（General）"><a href="#1-2-通用（General）" class="headerlink" title="1.2 通用（General）"></a>1.2 通用（General）</h3><p>单位：英寸（Inches）</p>
<p>格式：2:5</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-2.png" alt="image-20210806221658661"></p>
<h3 id="1-3-层（Layers）"><a href="#1-3-层（Layers）" class="headerlink" title="1.3 层（Layers）"></a>1.3 层（Layers）</h3><p>左面出图层除机械层全选择，镜像层不选，最下面四个层的合集与上面层重复全部不选</p>
<p>右面机械层全不选</p>
<p>下面勾选”包括未连接的中间层焊盘“（Include unconnected mid-layer pads）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-3.png" alt="image-20210806222145277"></p>
<h3 id="1-4-钻孔图层（Drill-Drawing）"><a href="#1-4-钻孔图层（Drill-Drawing）" class="headerlink" title="1.4 钻孔图层（Drill Drawing）"></a>1.4 钻孔图层（Drill Drawing）</h3><p>全不选</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-4.png" alt="image-20210806222318634"></p>
<h3 id="1-5-光圈（Apertures）"><a href="#1-5-光圈（Apertures）" class="headerlink" title="1.5 光圈（Apertures）"></a>1.5 光圈（Apertures）</h3><p>选择嵌入的孔径（Embedded apertures）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-5.png" alt="image-20210806222832869"></p>
<h3 id="1-6-高级（Advanced）"><a href="#1-6-高级（Advanced）" class="headerlink" title="1.6 高级（Advanced）"></a>1.6 高级（Advanced）</h3><p>设置如图两项，其他默认即可</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-6.png" alt="image-20210806223016206"></p>
<h3 id="1-7-点击确定（OK）"><a href="#1-7-点击确定（OK）" class="headerlink" title="1.7 点击确定（OK）"></a>1.7 点击确定（OK）</h3><p>弹出的直接关掉，不用保存</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-7.png" alt="image-20210806223142508"></p>
<h2 id="二、导出机械层"><a href="#二、导出机械层" class="headerlink" title="二、导出机械层"></a>二、导出机械层</h2><h3 id="2-1-“文件“-gt-”制造输出“-gt-”Gerber-Files“"><a href="#2-1-“文件“-gt-”制造输出“-gt-”Gerber-Files“" class="headerlink" title="2.1 “文件“ -&gt; ”制造输出“ -&gt; ”Gerber Files“"></a>2.1 “文件“ -&gt; ”制造输出“ -&gt; ”Gerber Files“</h3><p>同2.1</p>
<h3 id="2-2-通用（General）"><a href="#2-2-通用（General）" class="headerlink" title="2.2 通用（General）"></a>2.2 通用（General）</h3><p>同2.1</p>
<h3 id="3-层（Layers）"><a href="#3-层（Layers）" class="headerlink" title="3. 层（Layers）"></a>3. 层（Layers）</h3><p>左面出图层全不选，镜像层全不选</p>
<p>右面机械层全选</p>
<p>取消勾选”包括未连接的中间层焊盘“（Include unconnected mid-layer pads）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-2-3.png" alt="image-20210806223538241"></p>
<h3 id="2-4-钻孔图层（Drill-Drawing）"><a href="#2-4-钻孔图层（Drill-Drawing）" class="headerlink" title="2.4 钻孔图层（Drill Drawing）"></a>2.4 钻孔图层（Drill Drawing）</h3><p>勾选钻孔图（Drill Drawing Plots）和钻孔向导图（Drill Guide Plots）下的输出所有使用的钻孔对（Plot all used drill pairs）</p>
<p>不勾选镜像输出</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-2-4.png" alt="image-20210806223735534"></p>
<h3 id="2-5-光圈（Apertures）"><a href="#2-5-光圈（Apertures）" class="headerlink" title="2.5 光圈（Apertures）"></a>2.5 光圈（Apertures）</h3><p>同1.5</p>
<h3 id="2-6-高级（Advanced）"><a href="#2-6-高级（Advanced）" class="headerlink" title="2.6 高级（Advanced）"></a>2.6 高级（Advanced）</h3><p>同1.6</p>
<h3 id="2-7-点击确定（OK）"><a href="#2-7-点击确定（OK）" class="headerlink" title="2.7 点击确定（OK）"></a>2.7 点击确定（OK）</h3><p>弹出的直接关掉，不用保存</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-2-7.png" alt="image-20210806223916694"></p>
<h2 id="三、导出钻孔层"><a href="#三、导出钻孔层" class="headerlink" title="三、导出钻孔层"></a>三、导出钻孔层</h2><h3 id="3-1-”文件”-gt-“制造输出”-gt-“NC-Drill-Files”"><a href="#3-1-”文件”-gt-“制造输出”-gt-“NC-Drill-Files”" class="headerlink" title="3.1 ”文件” -&gt; “制造输出” -&gt; “NC Drill Files”"></a>3.1 ”文件” -&gt; “制造输出” -&gt; “NC Drill Files”</h3><p>（“File”-&gt;“Fabrication Outputs”-&gt;“NC Drill Files”）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-3-1.png" alt="image-20210806224045854"></p>
<h3 id="3-2-如图设置"><a href="#3-2-如图设置" class="headerlink" title="3.2 如图设置"></a>3.2 如图设置</h3><p>单位：英寸（Inches）</p>
<p>格式：2:5</p>
<p>前导/尾数零（Leading/Trailing Zeroes）：摒弃前导零（Suppress leading zeroes）</p>
<p>其他默认即可</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-3-2.png" alt="image-20210806224252303"></p>
<h3 id="3-3-点击确定（OK）"><a href="#3-3-点击确定（OK）" class="headerlink" title="3.3 点击确定（OK）"></a>3.3 点击确定（OK）</h3><p>弹出“导入钻孔数据”（Import Drill Data），点击确定</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-3-3.png" alt="image-20210806224531631"></p>
<p>如果又弹出一个，同样点击确定即可</p>
<p>都不用保存，直接关掉</p>
<h2 id="四、到此为止，已经完成了Gerber文件的导出"><a href="#四、到此为止，已经完成了Gerber文件的导出" class="headerlink" title="四、到此为止，已经完成了Gerber文件的导出"></a>四、到此为止，已经完成了Gerber文件的导出</h2><p>Gerber默认导出在PCB所在目录下的“Project Outputs for XXX”文件夹，如图</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-4-1.png" alt="image-20210806225134364"></p>
<p>将整个文件夹打包，发给PCB厂家</p>
<hr>
<p>Github：<a href="https://github.com/fan-ziqi">点击进入</a></p>
]]></content>
      <categories>
        <category>Altium Designer</category>
      </categories>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>CubeMX配置SPI-Flash(W25Q256)</title>
    <url>/posts/7b613e40.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CubeMX配置SPI-Flash-W25Q256"><a href="#CubeMX配置SPI-Flash-W25Q256" class="headerlink" title="CubeMX配置SPI-Flash(W25Q256)"></a>CubeMX配置SPI-Flash(W25Q256)</h1><p>W25Q256（256Mb）将32M（字节byte）的容量分为512个块（block），每个块大小为64K字节，每个块又分为16个扇区（sector）,每个扇区4K字节。最小擦除单位为一个扇区，也就是4K字节。</p>
<p>首先应该配置SPI,但是这里有个大坑.</p>
<p>按照标准的SPI协议，当SPI被配置为主机模式后，通过SPI对从设备进行操作时，其NSS应该自动置低，从而选中（使能）从设备；一旦不对从设备进行操作，NSS立刻置为高。</p>
<p>但是，我在实际调试过程中发现：STM32 SPI NSS无法自动实现跳变。 一旦SPI初始化完成并使能SPI，NSS立刻置低，然后保持不变。</p>
<p>这个问题一直无法解决，直到我在ST官方论坛上看到国外有些技术人员也在讨论这个问题，他们得出的结论是：STM32 SPI NSS无法自动跳变。</p>
<p>ST官方技术人员也证实：STM32 SPI NSS是不会自动置位和复位的。按照官方说法，ST已经将其列入了改进计划。</p>
<p>对于这个问题，可以采用下面的方法解决：</p>
<p>在SPI初始化时，采用NSS soft模式，然后使能NSS输出功能。从而将NSS当做GPIO使用，通过软件set和reset来实现NSS的置位和复位。</p>
<p>具体在CubeMX中应将FLASH的NSS当成GPIO Output配置而不是SPI NSS.配置如图所示:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113160700854.png" alt="image-20220113160700854"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113160802730.png" alt="image-20220113160802730"></p>
<p>因为需要在flash中存入浮点数,所以需要类型转换,这里使用union联合体实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> union_float;</span><br><span class="line">    <span class="keyword">uint8_t</span> union_int8[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span> <span class="title">Test_write</span>,<span class="title">Test_read</span>;</span></span><br><span class="line">Test_write.union_float=<span class="number">1.23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读flash的id</span></span><br><span class="line">BSP_W25Q256_Read_ID(id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ID = 0x%02X%02X\r\n&quot;</span>, id[<span class="number">0</span>], id[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试flash的擦读写</span></span><br><span class="line">BSP_W25Q256_Erase_Block(<span class="number">0</span>);</span><br><span class="line">BSP_W25Q256_Write(Test_write.union_int8, <span class="number">0</span>, <span class="keyword">sizeof</span>(Test_write.union_int8));</span><br><span class="line">BSP_W25Q256_Read(Test_read.union_int8, <span class="number">0</span>, <span class="keyword">sizeof</span>(Test_read.union_int8));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Ready to write:  float: %f, trans to uint8: 0x%x 0x%x 0x%x 0x%x\r\n&quot;</span>, </span><br><span class="line">       Test_write.union_float, </span><br><span class="line">       Test_write.union_int8[<span class="number">0</span>],</span><br><span class="line">       Test_write.union_int8[<span class="number">1</span>], </span><br><span class="line">       Test_write.union_int8[<span class="number">2</span>],</span><br><span class="line">       Test_write.union_int8[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Read from Flash: uint8: 0x%x 0x%x 0x%x 0x%x, trans to float: %f\r\n&quot;</span>, </span><br><span class="line">       Test_read.union_int8[<span class="number">0</span>],</span><br><span class="line">       Test_read.union_int8[<span class="number">1</span>],</span><br><span class="line">       Test_read.union_int8[<span class="number">2</span>],</span><br><span class="line">       Test_read.union_int8[<span class="number">3</span>],</span><br><span class="line">       Test_read.union_float);</span><br></pre></td></tr></table></figure>
<p>参考:</p>
<p>关于STM32 SPI NSS的讨论 <a href="https://blog.csdn.net/chseangs/article/details/4520733">https://blog.csdn.net/chseangs/article/details/4520733</a></p>
<p>SPI problem with hardware NSS management <a href="https://community.st.com/s/question/0D50X00009XkbvdSAB/spi-problem-with-hardware-nss-management">https://community.st.com/s/question/0D50X00009XkbvdSAB/spi-problem-with-hardware-nss-management</a></p>
<p>STM32CbueMX之W25Q256 <a href="https://blog.csdn.net/sudaroot/article/details/93158309">https://blog.csdn.net/sudaroot/article/details/93158309</a></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>FOC控制原理——Clark变换和Park变换</title>
    <url>/posts/9532f19e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC控制原理——Clark变换和Park变换"><a href="#FOC控制原理——Clark变换和Park变换" class="headerlink" title="FOC控制原理——Clark变换和Park变换"></a>FOC控制原理——Clark变换和Park变换</h1><h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153620081.png" alt="image-20220323153620081"></p>
<p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    \begin{aligned}
    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\
            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c
    \end{aligned} \\
    \begin{aligned}
    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\
           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c
    \end{aligned}
\end{array}\right.</script><p>可以将其整理成矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{ccc}
    1 & -\frac{1}{2}       & -\frac{1}{2} \\
    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}
\end{array}\right]
\left[\begin{array}{c}
    I_{a} \\
    I_{b} \\
    I_{c}
\end{array}\right]</script><p>由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故也可整理为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    I_\alpha=\frac{3}{2}I_a \\
    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b
\end{array}\right.</script><p>反Clark变换则将三向信号转换为两向信号，根据上式可以解得</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{a} \\
    I_{b} \\
    I_{c}
\end{array}\right]=
\left[\begin{array}{ccc}
    \frac{2}{3}  & 0       \\
    -\frac{1}{3} & \frac{1}{\sqrt{3}} \\
    -\frac{1}{3} & -\frac{1}{\sqrt{3}}
\end{array}\right]
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]</script><p>也可通过计算Clark变换常数矩阵的伪逆来确定反Clark变换的常数矩阵（使用MATLAB中的 <code>pinv()</code>函数）</p>
<h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323152939436.png" alt="image-20220323152939436"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323150553068.png" alt="image-20220323150553068"></p>
<p>通过图像可以看到，输入信号的幅值为1，经过Clark变换后的图像幅值变为1.5，即变为 $\frac{3}{2}$ 倍；进行反Clark变换后幅值又变为1.5，即变为 $\frac{2}{3}$ 倍。所以要进行等幅值变换。修改仿真：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153007076.png" alt="image-20220323153007076"></p>
<p>可以看到，经过等幅值变换后，幅值统一为1。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323151818659.png" alt="image-20220323151818659"></p>
<h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Park变换可以将正弦变量线性化</p>
<p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/v2-d15d057327992a5c50016aea5bb7201b_1440w.jpg" alt="img"></p>
<p>也就是说 $d-q$ 坐标系始终跟着转子旋转。</p>
<p>则可以写出</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
I_{d}=I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \\
I_{q}=-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)
\end{array}\right.</script><p>整理成矩阵形式</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
    I_{d} \\
    I_{q}
\end{array}\right]=
\left[\begin{array}{cc}
     \cos \theta & \sin \theta \\
    -\sin \theta & \cos \theta
\end{array}\right]
\left[\begin{array}{l}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]</script><p>所以如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。</p>
<p>同理，可以求得反Park变换</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{cc}
     \cos \theta & -\sin \theta \\
     \sin \theta & \cos \theta
\end{array}\right]
\left[\begin{array}{l}
    I_{d} \\
    I_{q}
\end{array}\right]</script><h3 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>在Clark变换和等幅值变换的基础上添加Park变换</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160805870.png" alt="image-20220323160805870"></p>
<p>关注Park部分</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160942614.png" alt="image-20220323160942614"></p>
]]></content>
      <categories>
        <category>电机</category>
      </categories>
      <tags>
        <tag>FOC</tag>
      </tags>
  </entry>
  <entry>
    <title>FOC学习笔记【持续更新中】</title>
    <url>/posts/d99d1c1a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC学习笔记"><a href="#FOC学习笔记" class="headerlink" title="FOC学习笔记"></a>FOC学习笔记</h1><p><strong>2022.04.16 使用EKF的状态观测器已完结</strong></p>
<h2 id="FOC框架"><a href="#FOC框架" class="headerlink" title="FOC框架"></a>FOC框架</h2><p>三向电机，UVW三向，角度互差120度</p>
<p>对于BLDC控制方法，每次换向增加60度，转子只能到达六个位置，所以六步换向会有振动；使用FOC控制方法可以使转子到达任意角度，所以运行起来会更加平滑。</p>
<p>举个例子，如果想到达40度位置，只需要在0度方向通电一段时间，在60度方向通电一段时间，再在空矢量（全桥000或111）的状态下通电一段时间（空矢量的时长用来调节扭矩），三段时间组成一个周期，以这个周期循环产生PWM，即可锁定至40度。改变0度和60度的通电时长比例即可到达任意位置。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328103406110.png" alt="image-20220328103406110" style="zoom: 50%;"></p>
<p>要想使磁场旋转，就需要输入正弦电压。而我们的输入是直流电，可以通过不断改变PWM脉宽来模拟正弦电压，体现在电流上则为正弦电流。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328104728924.png" alt="image-20220328104728924" style="zoom:50%;"></p>
<p>对于一个完整的FOC框架，先来看正向通路：输入 $I_{d_ref}$ 和 $I_{q_ref}$ 与下文反馈通路采样得到的电流 $I_d$ 和 $I_q$ 进行PID调节输出 $U_d$ 和 $U_q$ （输入的 $I_{d_ref}$ 通常为0， $I_{q_ref}$ 前通常还需要接入一个速度PID构成速度环。），再通过反Park变换转换成 $U_\alpha$ 和 $U_\beta$ ，送进SVPWM产生六路PWM信号，将PWM信号输入逆变桥控制MOS管的通断，产生三向电压控制电机转动。</p>
<p>再来看反馈通路：通过采样电阻采集两路的电流，根据基尔霍夫电流定律，可以算出第三向电流，将三向电流通过Clark变换转化成 $I_\alpha$ 和 $I_\beta$ ，再通过Park变换转换成 $I_d$ 和 $I_q$ ，送入PID构成电流环。同时Park变换和反Park变换需要输入当前角度。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328110606943.png" alt="image-20220328110606943"></p>
<p>获得角度和速度的方法分为有感和无感。有感采用霍尔元件（Hall Sensor），安装在电机上检测电机磁铁的位置。无感使用观测器（observer）获得角度速度信息，本文将使用卡尔曼滤波观测器（EKF），输入为  $U_\alpha$ 、 $U_\beta$ 、 $I_\alpha$ 、 $I_\beta$ 。使用无感方式不需要霍尔传感器，可以减少线的数量，也可以减小成本。</p>
<h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>为什么要使用坐标变换？电机控制大多是在控制速度/转矩，需要用PID闭环控制正弦交流电压的幅值和角度，不是很容易实现，所以通过坐标变化把正弦交流信息分解成角度信息（Q轴控制转矩）和幅值信息（D轴控制磁场）单独控制。</p>
<p><strong>FOC的变换中要满足等幅值变换，即变换前后幅值不变。</strong></p>
<p>坐标变换都分为正向变换和反向变换，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。</p>
<p>下面的变换均采用联立和矩阵两种形式表示，以方便使用。</p>
<h3 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142441996.png" alt="image-20220328142441996" style="zoom:50%;"></p>
<p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    \begin{aligned}
    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\
            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c
    \end{aligned} \\
    \begin{aligned}
    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\
           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c
    \end{aligned}
\end{array}\right.</script><p>矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{ccc}
    1 & -\frac{1}{2}       & -\frac{1}{2} \\
    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}
\end{array}\right]
\left[\begin{array}{c}
    I_{a} \\
    I_{b} \\
    I_{c}
\end{array}\right]</script><p>我们一般在电路中只采集两向电流，由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故上式也可整理为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    I_\alpha=\frac{3}{2}I_a \\
    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b
\end{array}\right.</script><p>矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{cc}
    \frac{3}{2} & 0\\
    \frac{\sqrt{3}}{2} & \sqrt{3}
\end{array}\right]
\left[\begin{array}{c}
    I_{a} \\
    I_{b} 
\end{array}\right]</script><p>由于变换前后 $I_a$ 和 $I_\alpha$ 幅值要相同，所以要进行等幅值变换，变换系数为 $\frac{2}{3}$ ，即变为</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    I_\alpha=I_a \\
    I_\beta=\frac{1}{\sqrt3}(I_a+2I_b)
\end{array}\right.</script><p>矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{cc}
    1 & 0\\
    \frac{1}{\sqrt{3}} & \frac{2}{\sqrt{3}}
\end{array}\right]
\left[\begin{array}{c}
    I_{a} \\
    I_{b} 
\end{array}\right]</script><p>（这里的系数在后文SVPWM里相电压的幅值与电压空间矢量之间有一个 $\frac{3}{2}$ 的系数相抵消）</p>
<p>MATLAB实现为：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103933845.png" alt="image-20220330103933845"></p>
<h3 id="Clark反变换"><a href="#Clark反变换" class="headerlink" title="Clark反变换"></a>Clark反变换</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142204832.png" alt="image-20220328142204832" style="zoom:50%;"></p>
<p>Clark反变换则将三向信号转换为两向信号。根据图可以写出：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
U_{a} =  U_{\alpha} \\
U_{b} = -\frac{1}{2}U_{\alpha} + \frac{\sqrt3}{2}U_{\beta}\\
U_{c} = -\frac{1}{2}U_{\alpha} - \frac{\sqrt3}{2}U_{\beta}
\end{array}\right.</script><p>矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    U_{a} \\
    U_{b} \\
    U_{c}
\end{array}\right]=
\left[\begin{array}{ccc}
    1  & 0       \\
    -\frac{1}{2} & \frac{\sqrt{3}}{2} \\
    -\frac{1}{2} & -\frac{\sqrt{3}}{2}
\end{array}\right]
\left[\begin{array}{c}
    U_{\alpha} \\
    U_{\beta}
\end{array}\right]</script><p>MATLAB实现为：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103915885.png" alt="image-20220330103915885"></p>
<h3 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h3><p>Park变换可以将正弦变量线性化</p>
<p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142542510.png" alt="image-20220328142542510" style="zoom:50%;"></p>
<p>也就是说 $d-q$ 坐标系始终跟着转子同步旋转。</p>
<p>则根据上图可以写出</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
I_{d}=I_{\alpha} \cos\theta+I_{\beta} \sin\theta \\
I_{q}=-I_{\alpha} \sin\theta+I_{\beta} \cos\theta
\end{array}\right.</script><p>很明显上述变换可以用旋转矩阵来表示，使用矩阵形式可以很方便地写出：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
    I_{d} \\
    I_{q}
\end{array}\right]=
\left[\begin{array}{cc}
     \cos \theta & \sin \theta \\
    -\sin \theta & \cos \theta
\end{array}\right]
\left[\begin{array}{l}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]</script><p>（如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。）</p>
<p>MATLAB实现为</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104003922.png" alt="image-20220330104003922"></p>
<h3 id="Park反变换"><a href="#Park反变换" class="headerlink" title="Park反变换"></a>Park反变换</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142732077.png" alt="image-20220328142732077" style="zoom:50%;"></p>
<p>根据上面的推导可以求得反Park变换</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
U_{\alpha}=U_{d} \cos\theta-U_{q} \sin\theta \\
U_{\beta}= U_{d} \sin\theta+U_{q} \cos\theta
\end{array}\right.</script><p>同理，使用旋转矩阵可以求出反变换的系数矩阵：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
    U_{\alpha} \\
    U_{\beta}
\end{array}\right]=
\left[\begin{array}{cc}
     \cos \theta & -\sin \theta \\
     \sin \theta & \cos \theta
\end{array}\right]
\left[\begin{array}{l}
    U_{d} \\
    U_{q}
\end{array}\right]</script><p>MATLAB实现为</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103857619.png" alt="image-20220330103857619"></p>
<h3 id="MATLAB仿真"><a href="#MATLAB仿真" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h3><p>为了更清楚地仿真，这里不用矩阵形式表示，如需矩阵形式可以看我另一篇文章。</p>
<p>请注意，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。但是在这节的仿真中，把正变换和反变换连在一起，没有实际意义，只是为了验证。</p>
<p>输入Vd为0，Vq为1，角度为由0到2pi的连续值。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103716603.png" alt="image-20220330103716603"></p>
<p>再来看foc模块内部，输入经过两个逆变换，再经过两个正变换。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103816443.png" alt="image-20220330103816443"></p>
<p>运行查看波形（新版本MATLAB常值输入为一个圆圈）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104412589.png" alt="image-20220330104412589"></p>
<h2 id="SVPWM"><a href="#SVPWM" class="headerlink" title="SVPWM"></a>SVPWM</h2><p>根据BLDC的六步换向，可以将一圈分为六个扇区，前文FOC引入章节已经讲过，只需要控制每个状态通电的时间就可以控制转子到达任意角度。这就是SVPWM。</p>
<p>SVPWM的输入为 $U_{\alpha}$ 和 $U_{\beta}$ ，输出为三向计数器的比较值。所以应该首先判断用哪两个相邻矢量，然后计算两个相邻矢量的作用时长，然后将作用时长转化成计数器的比较数值送入定时器。下面对这三个步骤进行讲解。</p>
<h3 id="扇区判断"><a href="#扇区判断" class="headerlink" title="扇区判断"></a>扇区判断</h3><p>三相电压可以表示为（ $U_{m}$ 为电压幅值）：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
U_a = U_{m}cos\theta \\
U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\
U_c = U_{m}cos(\theta+\frac{2}{3}\pi)
\end{array}</script><p>将其转换为 $\alpha-\beta$ 坐标系，可以算出</p>
<script type="math/tex; mode=display">
\begin{array}{l}
U_{\alpha} = U_{m}cos\theta \\
U_{\beta} = U_{m}sin\theta
\end{array}</script><p>从这个式子发现，可以从中算出角度信息从而可以判断在哪个扇区</p>
<script type="math/tex; mode=display">
\theta = arctan(\frac{U_{\beta}}{U_{\alpha}})</script><p>由于除法和反三角函数对于MCU来说计算量比较大。我们来找一个简便算法。</p>
<p> $U_{\alpha}$ 是关于cos的三角函数， $U_{\beta}$ 是关于sin的三角函数，可以得到：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
扇区1:& U_{\alpha} > 0&,& U_{\beta} > 0\\
扇区2:& U_{\alpha} >or< 0&,& U_{\beta} > 0\\
扇区3:& U_{\alpha} < 0&,& U_{\beta} > 0\\
扇区4:& U_{\alpha} < 0&,& U_{\beta} < 0\\
扇区5:& U_{\alpha} >or< 0&,& U_{\beta} < 0\\
扇区6:& U_{\alpha} > 0&,& U_{\beta} < 0
\end{array}</script><p>可以看到，通过 $U_{\beta}$ 的正负可以判断出是1/2/3扇区还是4/5/6扇区。</p>
<p>这个条件只将扇区分为两个部分，我们还需要几个条件来更细致地分。将每个扇区的反三角函数范围计算出来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
扇区1:& tan0^{\circ} >   \frac{U_{\beta}}{U_{\alpha}} > tan60^{\circ} &\Rightarrow& 
0 &>&        \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\
扇区2:& tan60^{\circ} >  \frac{U_{\beta}}{U_{\alpha}} > tan120^{\circ} &\Rightarrow& 
\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\
扇区3:& tan120^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan180^{\circ} &\Rightarrow&
-\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0        \\
扇区4:& tan180^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan240^{\circ} &\Rightarrow&
0        &>& \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\
扇区5:& tan240^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan300^{\circ} &\Rightarrow&
\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\
扇区6:& tan300^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan360^{\circ} &\Rightarrow& 
-\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0
\end{aligned}</script><p>观察这个结论， $U_{\beta}$ 和 $\sqrt{3}U_{\alpha}$ 似乎有关系，回顾反Clark变换， $U_{b}$ 和 $U_{c}$ 的式子就是这种关系。所以可以把上面的结论往反Clark变换上凑。看一下反Clark变换的图像，注意我们需要的关系里的 $\sqrt{3}$ 是乘在 $U_{\alpha}$ 上的，所以我们把 $U_{\beta}$ 和 $U_{\alpha}$ 反一下，对应的公式为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
U_{a} =  U_{\beta} \\
U_{b} = -\frac{1}{2}U_{\beta} + \frac{\sqrt3}{2}U_{\alpha}\\
U_{c} = -\frac{1}{2}U_{\beta} - \frac{\sqrt3}{2}U_{\alpha}
\end{array}\right.</script><p>生成上述公式的图像，其中黄色的线为 $U_{a}$ 为 $U_{\beta}$ ，蓝色的线 $U_{b}$ 为 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，红色的线 $U_{c}$ 为 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330145027064.png" alt="image-20220330145027064"></p>
<p>可以看到在每个扇区内总有一向大于0，两向小于0，所以 $U_{b}$ 和 $U_{c}$ 的正负可以当做判断条件之一。我们顺便还又一次得到了 $U_{\beta}$ 这个判断条件。整理一下上面的式子</p>
<script type="math/tex; mode=display">
\begin{aligned}
扇区1:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\
扇区2:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\
扇区3:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\
扇区4:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\
扇区5:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\
扇区6:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0
\end{aligned}</script><p>所以通过计算 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 的正负可以判断出是1/6扇区，3/4扇区，2扇区，5扇区的哪一组。</p>
<p>综上，我们的判断条件有： $U_{\beta}$ 、 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 。我们分别定义：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
U_a = U_{\beta} \\
U_b = \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\\
U_c = -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}
\end{array}</script><p>综合这三个条件就可以判断是在哪个扇区 。那么有没有一种算法可以将这一堆判断数值化并转换成1~6的数字呢？可以用下面的公式：</p>
<script type="math/tex; mode=display">
N=A+2B+4C</script><p>式中A代表 $U_a$ 的正负，B代表 $U_b$ 的正负，C代表 $U_c$ 的正负，大于0为1，小于0为0。最后转换出来的的N即为1~6的数字：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
扇区 & 1 & 2 & 3 & 4 & 5 & 6 & \\
N   & 3 & 1 & 5 & 4 & 6 & 2 &
\end{array}</script><p>至此，我们成功完成了扇区判断。</p>
<h3 id="计算相邻矢量作用时长"><a href="#计算相邻矢量作用时长" class="headerlink" title="计算相邻矢量作用时长"></a>计算相邻矢量作用时长</h3><p>控制相邻矢量作用时长就可以控制转子到达任意方向，下面进行分析。</p>
<h4 id="六个矢量的大小"><a href="#六个矢量的大小" class="headerlink" title="六个矢量的大小"></a>六个矢量的大小</h4><p>六个MOS管可以产生8种状态</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152650462.png" alt="image-20220330152650462" style="zoom:50%;"></p>
<p>设上开下合为0（电流从O往对应的向流），上合下开为1（电流从对应的向往O流），表示其中的六个矢量。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152634407.png" alt="image-20220330152634407"></p>
<p>放在一张图中即为：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152741018.png" alt="image-20220330152741018" style="zoom:50%;"></p>
<p>还有两个零矢量（000和111），无电流，不产生磁场。</p>
<p>对于100的状态，可以等效为下面的电路图：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330154344462.png" alt="image-20220330154344462" style="zoom:25%;"></p>
<p>可以计算出电机中三个相电压（每相相对于电机中间连接点的电压）</p>
<script type="math/tex; mode=display">
\begin{aligned}
U_{AN} &=U_{A}-U_{N}=\frac{2}{3} U_{d c} \\
U_{BN} &=U_{B}-U_{N}=-\frac{1}{3} U_{d c} \\
U_{CN} &=U_{C}-U_{N}=-\frac{1}{3} U_{d c}
\end{aligned}</script><p>同理可以计算其他所有方向矢量的相电压，可以看出，六个矢量的大小均为 $\frac{2}{3} U_{d c}$ ，即<strong>SVPWM相电压幅值为 $\frac{2}{3} U_{d c}$</strong> </p>
<h4 id="电压利用率"><a href="#电压利用率" class="headerlink" title="电压利用率"></a>电压利用率</h4><p>电压利用率等于合成矢量的电压除以母线电压。下面在复平面计算合成矢量的电压 $U_{out}$ ：</p>
<script type="math/tex; mode=display">
U_{out} = U_a +U_{b}\cdot e^{j\cdot \frac{2}{3}\pi}+U_{c}\cdot e^{j\cdot (-\frac{2}{3}\pi)}</script><p>根据欧拉公式可以推导出：</p>
<script type="math/tex; mode=display">
e^{jx}=cosx+jsinx</script><p>又因为三相电压与相电压幅值之间的关系：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
U_a = U_{m}cos\theta \\
U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\
U_c = U_{m}cos(\theta+\frac{2}{3}\pi)
\end{array}</script><p>带入可以计算出 $U_{out}$ ：</p>
<script type="math/tex; mode=display">
U_{out}=\frac{3}{2}U_m\cdot e^{j\theta}</script><p>合成矢量的电压是相电压幅值的 $\frac{3}{2}$ 倍，而SVPWM相电压幅值 $U_m$ 为 $\frac{2}{3} U_{d c}$ ，所以</p>
<script type="math/tex; mode=display">
U_{out}=U_{dc}</script><p>即<strong>合成矢量的电压等于母线电压</strong>。所以<strong>SVPWM的电压利用率是100%</strong>。</p>
<h4 id="SVPWM输出电压是马鞍波"><a href="#SVPWM输出电压是马鞍波" class="headerlink" title="SVPWM输出电压是马鞍波"></a>SVPWM输出电压是马鞍波</h4><p>由于中间连接点N的点位 是浮动的，为三角波，而相电压是每相相对于电机中间连接点N的电压，所以相电压不是一个正弦波，而是一个正弦波与一个三角波叠加而成的，即为马鞍波。网图：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/d94c427b1d664ffe9b585d58e60482f6.jpg" alt="d94c427b1d664ffe9b585d58e60482f6"></p>
<h4 id="矢量作用时长"><a href="#矢量作用时长" class="headerlink" title="矢量作用时长"></a>矢量作用时长</h4><p>合成矢量的电压是所在扇区两个矢量与空矢量不同时长的组合：</p>
<script type="math/tex; mode=display">
U_{out}=U_x\frac{T_x}{T_s}+U_y\frac{T_y}{T_s}+U_0\frac{T_0}{T_s}</script><p>由于SVPWM的输入是 $U_{\alpha}$ 和 $U_{\beta}$ ，但是要控制 $T_x$ 和 $T_y$ ，所以要找到他们的对应关系。</p>
<p>对于第一个扇区，将 $U_{out}$ 在 $\alpha-\beta$ 坐标系中表示：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
U_\alpha=|U_x|\frac{T_x}{T_s}+|U_y|\frac{T_y}{T_s}cos60^{\circ}\\
U_\beta=|U_y|\frac{T_y}{T_s}sin60^{\circ}
\end{array}</script><p>其中 $|U_x|$ 和 $|U_y|$ 根据前面的计算均为 $\frac{2}{3} U_{d c}$ ，可以解出：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\
T_y=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta
\end{array}</script><p>同理，可以计算出所有六个扇区：</p>
<p>第二扇区</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\
T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)
\end{array}</script><p>第三扇区</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_x=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\\
T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)
\end{array}</script><p>第四扇区</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\\
T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)
\end{array}</script><p>第五扇区</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\
T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)
\end{array}</script><p>第六扇区 </p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\
T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)
\end{array}</script><p>六个扇区中都有相同的项，其中包含前文判断扇区所用的 $U_1$ 、 $U_2$ 、 $U_3$ 。直接把前面已经计算过的变量拿过来使用，大大减少了计算量。式中的 $\frac{\sqrt{3}T_S}{U_{dc}}$ 为调制比，定义：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
U_{mr} = \frac{\sqrt{3}T_S}{U_{dc}} \\
X= \frac{\sqrt{3}T_S}{U_{dc}}U_\beta=U_{mr}U_1\\
Y= \frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_2\\
Z= \frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_3
\end{array}</script><p>可以将六个扇区表示为：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
& T_x & T_y  \\
扇区1&  Y  &  X  \\
扇区2& -Y  & -Z  \\
扇区3&  X  &  Z  \\
扇区4& -X  & -Y  \\
扇区5&  Z  &  Y  \\
扇区6& -Z  & -X  \\
\end{array}</script><h3 id="定时器比较值计算"><a href="#定时器比较值计算" class="headerlink" title="定时器比较值计算"></a>定时器比较值计算</h3><p>我们前文算出来的 $T_x$ 和 $T_y$ 以秒为单位，需要把 $T_x$ 和 $T_y$ 转换为定时器比较值。定时器模式使用中心对齐，只需要控制半个周期的比较值就可以产生相对中心对称的PWM波。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331141308347.png" alt="image-20220331141308347" style="zoom:50%;"></p>
<p>先来看第一扇区。在一个扇区内切换状态的时候，合理使用零矢量可以保证每一次切换只改变一路MOS管。那么第一扇区内的切换顺序就为：</p>
<script type="math/tex; mode=display">
000 \to 100 \to 110 \to 111 \to 110 \to 100 \to 000</script><p>可以看到，切换顺序构成了一个环路。在一个周期内我们需要控制三段作用时长：</p>
<script type="math/tex; mode=display">
T_s=T_x+T_y+T_N</script><p>六个MOS需要产生六路PWM来控制他们的状态。由于上下半桥是互补的，所以只需要生成三个PWM：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331151522966.png" alt="image-20220331151522966"></p>
<p>由于是中心对齐模式，所以只需要控制半个周期的时长 $\frac{T_x}{2}$ 和 $\frac{T_y}{2}$ 。在半个周期内 $T_N$ 出现了两次，分别为000和111，在半个周期内这两段时间平均分配。即为 $\frac{T_S-T_x-T_y}{4}$ 。</p>
<p>这样就可以计算三个定时器的比较值 $T_1$ 、 $T_2$ 和 $T_3$ ：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_1= \frac{T_S-T_x-T_y}{4}\\
T_2=T_a+\frac{T_x}{2}\\
T_3=T_b+\frac{T_y}{2}
\end{array}</script><p>同理，可以计算出所有六个扇区的切换顺序。通过结果可以得到结论：</p>
<p>设</p>
<script type="math/tex; mode=display">
\begin{array}{l}
T_a= \frac{T_S-T_x-T_y}{4}\\
T_b=T_a+\frac{T_x}{2}\\
T_c=T_b+\frac{T_y}{2}
\end{array}</script><p>那么六个扇区可以表示为：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
  & 扇区1 & 扇区2 & 扇区3 & 扇区4 & 扇区5 & 扇区6 & \\
T1& T_a & T_b & T_c & T_c & T_b & T_a &\\
T2& T_b & T_a & T_a & T_b & T_c & T_c &\\
T3& T_c & T_c & T_b & T_a & T_a & T_b &
\end{array}</script><p>至此，SVPWM输出比较值 $T_1$ 、 $T_2$ 、 $T_3$ ，互补得到六个比较值，输入到定时器，输出三路PWM。</p>
<h4 id="MATLAB仿真-1"><a href="#MATLAB仿真-1" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h4><p>设定Udc为24，pwm为18000</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163919487.png" alt="image-20220331163919487"></p>
<p>在foc子模块中，将park反变换的输出输入SVPWM模块：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163836635.png" alt="image-20220331163836635"></p>
<p>SVPWM模块：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[T1,T2,T3,sector]</span> = <span class="title">fcn</span><span class="params">(Ualpha,Ubeta,Udc,Tpwm)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">sector = single(<span class="number">0</span>);</span><br><span class="line">T1 = single(<span class="number">0</span>);</span><br><span class="line">T2 = single(<span class="number">0</span>);</span><br><span class="line">T3 = single(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一步：扇区判断</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ua = Ubeta;</span><br><span class="line">Ub = (<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line">Uc = (-<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% 计算判断扇区所用的ABC的值</span></span><br><span class="line">A=single(<span class="number">0</span>);B=single(<span class="number">0</span>);C=single(<span class="number">0</span>);N=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(Ua&gt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ua&lt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Ub&gt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ub&lt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Uc&gt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Uc&lt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算判断扇区所用的N的值</span></span><br><span class="line">N = A + <span class="number">2</span>*B + <span class="number">4</span>*C;</span><br><span class="line"><span class="comment">% 扇区判断</span></span><br><span class="line"><span class="keyword">switch</span> (N)   </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        sector = single(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        sector = single(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        sector = single(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        sector = single(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        sector = single(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        sector = single(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：计算相邻矢量作用时长</span></span><br><span class="line"><span class="comment">% 计算调制比</span></span><br><span class="line">Umr = <span class="built_in">sqrt</span>(<span class="number">3</span>)*Tpwm/Udc;</span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">X = Umr * Ua;</span><br><span class="line">Y = Umr * Ub;</span><br><span class="line">Z = Umr * Uc;</span><br><span class="line"><span class="comment">% 分扇区计算Tx和Ty的值</span></span><br><span class="line">Tx=single(<span class="number">0</span>);Ty=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        Tx = Y; Ty = X;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        Tx = -Y; Ty = -Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        Tx = X; Ty = Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        Tx = -X; Ty = -Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        Tx = Z; Ty = Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        Tx = -Z; Ty = -X;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：定时器比较值计算</span></span><br><span class="line"><span class="comment">% 干啥用的？</span></span><br><span class="line"><span class="keyword">if</span> Tx+Ty &gt; Tpwm</span><br><span class="line">    Tx = Tx/(Tx+Ty);</span><br><span class="line">    Ty = Ty/(Tx+Ty);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Tx = Tx;</span><br><span class="line">    Ty = Ty;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ta = (Tpwm-Tx-Ty)/<span class="number">4.0</span>;</span><br><span class="line">Tb = Ta+Tx/<span class="number">2.0</span>;</span><br><span class="line">Tc = Tb+Ty/<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">% 分扇区计算定时器比较值T1、T2和T3的值</span></span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        T1 = Ta; T2 = Tb; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        T1 = Tb; T2 = Ta; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        T1 = Tc; T2 = Ta; T3 = Tb;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        T1 = Tc; T2 = Tb; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        T1 = Tb; T2 = Tc; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        T1 = Ta; T2 = Tc; T3 = Tb;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以看到，定时器比较值为马鞍波</p>
<p><img src="/posts/Users\fanziqi\AppData\Roaming\Typora\typora-user-images\image-20220331165323898.png" alt="image-20220331165323898"></p>
<p>扇区为从1到6的循环</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331165348883.png" alt="image-20220331165348883"></p>
<h2 id="电流闭环"><a href="#电流闭环" class="headerlink" title="电流闭环"></a>电流闭环</h2><p>前文输入 $U_{d}$ 和 $U_{q}$ 到反Park变换，输出 $U_{\alpha}$ 和 $U_{\beta}$ 到SVPWM，输出三对互补的PWM到全桥，最后输出三相电压到电机。如果需要让电机以设定的电流运行，就需要PI闭环控制电流。闭环控制三相交流电流是不太容易实现的，所以我们选择闭环控制直流电流 $I_{d}$ 和 $I_{q}$ 。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/20220406114532.png" alt></p>
<p>PI控制器输入 $I_{d_{ref}}$ 和 $I_{q_{ref}}$ ，输出 $U_{d}$ 和 $U_{q}$ ，现在还需要反馈量 $I_{d}$ 和 $I_{q}$ ，这就需要用到前文讲到的正变换。用采样电阻搭配ADC采集全桥上任意两相的电流，通过基尔霍夫电流定律计算第三相电流，一并送入Clark变换输出 $I_{\alpha}$ 和 $I_{\beta}$ ，再通过Park变换产生反馈量 $I_{d}$ 和 $I_{q}$ 。</p>
<p>对于PI的参数设定，有一个参考设定值（还是需要自行调整）：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
  & P & I &\\
d& K_{pd}=\alpha L_d & K_{Id}=\alpha R\\
q& K_{pq}=\alpha L_q & K_{Iq}=\alpha R
\end{array}</script><p>其中 $\alpha$ 的取值为（ $\tau$ 为电机的时间常数）：</p>
<script type="math/tex; mode=display">
\alpha = \frac{2\pi}{\tau} \\
\tau = min\left\{\frac{L_d}{R},\frac{L_q}{R}\right\}</script><p>电机分为表贴电机和内嵌式电机，表贴式是把永磁体贴在转子表面，内嵌式是把永磁体安装在转子内。我们常用的电机都是表贴电机，对于表贴电机， $L_d=L_q=L$ ，则：</p>
<script type="math/tex; mode=display">
K_{p}=2\pi R \\
K_{I}=2\pi \frac{R^2}{L}</script><h2 id="角度和速度的获取"><a href="#角度和速度的获取" class="headerlink" title="角度和速度的获取"></a>角度和速度的获取</h2><h3 id="有感（HALL）"><a href="#有感（HALL）" class="headerlink" title="有感（HALL）"></a>有感（HALL）</h3><p>霍尔传感器分为60度和120度</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220406151555324.png" alt="image-20220406151555324"></p>
<p>画一下转一圈三个霍尔传感器的波形</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220406151530069.png" alt="image-20220406151530069"></p>
<p>这两种排列方式除了组合方式不同，其他都一样。</p>
<p>单片机通过输入捕获采集三路高低电平的跳变，通过对三路信号进行异或，则转一圈可以进6次中断，进入中断后检测IO电平就可以知道电机对应角度。但现在一圈只能获取到6个固定的角度值，无法获取到如80度这个角度。这时可以对速度进行积分得到角度，速度的获取可以通过查询60-120之间定时器的计数值来获得。但是转到80度的时候没办法获取到120度时候的定时器计数值就无法获取当前段的速度，这时可以用前一段的速度近似为当前段的速度。</p>
<h3 id="无感（EKF）"><a href="#无感（EKF）" class="headerlink" title="无感（EKF）"></a>无感（EKF）</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>前面的有感部分，是在电机上安装霍尔传感器，引出三根线到单片机通过输入捕获算出当前角度，再与预设角度完成角度闭环。</p>
<p>而无感控制则不需要霍尔传感器，只需要三根UVW线输出到电机即可，去掉了霍尔传感器和三根线，节省了成本；有些使用场合无法使用霍尔传感器，则需要使用无感，比如空调压缩机，内部充满了润滑油，无法安装霍尔传感器；有些时候有感算法或硬件出现问题也可以切换至无感，防止系统闸机，比如汽车运行中霍尔传感器突然坏了，为了使整个系统正常运行，就可以临时切换到无感。上述这些都是无感控制的优点。无感控制现在已经越来越普及，空调、洗衣机、高端风扇、汽车都在用无感控制。</p>
<h4 id="状态观测器"><a href="#状态观测器" class="headerlink" title="状态观测器"></a>状态观测器</h4><p>观测器有很多种，扩展卡尔曼滤波观测器、滑膜观测器、龙伯格观测器、自适应观测器、磁链观测器等。其中扩展卡尔曼滤波观测器的低速性能比较好，所以本文重点讨论EKF。</p>
<p>状态观测器实质上就是用数学方法建立一个可以模拟真实被控对象的模型，用这个模型来得知一些无法通过测量得到的状态量。对于电机系统来说，如果没有传感器去测量电机的转速和转子位置，那么就可以通过搭建状态观测器来估算电机的转子和转子位置，这就是基于状态观测器的电机的无传感器控制。</p>
<p>但是使用这种方法建立的观测器有着诸多问题：</p>
<ol>
<li>抗干扰能力差：加入扰动或负载，此时的状态观测器很难保持正确的响应而导致输出错误或者系统崩溃；</li>
<li>存在误差：误差主要存在与系统误差和测量误差<ol>
<li>系统误差：在建模的时候电机的参数不可能完全精确，在建模的时候造成误差。</li>
<li>测量误差：观测器需要电流作为输入，而电流的采集就会存在误差。</li>
</ol>
</li>
</ol>
<p>所以为了解决以上问题，需要给状态观测器增加反馈，通过反馈来修正状态观测器的输出，让观测器尽可能的去贴近真实的电机。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/017fc22e045b4488a08db81c18a6590f.png" alt="在这里插入图片描述"></p>
<h5 id="状态空间表示"><a href="#状态空间表示" class="headerlink" title="状态空间表示"></a>状态空间表示</h5><p>线性系统的状态空间方程为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\dot x = Ax+Bu\\
y=Hx
\end{array}\right.</script><p>永磁同步电机的方程：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
U_\alpha = Ri_\alpha + L_s \frac{di_\alpha}{dt} - \omega_e \psi_f sin\theta\\
U_\beta = Ri_\beta + L_s \frac{di_\beta}{dt} + \omega_e \psi_f cos\theta
\end{array}\right.</script><p>上述方程的含义为：将每一相抽象为一个电阻，一个电感和一个反电动势的串联，则每一相的电压为前面三项压降之和（反电动势为速度乘磁链）。方程中的电阻R、电感L、和磁链flux为电机的固有参数，电流可以通过采样电阻得到，只剩下了角度和转速，将电机方程转化为状态空间表达：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\frac{d i_\alpha}{dt} = -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta + \frac{1}{L_s}U_\alpha \\
\frac{d i_\beta}{dt} = -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta + \frac{1}{L_s}U_\beta \\
\frac{d \omega_e}{dt} = 0 \\
\frac{d \theta}{dt} = \omega_e
\end{array}\right.</script><h5 id="矩阵化表示"><a href="#矩阵化表示" class="headerlink" title="矩阵化表示"></a>矩阵化表示</h5><p>接下来我们将上面的式子整理成矩阵形式，首先确认状态变量分别为 $ \dot{i_\alpha},\dot{i_\beta},\dot{\omega_e},\dot{\theta}$ ，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dot{x}=
\begin{bmatrix}
 \dot{i_\alpha} \\
 \dot{i_\beta} \\
 \dot{\omega_e} \\
 \dot{\theta} \\
\end{bmatrix}
\quad
x=
\begin{bmatrix}
 i_\alpha \\
 i_\beta \\
 \omega_e \\
 \theta \\
\end{bmatrix}
\end{aligned}</script><p>输入 $u$ ，对于电机来说就是电压，我们选择 $\alpha-\beta$ 坐标系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
u=
\begin{bmatrix}
 U_\alpha \\
 U_\beta \\
\end{bmatrix}
\end{aligned}</script><p>输出矩阵 $y$ 为通过采样电阻测得的电流：</p>
<script type="math/tex; mode=display">
\begin{aligned}
y=
\begin{bmatrix}
 i_\alpha \\
 i_\beta \\
\end{bmatrix}
\end{aligned}</script><p>则 $H$ 和 $B$ 矩阵就可以表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
H=
\begin{bmatrix}
 1 & 0 & 0 & 0 \\
 0 & 1 & 0 & 0 \\
\end{bmatrix}
\quad
B=
\begin{bmatrix}
 \frac{1}{L_s} & 0 \\
 0 & \frac{1}{L_s} \\
 0 & 0 \\
 0 & 0 \\
\end{bmatrix}
\end{aligned}</script><p>此时矩阵形式的表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}
i_{\alpha} \\
\dot{i}_{\beta} \\
\dot{\omega} \\
\dot{\theta}
\end{bmatrix}
 & = 
\begin{bmatrix}
-\frac{R}{L_{S}} i_{\alpha}+\frac{1}{L_{s}} \omega_{e} \psi_{f} \sin \theta \\
-\frac{R}{L_{S}} i_{\beta}-\frac{1}{L_{s}} \omega_{e} \psi_{f} \cos \theta \\
0 \\
\omega_{e}
\end{bmatrix}+\begin{bmatrix}
\frac{1}{L_{s}} & 0 \\
0 & \frac{1}{L_{s}} \\
0 & 0 \\
0 & 0
\end{bmatrix}\begin{bmatrix}
u_{\alpha} \\
u_{\beta}
\end{bmatrix}\\
\begin{bmatrix}
i_{\alpha} \\
i_{\beta}
\end{bmatrix}
 & = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
i_{\alpha} \\
i_{\beta} \\
\omega_{e} \\
\theta
\end{bmatrix}
\end{aligned}</script><p>对比状态空间表示，无法显式地表示出线性的 $Ax$ ，因为电机系统不是线性的，所以用 $f(x)$ 这一非线性项替代这一项。 $f(x)$ 定义为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)=
\begin{bmatrix}
 -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta \\
 -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta \\
 0 \\
 \omega_e \\
\end{bmatrix}
\end{aligned}</script><p>则此时的状态空间方程变为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\dot x = f(x)+Bu\\
y=Hx
\end{array}\right.</script><h4 id="扩展卡尔曼滤波器"><a href="#扩展卡尔曼滤波器" class="headerlink" title="扩展卡尔曼滤波器"></a>扩展卡尔曼滤波器</h4><p>关于卡尔曼滤波器的知识请看这篇文章：<a href="https://www.robotsfan.com/posts/b4727fbe.html">手撕卡尔曼滤波器</a></p>
<p>扩展卡尔曼滤波器（Extend Kalman Filter），简称EKF。带“扩展”二字，是因为卡尔曼滤波器只能处理线性系统，而电机是一个非线性，强耦合的系统，使用扩展卡尔曼滤波器可以处理这种非线性系统。</p>
<p>前文的状态空间方程中 $f(x)$ 是非线性的，如果想对非线性系统进行卡尔曼滤波，需要对其线性化（Linearization），泰勒级数展开是将非线性系统线性化的一种方法。将 $f(x)$ 泰勒级数展开并取前两项：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)=f(x_0)+\frac{\partial f(x)}{\partial x}(x-x_0)
\end{aligned}</script><p>对 $f(x)$ 求偏导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F = \frac{\partial f(x)}{\partial x}=
\begin{bmatrix}
-\frac{R}{L_{S}} & 0 & \frac{\psi_{f} \sin \theta}{L_{S}} & \frac{\omega_{e} \psi_{f} \cos \theta}{L_{S}} \\
0 & -\frac{R}{L_{S}} & -\frac{\psi_{f} \cos \theta}{L_{S}} & \frac{\omega_{e} \psi_{f} \sin \theta}{L_{S}} \\
0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0
\end{bmatrix}
\end{aligned}</script><p>此时状态空间方程变为：</p>
<script type="math/tex; mode=display">
\dot{x}=f(x_{0})+F(x-x_{0})+B u</script><p>状态方程是建立在连续系统的基础上，需要将其转化成离散化系统后，才能在微控制器中实现卡尔曼滤波状态观测器。在离散化系统中， $\dot{x}=\frac{x_{k}-x_{k-1}}{\Delta t}$ ，则状态空间方程表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{x_{k}-x_{k-1}}{\Delta t}  &= f(x_{k-1})+B u_{k-1}\\
x_{k}&=x_{k-1}+(f(x_{k-1})+B u_{k-1}) \Delta t\\
&=(I+F\Delta t)x_{k-1}+B u_{k-1}\Delta t
\end{aligned}</script><p>令 $A=(I+F\Delta t)$ ，扩展卡尔曼滤波器的流程为以下五步：</p>
<ul>
<li><p>预测</p>
<ol>
<li><p>计算预估值</p>
<p>$\hat{x}_k^-=\hat{x}_{k-1}+(f(x_{k-1})+B u_{k-1}) \Delta t$</p>
</li>
<li><p>计算误差协方差</p>
<p>$P_k^-=(I+F\Delta t)P_{k-1}(I+F\Delta t)^T+Q$</p>
</li>
</ol>
</li>
<li><p>校正</p>
<ol>
<li><p>计算卡尔曼增益</p>
<p>$K_k=P_k^-H^T(HP_k^-H^T+R)^{-1}$</p>
</li>
<li><p>修正预估值</p>
<p>$\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)$ </p>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>更新误差协方差，用于下一次计算</p>
<p>$P_k=(I-K_kH)P_k^-$ </p>
</li>
</ol>
<p>上面的五个方程中， $\Delta t$ 为采样时间， $Q$ 为模型误差， $R$ 为测量误差</p>
<p>在MATLAB中建立EKF观测器，需要建立全局变量x和P用于保存每一次迭代的值给下一次迭代使用：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x_posteriori</span>  = <span class="title">fcn</span><span class="params">(Ialpha,Ibeta,Ualpha,Ubeta,Ls,Rs,Flux)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> x;</span><br><span class="line"><span class="keyword">global</span> P;</span><br><span class="line"></span><br><span class="line">R=[<span class="number">0.02</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.02</span>];</span><br><span class="line">Q=[<span class="number">0.01</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.01</span>];</span><br><span class="line">Time=<span class="number">0.0001</span>;</span><br><span class="line"></span><br><span class="line">u=[Ualpha;Ubeta];</span><br><span class="line">y=[Ialpha;Ibeta];</span><br><span class="line">H=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">B=[<span class="number">1</span>/Ls,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>/Ls;<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">F=[-Rs/Ls,<span class="number">0</span>,Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls,x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>,-Rs/Ls,-Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls,x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">f=[-Rs*Ialpha/Ls+x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;-Rs*Ibeta/Ls-x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>;x(<span class="number">3</span>,<span class="number">1</span>)];</span><br><span class="line"><span class="comment">% 计算预估值</span></span><br><span class="line">x_prior=x+(f+B*u)*Time;</span><br><span class="line"><span class="comment">% 计算误差协方差</span></span><br><span class="line">A=(<span class="built_in">eye</span>(<span class="number">4</span>)+F*Time);</span><br><span class="line">P_prior=A*P*A&#x27;+Q;</span><br><span class="line"><span class="comment">% 计算卡尔曼增益</span></span><br><span class="line">K=(P_prior*H&#x27;)/(H*P_prior*H&#x27;+R);</span><br><span class="line"><span class="comment">% 修正预估值</span></span><br><span class="line">x_posteriori=x_prior+K*(y-H*x_prior);</span><br><span class="line"><span class="comment">% 更新误差协方差</span></span><br><span class="line">P_posteriori=(<span class="built_in">eye</span>(<span class="number">4</span>)-K*H)*P_prior;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x_posteriori(<span class="number">4</span>,<span class="number">1</span>)&gt;(<span class="number">2</span>*<span class="built_in">pi</span>)</span><br><span class="line">    x_posteriori(<span class="number">4</span>,<span class="number">1</span>)=x_posteriori(<span class="number">4</span>,<span class="number">1</span>)-(<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x=x_posteriori;</span><br><span class="line">P=P_posteriori;</span><br></pre></td></tr></table></figure>
<p>调整R矩阵和Q矩阵至最优，查看观测器效果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220416201249667.png" alt="image-20220416201249667"></p>
<p>蓝色为观测角度，黄色为真实角度。可以看到经过很短时间的迭代，观测器就已经可以很好地预测电机角度，至此完成了EKF无感算法。</p>
<h2 id="速度闭环"><a href="#速度闭环" class="headerlink" title="速度闭环"></a>速度闭环</h2>]]></content>
      <categories>
        <category>电机</category>
      </categories>
      <tags>
        <tag>FOC</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitbook</title>
    <url>/posts/d5c8f039.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Gitbook"><a href="#Gitbook" class="headerlink" title="Gitbook"></a>Gitbook</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装gitbook"><a href="#安装gitbook" class="headerlink" title="安装gitbook"></a>安装gitbook</h3><p>gitbook基于Node.js，所以要先安装Node.js，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F">官网</a>。</p>
<p>安装好node后，安装gitbook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g gitbook-cli</span><br><span class="line">//当前目录下安装</span><br><span class="line">npm install gitbook-cli</span><br></pre></td></tr></table></figure>
<h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><p>安装好之后执行<code>gitbook -V</code>检查版本，不出意外应该会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CLI version: 2.3.2</span><br><span class="line">Installing GitBook 3.2.3</span><br><span class="line">/xxx/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287</span><br><span class="line">      <span class="keyword">if</span> (cb) cb.apply(this, arguments)</span><br><span class="line">                 ^</span><br><span class="line"></span><br><span class="line">TypeError: cb.apply is not a <span class="keyword">function</span></span><br><span class="line">    at /data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18</span><br><span class="line">    at FSReqCallback.oncomplete (fs.js:169:5)</span><br></pre></td></tr></table></figure>
<p>此时需要进入上面给出的目录，找到polyfills.js，将62-64注释掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs.stat = statFix(fs.stat)</span></span><br><span class="line"><span class="comment">//fs.fstat = statFix(fs.fstat)</span></span><br><span class="line"><span class="comment">//fs.lstat = statFix(fs.lstat)</span></span><br></pre></td></tr></table></figure>
<p>此时运行<code>gitbook -V</code>不会报错。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>新建一个工程目录，在目录下执行<code>gitbook init</code>，应该又报错了。这是因为node的版本太高了，需要对node进行降级。这里我推荐使用nvm来管理nodeJs的版本。因为我还有使用高版本node的需求，而且降级也挺麻烦的。nvm的<a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a>，选择nvm-setup.zip，安装时第二个路径要选择nodejs的安装路径。</p>
<p>查看安装的nodejs版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure>
<p>安装低版本nodejs，这个版本经测试可用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install v12.22.3</span><br></pre></td></tr></table></figure>
<p>等待安装完，切换版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm use v12.22.3</span><br></pre></td></tr></table></figure>
<p>回到工程根目录再次初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure>
<p>初始化成功，创建了<code>README.md</code>（书籍的介绍）和<code>SUMMARY.md</code>（书籍的目录结构）</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这里拿自动目录插件举例，在工程根目录下创建一个<code>book.json</code>，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;summary&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根目录下执行<code>gitbook install ./</code>即可安装插件。启动服务后这个插件会自动生成目录。下文会讲解如何生成目录。</p>
<h2 id="加入文章"><a href="#加入文章" class="headerlink" title="加入文章"></a>加入文章</h2><p>在根目录下创建文件夹，以数字和短横线开头：<code>0-Example</code>，同样<code>0-Example</code>下也可以创建子文件夹。每一个文件夹相当于一个目录，子文件夹就是多级目录。</p>
<p>每一个子文件夹下要有一个命名为<code>0-README.md</code>的文件，用于放置这个目录的简介，其他md文件也要以数字和短横线开头：<code>1-TestPage.md</code></p>
<h2 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h2><p>加入好文章之后，启动本地服务，前文安装的summary插件会自动生成层级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中打开<a href="http://localhost:4000/，检验你的成果！">http://localhost:4000/，检验你的成果！</a></p>
]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署至云服务器的宝塔面板</title>
    <url>/posts/6b69667c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo部署至云服务器的宝塔面板"><a href="#Hexo部署至云服务器的宝塔面板" class="headerlink" title="Hexo部署至云服务器的宝塔面板"></a>Hexo部署至云服务器的宝塔面板</h1><blockquote>
<p>本文为网络转载, 版权属于：Heson</p>
<p>原文链接：<a href="https://www.heson10.com/posts/51315.html">https://www.heson10.com/posts/51315.html</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo 博客部署方法有好多种，<code>github pages</code>、<code>gitee pages(pro)</code>、<code>vercel</code>，<code>cloudflare page</code>、<code>阿里云oss</code>、<code>腾讯存储桶</code>等等这些不需要购买服务器的部署方式。一般大部分都用以上方式部署自己的hexo博客，但也有少部分部署在<code>自己服务器</code>的同志。</p>
<p>新手部署服务器最常见的方法就是：直接把本地生成的<code>public</code>中的文件，直接ftp到服务器<code>www根目录</code>，简单粗暴。</p>
<p>还有一种更优雅地方式，那就是直接在服务器上搭建<code>git仓库</code>，hexo三连直接<code>deploy</code>上去（跟搭建在github pages上的方式一样）。</p>
<h2 id="为什么要部署至服务器？"><a href="#为什么要部署至服务器？" class="headerlink" title="为什么要部署至服务器？"></a>为什么要部署至服务器？</h2><p>个人感觉手头有闲置的网速较快的服务器，可以尝试部署至服务器。</p>
<p>比如我手头有一个<code>腾讯云香港二区 2核 4GB 5M的服务器。</code>对比了一下我放在又拍云cdn上的主站网速，可以看到：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-1.png" alt="hexo-bt-1"></p>
<p><strong>这速度可谓不相上下。</strong></p>
<p>相比起github pages的慢、coding pages的抽（移动宽带经常抽），服务器部署还是有一定优势的。</p>
<p>当然，如果域名<code>备案</code>了，手头没有闲置的<code>服务器</code>，还是建议嫖上国内的CDN（又拍云）。</p>
<h2 id="部署教程"><a href="#部署教程" class="headerlink" title="部署教程"></a>部署教程</h2><p>老样子，简单说下思路：</p>
<ul>
<li>服务器安装宝塔面板</li>
<li>创建git仓库，并配置git钩子，自动同步文件到网站目录</li>
<li>配置网站访问设置</li>
<li>本地<code>git deploy</code>设置</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.云服务安装宝塔面板</p>
<p>2.本地生成ssh秘钥备用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub的邮箱&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;GitHub的邮箱&quot;</span><br></pre></td></tr></table></figure>
<h3 id="连接服务器终端"><a href="#连接服务器终端" class="headerlink" title="连接服务器终端"></a>连接服务器终端</h3><p>宝塔面板用户可直接左侧导航栏<code>终端</code>登录（如图）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-2.png" alt="hexo-bt-2"></p>
<ul>
<li>切换到 <code>root</code> 账号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure>
<p>宝塔默认是root账号，注意看图：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-3.png" alt="hexo-bt-3"></p>
<ul>
<li>安装 <code>git</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure>
<h3 id="创建-Git-账户"><a href="#创建-Git-账户" class="headerlink" title="创建 Git 账户"></a>创建 Git 账户</h3><p>创建 Git 账户并赋予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">chmod 740 /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>编辑 <code>/etc/sudoers</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>键进入编辑模式，找到<code>root ALL=(ALL) ALL</code>，在其下方加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-4.png" alt="hexo-bt-4"></p>
<p>输入完成后按<code>esc</code>，再输入<code>:wq</code>，保存退出。</p>
<p>更变<code>/etc/sudoers</code>权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>设置 git 账户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure>
<p>输入密码，输入的时候是看不到任何显示的，输完回车即可。</p>
<p>切换至 <code>git 用户</code>，创建 <code>~/.ssh</code> 文件夹和 <code>~/.ssh/authorized_keys</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>同样<code>i</code>进入编辑模式，把之前本地准备的<code>id_rsa.pub</code>文件中的公钥复制进去，按<code>esc</code>后，输入<code>:wq</code>保存。<strong>(注意!!!!!!!!!!! 最后一行要加回车)</strong></p>
<p>更改权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 /home/git/.ssh/authorized_keys</span><br><span class="line">chmod 700 /home/git/.ssh</span><br></pre></td></tr></table></figure>
<p>本地测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -v git@服务器ip地址或域名</span><br></pre></td></tr></table></figure>
<p>不用输密码就成了。</p>
<h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p>切换为<code>root</code>用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure>
<p>创建<code>repo</code>作为仓库目录，并加权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/repo</span><br><span class="line">chown -R git:git /var/repo</span><br><span class="line">chmod -R 755 /var/repo</span><br></pre></td></tr></table></figure>
<p>创建 hexo 目录作为网站根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/hexo</span><br><span class="line">chown -R git:git /var/hexo</span><br><span class="line">chmod -R 755 /var/hexo</span><br></pre></td></tr></table></figure>
<p>创建一个空白的 git 仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure>
<p>编辑一个 Git 钩子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>进入编辑模式，添加下面的代码，按<code>esc</code>输入<code>:wq</code> 保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure>
<p>更改权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git /var/repo/hexo.git/hooks/post-receive</span><br><span class="line">chmod +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<h3 id="宝塔网站配置"><a href="#宝塔网站配置" class="headerlink" title="宝塔网站配置"></a>宝塔网站配置</h3><p>创建一个网站</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-5.png" alt="hexo-bt-5"></p>
<h3 id="本地-Git-deploy-设置"><a href="#本地-Git-deploy-设置" class="headerlink" title="本地 Git deploy 设置"></a>本地 Git deploy 设置</h3><p>安装git部署插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>在博客根目录配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@服务器ip或域名:/var/repo/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>配置完成后，可直接hexo三连到自己的服务器。简单快捷。</p>
<p>如果报错:<code>error: remote unpack failed: index-pack abnormal exit</code>, 删除<code>/var/hexo</code>下的所有文件. 包括<code>.user.ini</code>, 这个文件作用为防跨站, 添加权限之后可以再添加回来.</p>
<p>重新给权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git /var/repo</span><br><span class="line">chmod -R 755 /var/repo</span><br><span class="line"></span><br><span class="line">chown -R git:git /var/hexo</span><br><span class="line">chmod -R 755 /var/hexo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作</title>
    <url>/posts/c4c88997.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><ul>
<li><p>安装</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看版本</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成密钥</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUREMAIL&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看公钥</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub </span><br></pre></td></tr></table></figure>
</li>
<li><p>GIthub -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key</p>
</li>
<li><p>检查本地是否能远程访问github服务器，出现You’ve successfully authenticated，说明认证通过。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置自己的名称和电子邮件地址</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;YOURNAME&quot;</span><br><span class="line">git config --global user.email &quot;YOUREMAIL&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看设置</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>新项目</p>
<ul>
<li><p>建立新的repository</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/new</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建目录</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/test_project</span><br><span class="line">cd ~/test_project</span><br><span class="line">git init //初始化一个空的git repository  </span><br><span class="line">git remote add origin https://github.com//username//test_project.git //第一次初始化</span><br><span class="line">git checkout -b main //切换本地分支为main</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add . //添加文件</span><br><span class="line">git commit -am &quot;first commit&quot; //-m指定本次提交的描述信息 </span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置set-upstream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/main main</span><br><span class="line">git push //之后push用这个</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>已有项目</p>
<ul>
<li><p>clone下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:fan-ziqi/My_ROS_Robot.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/test_project</span><br><span class="line">cd ~/test_project</span><br><span class="line">git init //初始化一个空的git repository  </span><br><span class="line">git remote add origin https://github.com//username//test_project.git //第一次初始化</span><br><span class="line">git checkout -b main //切换本地分支为main</span><br></pre></td></tr></table></figure>
</li>
<li><p>pull下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置set-upstream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/main main</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .   // .代表添加所有文件  </span><br><span class="line">git commit -am &quot;对文件操作的简易描述&quot;  </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>出现错误<code>error: failed to push some refs to &#39;https://github.com/xxx/xxx.git&#39;</code></p>
<p>出现错误的原因是github中的某些文件不在本地代码目录中。</p>
<p>也就是说我们需要先将远程代码库中的任何文件先pull到本地代码库中，才能push新的代码到github代码库中。</p>
<p>使用如下命令：git pull —rebase origin main</p>
<p>然后再进行上传: git push -u origin main</p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MPU6050-DMP读不出数据</title>
    <url>/posts/bfa5a820.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MPU6050-DMP读不出数据"><a href="#MPU6050-DMP读不出数据" class="headerlink" title="MPU6050-DMP读不出数据"></a>MPU6050-DMP读不出数据</h1><p>遇上一个很头疼的问题，MPU6050可以正常读取三个轴的数据，但是使用DMP方式读取数据时，会卡在这一句上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get a packet. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mpu_read_fifo_stream</span>(dmp.packet_length, fifo_data, more))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>进入此函数，通过逐句debug，发现卡在这一句上了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!st.chip_cfg.dmp_on)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>问题来了，这说的是dmp没有打开啊？？可是前面命名已经使能了DMP</p>
<p>于是打开百度，同样问题的解答有以下几点</p>
<ul>
<li>MPU6050供电问题，经检查确实为3.3V，故排除</li>
<li>FIFO没有使能，经检查也有使能，排除</li>
</ul>
<p>嘶 那问题出在哪呢</p>
<p><strong>MPU6050不讲武德，它坏了</strong></p>
<p><strong>换一个芯片就好了</strong></p>
<p><strong>RNM退钱！</strong></p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习笔记</title>
    <url>/posts/404e593e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><h2 id="1-导入图像视频和网络摄像头"><a href="#1-导入图像视频和网络摄像头" class="headerlink" title="1 导入图像视频和网络摄像头"></a>1 导入图像视频和网络摄像头</h2><p>首先包含三个常用的头文件和IO库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>然后需要使用命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-图像"><a href="#1-1-图像" class="headerlink" title="1.1 图像"></a>1.1 图像</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先需要定义图像文件路径，使用string类型来存储</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">    <span class="comment">// 用Mat类型读取图像</span></span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;图像&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 使用waitKey进行一个延时，否则图像会立即关闭。0为无穷大，即不会关闭。</span></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-视频"><a href="#1-2-视频" class="headerlink" title="1.2 视频"></a>1.2 视频</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先需要定义视频文件路径，使用string类型来存储</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_video.mp4&quot;</span>;</span><br><span class="line">	<span class="comment">// 构造VideoCapture类型对象</span></span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line">	<span class="comment">// 单帧图像</span></span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="comment">// 对于视频来说需要捕获所有帧并显示，所以需要while循环。</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 读取一帧图像</span></span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		<span class="comment">// 显示图像</span></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;视频&quot;</span>, img);</span><br><span class="line">		<span class="comment">// 这时需要延时，否则视频非常快</span></span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视频结束后会抛出错误（无法读取文件），原因为视频结束后没有图像送入img所以报错。</p>
<h3 id="1-3-摄像头"><a href="#1-3-摄像头" class="headerlink" title="1.3 摄像头"></a>1.3 摄像头</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 摄像头不需要路径，需要输入相机的ID号，剩下的和读取视频一样</span></span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;摄像头&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-基本函数"><a href="#2-基本函数" class="headerlink" title="2 基本函数"></a>2 基本函数</h2><p>前文包含的头文件<code>#include &lt;opencv2/imgproc.hpp&gt;</code>就是图像处理的头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	Mat imgGray;</span><br><span class="line">	<span class="comment">// “convert”，即为转换图像的颜色空间，这里将彩色图想转换为灰度图像</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line"></span><br><span class="line">	Mat imgBlur;</span><br><span class="line">	<span class="comment">// 添加高斯模糊(7*7)</span></span><br><span class="line">	<span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line"></span><br><span class="line">	Mat imgCanny;</span><br><span class="line">	<span class="comment">// 边缘检测，通常在边缘检测前对图像进行一次高斯模糊(可以自行对比有什么区别)</span></span><br><span class="line">	<span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀</span></span><br><span class="line">	Mat imgDil, imgErode;</span><br><span class="line">	<span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgDil);</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Erode&quot;</span>, imgErode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122257889.png" alt="image-20220309122257889"></p>
<h2 id="3-对图像进行伸缩和剪裁"><a href="#3-对图像进行伸缩和剪裁" class="headerlink" title="3 对图像进行伸缩和剪裁"></a>3 对图像进行伸缩和剪裁</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 伸缩</span></span><br><span class="line">	Mat imgResize;</span><br><span class="line">	<span class="comment">// 使用size方法查看图像尺寸</span></span><br><span class="line">	cout &lt;&lt; img.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 可以调整成具体的大小</span></span><br><span class="line">	<span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">400</span>,<span class="number">600</span>));</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Resize Size()&quot;</span>, imgResize);</span><br><span class="line">	<span class="comment">// 也可以调整缩放比例fxfy</span></span><br><span class="line">	<span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(),<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Resize &quot;</span>, imgResize);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 裁剪</span></span><br><span class="line">	Mat imgCrop;</span><br><span class="line">	<span class="comment">// 矩形数据类型，前两个参数为剪裁起点（左上角 x = 0, y = 0），后两个参数为宽和高</span></span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(<span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 使用刚刚定义的矩形对图像进行裁剪</span></span><br><span class="line">	imgCrop = <span class="built_in">img</span>(roi);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122213509.png" alt="image-20220309122213509"></p>
<h2 id="4-绘制形状和文字"><a href="#4-绘制形状和文字" class="headerlink" title="4 绘制形状和文字"></a>4 绘制形状和文字</h2><p>下文中，使用Point()定义一个点，使用Scalar()定义一个标量（颜色）</p>
<p>绘制形状和文字所用函数中最后两个参数均为颜色和厚度(FILLED为填充)，不再重复说明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个空白图像，512*512大小，8位3通道(CV_8UC3)，白色(255,255,255)</span></span><br><span class="line">	<span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">512</span>, <span class="number">512</span>, CV_8UC3, Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画圆 传入圆心，半径</span></span><br><span class="line">	<span class="built_in">circle</span>(img, <span class="built_in">Point</span>(<span class="number">256</span>, <span class="number">256</span>), <span class="number">155</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),FILLED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画矩形 传入左上角与右下角点的坐标</span></span><br><span class="line">	<span class="built_in">rectangle</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">226</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">286</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画线 传入起点和终点的坐标</span></span><br><span class="line">	<span class="built_in">line</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">296</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">296</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制文字 传入文字，左上角坐标，字体，比例</span></span><br><span class="line">	<span class="built_in">putText</span>(img, <span class="string">&quot;OpenCV Learning&quot;</span>, <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">262</span>), FONT_HERSHEY_COMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122144678.png" alt="image-20220309122144678"></p>
<h2 id="5-透视变换"><a href="#5-透视变换" class="headerlink" title="5 透视变换"></a>5 透视变换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/cards.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以使用画图工具获取到点坐标，使用Point2f创建浮点数</span></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>,<span class="number">142</span>&#125;,&#123;<span class="number">771</span>,<span class="number">190</span>&#125;,&#123;<span class="number">405</span>,<span class="number">395</span>&#125;,&#123;<span class="number">674</span>,<span class="number">457</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 变换后的大小</span></span><br><span class="line">	<span class="keyword">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建变换矩阵</span></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 透视变换</span></span><br><span class="line">	Mat imgWarp;</span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Size</span>(w, h));</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示四个顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，成功将图形矫正</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122100872.png" alt="image-20220309122100872"></p>
<h2 id="6-颜色识别"><a href="#6-颜色识别" class="headerlink" title="6 颜色识别"></a>6 颜色识别</h2><p>颜色识别需要设定选取好的hsv三个通道的最大值和最小值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/lambo.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">	Mat imgHSV;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义选取好的六个值</span></span><br><span class="line">	<span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line">	<span class="keyword">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line">	<span class="comment">// 定义下限和上限</span></span><br><span class="line">	<span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">	<span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建遮罩</span></span><br><span class="line">	Mat mask;</span><br><span class="line">	<span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行查看效果</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121922828.png" alt="image-20220309121922828"></p>
<p>上面的值可以使用Trackbar试出来，替换一张图片再次尝试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">	Mat imgHSV;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设定初始值</span></span><br><span class="line">	<span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">0</span>, vmin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> hmax = <span class="number">179</span>, smax = <span class="number">255</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建遮罩</span></span><br><span class="line">	Mat mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义窗口名</span></span><br><span class="line">	<span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line">	<span class="comment">// 创建Trackbar</span></span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">		<span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">		<span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始值是这样的</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121750288.png" alt="image-20220309121750288"></p>
<p>因为这张图里都是确定的颜色，所以只需要拖动前两行即可筛选出想要的颜色</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121842503.png" alt="image-20220309121842503"></p>
<h2 id="7-形状识别"><a href="#7-形状识别" class="headerlink" title="7 形状识别"></a>7 形状识别</h2><p>本节将学习如何检测圆形、正方形、矩形、三角形这些形状，和识别出图像中的轮廓</p>
<h3 id="7-1-预处理"><a href="#7-1-预处理" class="headerlink" title="7.1 预处理"></a>7.1 预处理</h3><p>首先对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。详见</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在识别形状之前需要对图片进行一系列的预处理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 灰度处理</span></span><br><span class="line">	Mat imgGray;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯模糊</span></span><br><span class="line">	Mat imgBlur;</span><br><span class="line">	<span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边缘检测</span></span><br><span class="line">	Mat imgCanny;</span><br><span class="line">	<span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 膨胀和腐蚀</span></span><br><span class="line">	Mat imgDil, imgErode;</span><br><span class="line">	<span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//	// 在这里进行边缘检测</span></span><br><span class="line"><span class="comment">//	getContours(imgDil,img);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Dil&quot;</span>, imgDil);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从处理后的图像可以看到，单单使用边缘检测，三角形的轮廓线断断续续，会对之后的识别造成影响。经过膨胀之后的图像轮廓线是实线，边缘特性更好。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309144348598.png" alt="image-20220309144348598"></p>
<p>关闭主函数中无用的输出，只留下<code>imshow(&quot;Image&quot;, img);</code>，然后去除<code>getContours(imgDil,img);</code>的注释，再进行下一步。</p>
<h3 id="7-2-找到轮廓"><a href="#7-2-找到轮廓" class="headerlink" title="7.2 找到轮廓"></a>7.2 找到轮廓</h3><p>根据边缘找到轮廓</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment">	 * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment">	 * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 找到轮廓</span></span><br><span class="line"><span class="comment">	 * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment">	 * 		取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment">	 * 		取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment">	 * 		取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment">	 * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours</span></span><br><span class="line"><span class="comment">	 * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">drawContours</span>(img_output, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，图像轮廓被正确地识别出来了。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309134724054.png" alt="image-20220309134724054"></p>
<h3 id="7-3-去除噪声"><a href="#7-3-去除噪声" class="headerlink" title="7.3 去除噪声"></a>7.3 去除噪声</h3><p>假设图像中最小的黑色圆圈为噪声，我们要将其滤除，所以需要判断轮廓大小并对其筛选。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设图像中有噪声，需要将其过滤</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//检测轮廓大小</span></span><br><span class="line">		<span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		cout &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">drawContours</span>(img_output, contours, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，黑色噪声成功被滤除</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309135058081.png" alt="image-20220309135058081"></p>
<h3 id="7-4-识别形状"><a href="#7-4-识别形状" class="headerlink" title="7.4 识别形状"></a>7.4 识别形状</h3><p>下一步我们要找到这些轮廓的角点，并对角点的数量进行判断，例如三角形就是3，四边形就是4，圆形可能七八个，并同时绘制出边界框与形状名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">	<span class="comment">// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//	drawContours(img_output, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义图形形状字符串</span></span><br><span class="line">	string object_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line">			<span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">			cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 找出边界框</span></span><br><span class="line">			bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 通过判断角点的数量来确定是什么形状</span></span><br><span class="line">			<span class="keyword">int</span> object_corners = (<span class="keyword">int</span>)contours_corners[i].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span>(object_corners == <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				object_type = <span class="string">&quot;Triangle&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(object_corners == <span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 通过计算宽高比来区分正方形和矩形</span></span><br><span class="line">				<span class="keyword">float</span> aspect_ratio = (<span class="keyword">float</span>)bounding_box[i].width / (<span class="keyword">float</span>)bounding_box[i].height;</span><br><span class="line">				cout &lt;&lt; aspect_ratio &lt;&lt; endl;</span><br><span class="line">				<span class="comment">// 宽高比在0.95~1.05范围内算作正方形</span></span><br><span class="line">				<span class="keyword">if</span> (aspect_ratio &gt; <span class="number">0.95</span> &amp;&amp; aspect_ratio &lt; <span class="number">1.05</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					object_type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 其余的算作矩形</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					object_type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(object_corners &gt; <span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				object_type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 只绘制角点之间的边框线</span></span><br><span class="line">			<span class="built_in">drawContours</span>(img_output, contours_corners, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">			<span class="comment">// 绘制矩形，bounding_box[i].tl()左上角，bounding_box[i].br()右下角</span></span><br><span class="line">			<span class="built_in">rectangle</span>(img_output, bounding_box[i].<span class="built_in">tl</span>(), bounding_box[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">5</span>);</span><br><span class="line">			<span class="comment">// 绘制文字（什么形状），绘制在边框的左上角再往上5像素</span></span><br><span class="line">			<span class="built_in">putText</span>(img_output, object_type, <span class="built_in">Point</span>(bounding_box[i].x, bounding_box[i].y - <span class="number">5</span> ), FONT_HERSHEY_PLAIN, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，不同形状的物体被成功识别出。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309143927287.png" alt="image-20220309143927287"></p>
<h2 id="8-人脸检测"><a href="#8-人脸检测" class="headerlink" title="8 人脸检测"></a>8 人脸检测</h2><p>人脸检测需要包含<code>#include &lt;opencv2/objdetect.hpp&gt;</code>头文件</p>
<p>使用OpenCV自带的Haar特征分类器进行检测。Haar特征分类器就是一个XML文件，该文件中会描述人体各个部位的Haar特征值。包括人脸、眼睛、嘴唇等等。通常被放置在一个叫haarcascades的目录下（全盘搜索一下就能找到），有以下这些：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309152132992.png" alt="image-20220309152132992"></p>
<p>根据命名可以知道各个分类器的用途。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/face.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写级联分类器</span></span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	<span class="comment">// 加载训练好的模型（族特征数据库）这里的路径请自行修改</span></span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个矩形向量</span></span><br><span class="line">	vector&lt;Rect&gt; faces;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 族检测算法</span></span><br><span class="line"><span class="comment">	 * 参数1：image--待检测图片，一般为灰度图像加快检测速度；</span></span><br><span class="line"><span class="comment">	 * 参数2：objects--被检测物体的矩形框向量组；</span></span><br><span class="line"><span class="comment">	 * 参数3：scaleFactor--表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%;</span></span><br><span class="line"><span class="comment">	 * 参数4：minNeighbors--表示构成检测目标的相邻矩形的最小个数(默认为3个)。</span></span><br><span class="line"><span class="comment">	 * 		如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。</span></span><br><span class="line"><span class="comment">	 * 		如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，</span></span><br><span class="line"><span class="comment">	 * 		这种设定值一般用在用户自定义对检测结果的组合程序上；</span></span><br><span class="line"><span class="comment">	 * 参数5：flags--要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING</span></span><br><span class="line"><span class="comment">	 * 		如果设置为CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域，因此这些区域通常不会是人脸所在区域；</span></span><br><span class="line"><span class="comment">	 * 参数6、7：minSize和maxSize用来限制得到的目标区域的范围。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在脸四周画出矩形</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行可以看到成功检测到人脸</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309153539038.png" alt="image-20220309153539038"></p>
<p>同样地，可以对视频流进行同样的处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">		vector&lt;Rect&gt; faces;</span><br><span class="line">		faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面演示三个应用</p>
<h2 id="应用1-空间绘图"><a href="#应用1-空间绘图" class="headerlink" title="应用1 空间绘图"></a>应用1 空间绘图</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////  Project 1 - 虚拟绘图 //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints;  <span class="comment">// to store all points</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////  颜色定义 ////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用前面讲过的程序提取颜色</span></span><br><span class="line"><span class="comment">// hmin, smin, vmin hmax, smax, vmax</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; myColors&#123; &#123;<span class="number">95</span>,<span class="number">22</span>,<span class="number">49</span>,<span class="number">139</span>,<span class="number">138</span>,<span class="number">92</span>&#125;, <span class="comment">// Green</span></span><br><span class="line">							  &#123;<span class="number">144</span>,<span class="number">76</span>,<span class="number">63</span>,<span class="number">179</span>,<span class="number">166</span>,<span class="number">154</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line">vector&lt;Scalar&gt; myColorValues&#123; &#123;<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>&#125;,		<span class="comment">// Green</span></span><br><span class="line">							  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">getContours</span><span class="params">(Mat img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义笔头位置</span></span><br><span class="line">	<span class="function">Point <span class="title">myPoint</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">			cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 设定笔头位置为设定点</span></span><br><span class="line">			myPoint.x = bounding_box[i].x + bounding_box[i].width / <span class="number">2</span>;</span><br><span class="line">			myPoint.y = bounding_box[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//			// 显示角和边界框</span></span><br><span class="line"><span class="comment">//			drawContours(img, contours_corners, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//			rectangle(img, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> myPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findColor</span>(Mat img)</span><br><span class="line">&#123;</span><br><span class="line">	Mat imgHSV;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myColors.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Scalar <span class="title">lower</span><span class="params">(myColors[i][<span class="number">0</span>], myColors[i][<span class="number">1</span>], myColors[i][<span class="number">2</span>])</span></span>;</span><br><span class="line">		<span class="function">Scalar <span class="title">upper</span><span class="params">(myColors[i][<span class="number">3</span>], myColors[i][<span class="number">4</span>], myColors[i][<span class="number">5</span>])</span></span>;</span><br><span class="line">		Mat mask;</span><br><span class="line">		<span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="built_in">to_string</span>(i), mask);</span><br><span class="line">		Point myPoint = <span class="built_in">getContours</span>(mask);</span><br><span class="line">		<span class="keyword">if</span> (myPoint.x != <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 每个myPoint都有三个值，xy和颜色序号</span></span><br><span class="line">			newPoints.<span class="built_in">push_back</span>(&#123; myPoint.x,myPoint.y,i &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawOnCanvas</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newPoints.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(img, <span class="built_in">Point</span>(newPoints[i][<span class="number">0</span>],newPoints[i][<span class="number">1</span>]), <span class="number">10</span>, myColorValues[newPoints[i][<span class="number">2</span>]], FILLED);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		newPoints = <span class="built_in">findColor</span>(img);</span><br><span class="line">		<span class="built_in">drawOnCanvas</span>(newPoints, myColorValues);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-应用2-文章扫描"><a href="#10-应用2-文章扫描" class="headerlink" title="10 应用2 文章扫描"></a>10 应用2 文章扫描</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 2 - Document Scanner  //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat imgOriginal, imgGray, imgBlur, imgCanny, imgThre, imgDil, imgErode, imgWarp, imgCrop;</span><br><span class="line">vector&lt;Point&gt; initialPoints,docPoints;</span><br><span class="line"><span class="keyword">float</span> w = <span class="number">420</span>, h = <span class="number">596</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">preProcessing</span><span class="params">(Mat img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line">	<span class="comment">//erode(imgDil, imgErode, kernel);</span></span><br><span class="line">	<span class="keyword">return</span> imgDil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">getContours</span><span class="params">(Mat image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(image, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">	<span class="comment">//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	vector&lt;Point&gt; biggest;</span><br><span class="line">	<span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		string objectType;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (area &gt; maxArea &amp;&amp; conPoly[i].<span class="built_in">size</span>()==<span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">				biggest = &#123; conPoly[i][<span class="number">0</span>],conPoly[i][<span class="number">1</span>] ,conPoly[i][<span class="number">2</span>] ,conPoly[i][<span class="number">3</span>] &#125;;</span><br><span class="line">				maxArea = area;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line">			<span class="comment">//rectangle(imgOriginal, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawPoints</span><span class="params">(vector&lt;Point&gt; points, Scalar color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(imgOriginal, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line">		<span class="built_in">putText</span>(imgOriginal, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">reorder</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Point&gt; newPoints;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line">		subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//0</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//1</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//2</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">getWarp</span><span class="params">(Mat img, vector&lt;Point&gt; points, <span class="keyword">float</span> w, <span class="keyword">float</span> h )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imgWarp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string path = <span class="string">&quot;res/paper.jpg&quot;</span>;</span><br><span class="line">	imgOriginal = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">resize</span>(imgOriginal, imgOriginal, <span class="built_in">Size</span>(), <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Preprpcessing - Step 1</span></span><br><span class="line">	imgThre = <span class="built_in">preProcessing</span>(imgOriginal);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get Contours - Biggest  - Step 2</span></span><br><span class="line">	initialPoints = <span class="built_in">getContours</span>(imgThre);</span><br><span class="line"><span class="comment">//	drawPoints(initialPoints, Scalar(0, 0, 255));</span></span><br><span class="line">	docPoints = <span class="built_in">reorder</span>(initialPoints);</span><br><span class="line"><span class="comment">//	drawPoints(docPoints, Scalar(0, 255, 0));</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Warp - Step 3</span></span><br><span class="line">	imgWarp = <span class="built_in">getWarp</span>(imgOriginal, docPoints, w, h);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Crop - Step 4</span></span><br><span class="line">	<span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, w - (<span class="number">2</span> * cropVal), h - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">	imgCrop = <span class="built_in">imgWarp</span>(roi);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, imgOriginal);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgThre);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用3-车牌检测"><a href="#应用3-车牌检测" class="headerlink" title="应用3 车牌检测"></a>应用3 车牌检测</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 3 - 牌照检测 //////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	CascadeClassifier plateCascade;</span><br><span class="line">	plateCascade.<span class="built_in">load</span>(<span class="string">&quot;Resources/haarcascade_russian_plate_number.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (plateCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;Rect&gt; plates;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		plateCascade.<span class="built_in">detectMultiScale</span>(img, plates, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plates.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Mat imgCrop = <span class="built_in">img</span>(plates[i]);</span><br><span class="line">			<span class="comment">//imshow(to_string(i), imgCrop);</span></span><br><span class="line">			<span class="built_in">imwrite</span>(<span class="string">&quot;Resources/Plates/&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;.png&quot;</span>, imgCrop);</span><br><span class="line">			<span class="built_in">rectangle</span>(img, plates[i].<span class="built_in">tl</span>(), plates[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</title>
    <url>/posts/b5b2ecfc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"><a href="#OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道" class="headerlink" title="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"></a>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGB_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mat RGB_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line">	<span class="function">Mat* <span class="title">Set_RGB_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line">	<span class="function">Mat <span class="title">Get_R</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_G</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_B</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//HSV类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSV_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mat HSV_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line">	<span class="function">Mat* <span class="title">Set_HSV_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line">	<span class="function">Mat <span class="title">Get_V</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_S</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_H</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//彩色图片的读取</span></span><br><span class="line">	Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line">	<span class="comment">//RGB三通道分离并显示</span></span><br><span class="line">	RGB_Channels my_rgb;</span><br><span class="line">	<span class="built_in">split</span>(image,my_rgb.<span class="built_in">Set_RGB_Color_Channels</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;R&quot;</span>,my_rgb.<span class="built_in">Get_R</span>());</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;G&quot;</span>,my_rgb.<span class="built_in">Get_G</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;B&quot;</span>,my_rgb.<span class="built_in">Get_B</span>());	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//RGB转HSV</span></span><br><span class="line">	Mat image_hsv;</span><br><span class="line">	<span class="built_in">cvtColor</span>(image, image_hsv, COLOR_BGR2HSV_FULL);</span><br><span class="line">	<span class="comment">//HSV三通道分离并显示</span></span><br><span class="line">	HSV_Channels my_hsv;</span><br><span class="line">	<span class="built_in">split</span>(image_hsv,my_hsv.<span class="built_in">Set_HSV_Color_Channels</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;H&quot;</span>,my_hsv.<span class="built_in">Get_H</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;S&quot;</span>,my_hsv.<span class="built_in">Get_S</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;V&quot;</span>,my_hsv.<span class="built_in">Get_V</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/8f0ffc2404d1a1957390a20f6bb47673.png" alt="image-20220302161619338"></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV文档矫正</title>
    <url>/posts/c780224b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV文档矫正"><a href="#OpenCV文档矫正" class="headerlink" title="OpenCV文档矫正"></a>OpenCV文档矫正</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将一个斜着拍摄的文档矫正成正的，如图所示：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_origin.jpg" alt="opencv-wendang-image_origin"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_output.jpg" alt="opencv-wendang-image_output"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>读取原始图像，若图像太大可以先进行缩放处理，并获取原始图像的宽和高</li>
<li>对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</li>
<li>找到最大的轮廓，并提取角点<ol>
<li>进行降噪处理：检测轮廓面积，只保留大于阈值面积的轮廓</li>
<li>计算每个轮廓的周长，使用DP算法计算出轮廓点的个数，规则为周长*0.02</li>
<li>找到图像中面积最大的，且角点为4的轮廓</li>
</ol>
</li>
<li>将找到的四个角点排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角<ol>
<li>将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</li>
<li>将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</li>
<li>重新排列四个角点</li>
</ol>
</li>
<li>进行透视变换<ol>
<li>根据变换前及变换后的四个角点，创建变换矩阵</li>
<li>根据变换矩阵对图像进行透视变换</li>
</ol>
</li>
<li>若透视变换后有一些毛边，按需要进行裁剪，裁剪后重新调整比例<ol>
<li>创建一个矩形用来裁剪，并设定四周裁剪5像素</li>
<li>裁剪后重新调整图像宽高</li>
</ol>
</li>
<li>显示变换后图像</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码中均有详细注释，请仔细阅读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些定义</span></span><br><span class="line">Mat image_origin,     <span class="comment">// 原始图像</span></span><br><span class="line">	image_gray,       <span class="comment">// 灰度处理后的图像</span></span><br><span class="line">	image_blur,       <span class="comment">// 高斯模糊处理后的图像</span></span><br><span class="line">	image_canny,      <span class="comment">// 边缘检测后的图像</span></span><br><span class="line">	image_dilate,     <span class="comment">// 膨胀后的图像</span></span><br><span class="line">	image_erode,      <span class="comment">// 腐蚀后的图像</span></span><br><span class="line">	image_preprocess, <span class="comment">// 预处理后的图像</span></span><br><span class="line">	image_trans,      <span class="comment">// 透视变换后的图像</span></span><br><span class="line">	image_crop;	      <span class="comment">// 裁剪后的图像</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; origin_points,  <span class="comment">// 重新排列前的角点</span></span><br><span class="line">			  reorder_points; <span class="comment">// 重新排列后的角点</span></span><br><span class="line">			  </span><br><span class="line">			  </span><br><span class="line"><span class="keyword">int</span> origin_width = <span class="number">0</span>, origin_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：预处理，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line"><span class="comment"> * 输入：图像，是否显示(0-不显示 1-显示每一步处理后的图像 2-只显示最终图像)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PreProcess</span><span class="params">(<span class="keyword">const</span> Mat&amp; image, <span class="keyword">int</span> display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 灰度处理</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(image, image_gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯模糊</span></span><br><span class="line">	<span class="built_in">GaussianBlur</span>(image_gray, image_blur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边缘检测(边缘检测前对图像进行一次高斯模糊)</span></span><br><span class="line">	<span class="built_in">Canny</span>(image_blur, image_canny, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 膨胀和腐蚀(有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀)</span></span><br><span class="line">	<span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="built_in">dilate</span>(image_canny, image_dilate, kernel);</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="comment">//erode(image_dilate, image_erode, kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示预处理效果</span></span><br><span class="line">	<span class="keyword">if</span>(display == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;灰度处理后的图像&quot;</span>, image_gray);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯模糊后的图像&quot;</span>, image_blur);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;边缘检测后的图像&quot;</span>, image_canny);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;膨胀后的图像&quot;</span>, image_dilate);</span><br><span class="line"><span class="comment">//		imshow(&quot;腐蚀后的图像&quot;, image_erode);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(display == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;预处理后的图像&quot;</span>, image_dilate);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> image_dilate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：找到面积最大的轮廓</span></span><br><span class="line"><span class="comment"> * 输入：源图像</span></span><br><span class="line"><span class="comment"> * 输出：最大轮廓的四个角点数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">GetMaxContour</span><span class="params">(<span class="keyword">const</span> Mat&amp; img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment">	 * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment">	 * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * findContours找到轮廓</span></span><br><span class="line"><span class="comment">	 * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment">	 * 		取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment">	 * 		取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment">	 * 		取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment">	 * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * drawContours绘出轮廓</span></span><br><span class="line"><span class="comment">	 * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours</span></span><br><span class="line"><span class="comment">	 * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line"><span class="comment">//	// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//	drawContours(image, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">corners_contours</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	vector&lt;Point&gt; biggest_contours;</span><br><span class="line">	<span class="keyword">double</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 检测轮廓面积</span></span><br><span class="line">		<span class="keyword">double</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//		cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 假设图像中有噪声，需要将其过滤，只保留面积大于1000的轮廓</span></span><br><span class="line">		<span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line">			<span class="keyword">double</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], corners_contours[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 找到图像中面积最大的，且角点为4的轮廓</span></span><br><span class="line">			<span class="keyword">if</span> (contour_area &gt; max_area &amp;&amp; corners_contours[i].<span class="built_in">size</span>() == <span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//drawContours(image_origin, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">				biggest_contours = &#123; corners_contours[i][<span class="number">0</span>],corners_contours[i][<span class="number">1</span>] ,corners_contours[i][<span class="number">2</span>] ,corners_contours[i][<span class="number">3</span>] &#125;;</span><br><span class="line">				max_area = contour_area;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//			// 只绘制角点之间的边框线，Debug用，取消注释可以看到检测出的所有边界框</span></span><br><span class="line"><span class="comment">//			drawContours(image_origin, corners_contours, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//			rectangle(image_origin, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回最大的轮廓</span></span><br><span class="line">	<span class="keyword">return</span> biggest_contours;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：绘制一些点</span></span><br><span class="line"><span class="comment"> * 输入：点集，颜色</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoints</span><span class="params">(vector&lt;Point&gt; points, <span class="keyword">const</span> Scalar&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(image_origin, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line">		<span class="built_in">putText</span>(image_origin, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：重新排列四个角点的顺序</span></span><br><span class="line"><span class="comment"> * 最终顺序为： 0  1</span></span><br><span class="line"><span class="comment"> * 			  2  3</span></span><br><span class="line"><span class="comment"> * 			  数组中为左上角-右上角-左下角-右下角</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">ReorderPoints</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Point&gt; newPoints;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// OpenCV中左上顶点为(0,0)，右为x轴正向，下为y轴正向。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</span></span><br><span class="line">		sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line">		<span class="comment">// 将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</span></span><br><span class="line">		subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新排列</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 0 和的最小值</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 1 差的最大值</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 2 差的最小值</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 3 和的最大值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：</span></span><br><span class="line"><span class="comment"> * 输入：源图像，四个角点的集合(角点的顺序为，左上角-右上角-左下角-右下角)，输出的宽，输出的高</span></span><br><span class="line"><span class="comment"> * 输出：透视变换后的图像</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PerspectiveTrans</span><span class="params">(<span class="keyword">const</span> Mat&amp; img, vector&lt;Point&gt; points, <span class="keyword">float</span> width, <span class="keyword">float</span> height )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 前面经过重新排列，四个角点的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line">	<span class="comment">// 变换后的四个角点</span></span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;width,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,height&#125;,&#123;width,height&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建变换矩阵</span></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line">	<span class="comment">// 透视变换</span></span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, image_trans, matrix, <span class="built_in">Point</span>(width, height));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> image_trans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1.读取原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/image_origin.jpg&quot;</span>;</span><br><span class="line">	image_origin = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	// 若图像太大可以先进行缩放处理</span></span><br><span class="line"><span class="comment">//	resize(image_origin, image_origin, Size(), 0.5, 0.5);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取原始图像的宽和高</span></span><br><span class="line">	origin_width  = image_origin.<span class="built_in">size</span>().width;</span><br><span class="line">	origin_height = image_origin.<span class="built_in">size</span>().height;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line">	image_preprocess = <span class="built_in">PreProcess</span>(image_origin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.找到最大的轮廓，并提取角点</span></span><br><span class="line">	origin_points = <span class="built_in">GetMaxContour</span>(image_preprocess);</span><br><span class="line"><span class="comment">//	DrawPoints(origin_points, Scalar(0, 0, 255)); // 红色</span></span><br><span class="line">	<span class="comment">// 此时发现，角点的顺序不固定，为了后面进行透视变换时与代码中变换后点集的顺序相同，需要将其排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">	reorder_points = <span class="built_in">ReorderPoints</span>(origin_points);</span><br><span class="line"><span class="comment">//	DrawPoints(reorder_points, Scalar(0, 255, 0)); //绿色</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.透视变换</span></span><br><span class="line">	image_trans = <span class="built_in">PerspectiveTrans</span>(image_origin, reorder_points, origin_width, origin_height);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 透视变换后有一些毛边，若需要可以进行裁剪</span></span><br><span class="line">	<span class="comment">// 四周裁剪5像素</span></span><br><span class="line">	<span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 创建一个矩形用来裁剪</span></span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, origin_width - (<span class="number">2</span> * cropVal), origin_height - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">	image_crop = <span class="built_in">image_trans</span>(roi);</span><br><span class="line">	<span class="comment">// 裁剪后重新调整比例</span></span><br><span class="line">	<span class="built_in">resize</span>(image_crop, image_crop, <span class="built_in">Size</span>(origin_width, origin_height));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.显示并输出变换后图像</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;源图像&quot;</span>, image_origin);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;最终图像&quot;</span>, image_crop);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;res/image_output.jpg&quot;</span>, image_crop);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image.jpg" alt="opencv-wendang-image"></p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV直方图均衡化</title>
    <url>/posts/ab9acae.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV直方图均衡化"><a href="#OpenCV直方图均衡化" class="headerlink" title="OpenCV直方图均衡化"></a>OpenCV直方图均衡化</h1><p>直方图均衡化，是对图像进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。<strong>直方图均衡化适用于增强直方图呈尖峰分布的图像。</strong></p>
<h2 id="几种图片的的直方图均衡化处理效果"><a href="#几种图片的的直方图均衡化处理效果" class="headerlink" title="几种图片的的直方图均衡化处理效果"></a>几种图片的的直方图均衡化处理效果</h2><h3 id="欠曝"><a href="#欠曝" class="headerlink" title="欠曝"></a>欠曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140221839.png" alt="image-20220308140221839"></p>
<h3 id="过曝"><a href="#过曝" class="headerlink" title="过曝"></a>过曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140259367.png" alt="image-20220308140259367"></p>
<p>从上面两个图片可以看到，直方图均衡化对于背景和前景都太亮或者太暗的图像效果较好，而且这是一个可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图。但缺点是直方图均衡化对处理的数据不加选择，它可能会增加背景噪声的对比度并且降低有用信号的对比度；变换后图像的灰度级减少，某些细节消失；某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。</p>
<p>下面再贴一张Luna的处理图：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140434486.png" alt="image-20220308140434486"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直方图均衡化</span></span><br><span class="line"><span class="function">Mat <span class="title">Histogramequalization</span><span class="params">(Mat src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> R[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> G[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> B[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> rows = src.rows;</span><br><span class="line">	<span class="keyword">int</span> cols = src.cols;</span><br><span class="line">	<span class="keyword">int</span> sum = rows * cols;</span><br><span class="line">	<span class="comment">//统计直方图的RGB分布</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]]++;</span><br><span class="line">			G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]]++;</span><br><span class="line">			R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构建直方图的累计分布方程，用于直方图均衡化</span></span><br><span class="line">	<span class="keyword">double</span> val[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		val[<span class="number">0</span>] += B[i];</span><br><span class="line">		val[<span class="number">1</span>] += G[i];</span><br><span class="line">		val[<span class="number">2</span>] += R[i];</span><br><span class="line">		B[i] = val[<span class="number">0</span>] * <span class="number">255</span> / sum;</span><br><span class="line">		G[i] = val[<span class="number">1</span>] * <span class="number">255</span> / sum;</span><br><span class="line">		R[i] = val[<span class="number">2</span>] * <span class="number">255</span> / sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//归一化直方图</span></span><br><span class="line">	<span class="function">Mat <span class="title">dst</span><span class="params">(rows, cols, CV_8UC3)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dst.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]];</span><br><span class="line">			dst.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]];</span><br><span class="line">			dst.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat luna = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Luna——原始图像&quot;</span>, luna);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Luna——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(luna));</span><br><span class="line"></span><br><span class="line">	Mat guobao = <span class="built_in">imread</span>(<span class="string">&quot;./guobao.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;过曝光——原始图像&quot;</span>, guobao);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;过曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(guobao));</span><br><span class="line"></span><br><span class="line">	Mat qianbao = <span class="built_in">imread</span>(<span class="string">&quot;./qianbao.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——原始图像&quot;</span>, qianbao);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(qianbao));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV滤波算法</title>
    <url>/posts/8b4c19c3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV滤波算法"><a href="#OpenCV滤波算法" class="headerlink" title="OpenCV滤波算法"></a>OpenCV滤波算法</h1><h2 id="三种滤波的优缺点对比"><a href="#三种滤波的优缺点对比" class="headerlink" title="三种滤波的优缺点对比"></a>三种滤波的优缺点对比</h2><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯滤波适合有高斯噪声的图片。能够很好的抑制图像输入时随机引入的噪声，将像素点跟邻域像素看作是一种高斯分布的关系，它的操作是将图像和一个高斯核进行卷积操作。但是不能很好地抑制椒盐噪声。</p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值滤波适合有椒盐噪声的图片。将窗口函数里面的所有像素进行排序取得中位数来代表该窗口中心的像素值，对椒盐噪声和脉冲噪声的抑制效果特别好，同时又能保留边缘细节。但是不能很好地抑制高斯噪声。</p>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>把每个像素都用周围的8个像素来做均值操作，幅值近似相等且随机分布在不同位置上，这样可以平滑图像，速度较快，算法简单。但是无法去掉噪声，只能微弱的减弱它。对于椒盐噪声，中值滤波是选择适当的点来替代污染点的值，所以处理效果好，由于椒盐噪声的均值不为0，所以均值滤波不能很好地去除噪声点。</p>
<h2 id="三种滤波算法对不同噪声的处理"><a href="#三种滤波算法对不同噪声的处理" class="headerlink" title="三种滤波算法对不同噪声的处理"></a>三种滤波算法对不同噪声的处理</h2><p><strong>给经过灰度处理的图像分别加入椒盐噪声、高斯噪声和椒盐高斯噪声，分别使用高斯滤波、中值滤波和均值滤波对图像进行滤波，下面为运行后的效果图：</strong></p>
<h3 id="添加椒盐噪声"><a href="#添加椒盐噪声" class="headerlink" title="添加椒盐噪声"></a>添加椒盐噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132251591.png" alt="image-20220308132251591"></p>
<h3 id="添加高斯噪声"><a href="#添加高斯噪声" class="headerlink" title="添加高斯噪声"></a>添加高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132404182.png" alt="image-20220308132404182"></p>
<h3 id="添加椒盐噪声和高斯噪声"><a href="#添加椒盐噪声和高斯噪声" class="headerlink" title="添加椒盐噪声和高斯噪声"></a>添加椒盐噪声和高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132459737.png" alt="image-20220308132459737"></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//生成高斯噪声</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">generate_gause_noise</span><span class="params">(<span class="keyword">double</span> mu, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//定义小值</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">double</span> epsilon = numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> z0, z1;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		flag = !flag;</span><br><span class="line">		<span class="comment">//flag为假构造高斯随机变量X</span></span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">			<span class="keyword">return</span> z1 * sigma + mu;</span><br><span class="line">		<span class="keyword">double</span> u1, u2;</span><br><span class="line">		<span class="comment">//构造随机变量</span></span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			u1 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">			u2 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">		&#125; <span class="keyword">while</span> (u1 &lt;= epsilon);</span><br><span class="line">		<span class="comment">//flag为真构造高斯随机变量</span></span><br><span class="line">		z0 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">cos</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line">		z1 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">sin</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line">		<span class="keyword">return</span> z0*sigma + mu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为图像加入高斯噪声</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_gause_noise</span><span class="params">(Mat&amp; image)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> channels = image.<span class="built_in">channels</span>();</span><br><span class="line">		<span class="keyword">int</span> rowsNumber = image.rows;</span><br><span class="line">		<span class="keyword">int</span> colsNumber = image.cols*channels;</span><br><span class="line">		<span class="comment">//推断图像的连续性</span></span><br><span class="line">		<span class="keyword">if</span> (image.<span class="built_in">isContinuous</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			colsNumber *= rowsNumber;</span><br><span class="line">			rowsNumber = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsNumber; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colsNumber; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//加入高斯噪声</span></span><br><span class="line">				<span class="keyword">int</span> val = image.ptr&lt;uchar&gt;(i)[j] + <span class="built_in">generate_gause_noise</span>(<span class="number">3</span>, <span class="number">0.8</span>) * <span class="number">32</span>;</span><br><span class="line">				<span class="keyword">if</span> (val &lt; <span class="number">0</span>)</span><br><span class="line">					val = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (val&gt;<span class="number">255</span>)</span><br><span class="line">					val = <span class="number">255</span>;</span><br><span class="line">				image.ptr&lt;uchar&gt;(i)[j] = (uchar)val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加椒盐噪声</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_salt_noise</span><span class="params">(Mat&amp; image, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line">			<span class="comment">// 灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;uchar&gt;(j, i) = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 彩色图像</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line">			<span class="comment">// 灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;uchar&gt;(j, i) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 彩色图像</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中值滤波</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">median_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">		<span class="keyword">int</span> start = win_size/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">				vector&lt;uchar&gt; model;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">						<span class="comment">//cout &lt;&lt; int(src.at&lt;uchar&gt;(i, j)) &lt;&lt; endl;</span></span><br><span class="line">						model.<span class="built_in">push_back</span>(src.at&lt;uchar&gt;(i, j));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">sort</span>(model.<span class="built_in">begin</span>(), model.<span class="built_in">end</span>());     <span class="comment">//采用快速排序进行</span></span><br><span class="line">				src.at&lt;uchar&gt;(m, n) = model[win_size*win_size/<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//均值滤波</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mean_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">		<span class="keyword">int</span> start = win_size / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">						sum += src.at&lt;uchar&gt;(i, j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum / win_size / win_size);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成高斯模板</span></span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; <span class="built_in">gause_template</span>(<span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> xcore = size / <span class="number">2</span>, ycore = size / <span class="number">2</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; res;</span><br><span class="line">		<span class="keyword">float</span> base = <span class="number">1.0</span> / <span class="number">2</span> / CV_PI / sigma / sigma;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</span><br><span class="line">			vector&lt;<span class="keyword">float</span>&gt;v;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; size; y++) &#123;</span><br><span class="line">				<span class="keyword">float</span> t1 = (<span class="built_in">pow</span>(x - xcore, <span class="number">2</span>) + <span class="built_in">pow</span>(y - ycore, <span class="number">2</span>)) / <span class="number">2.0</span> / sigma / sigma;</span><br><span class="line">				<span class="keyword">float</span> temp = base*<span class="built_in">exp</span>(-t1);</span><br><span class="line">				v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">			&#125;</span><br><span class="line">			res.<span class="built_in">push_back</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//高斯滤波</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">gause_filter</span><span class="params">(Mat&amp; src, <span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = <span class="built_in">gause_template</span>(sigma,size);</span><br><span class="line">		<span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">		<span class="keyword">int</span> start = size / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">				<span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">						<span class="comment">//cout &lt;&lt; gaussTem[i - m + start][j - n + start] &lt;&lt; endl;</span></span><br><span class="line">						sum += src.at&lt;uchar&gt;(i, j)*gaussTem[i-m+start][j-n+start];  <span class="comment">//重点理解！！！</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Flitter my_flitter;</span><br><span class="line">	Mat src = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line">	<span class="comment">//灰度处理</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(src, src,COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;灰度处理过的原始图像&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//椒盐噪声</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//添加椒盐噪声</span></span><br><span class="line">		Mat src_add_salt_noise;</span><br><span class="line">		src.<span class="built_in">convertTo</span>(src_add_salt_noise, CV_8UC1);</span><br><span class="line">		my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_noise, <span class="number">3000</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐噪声&quot;</span>, src_add_salt_noise);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中值滤波</span></span><br><span class="line">		Mat Trans_Median = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//均值滤波</span></span><br><span class="line">		Mat Trans_Mean = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//高斯滤波</span></span><br><span class="line">		<span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		Mat Trans_Gause = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//高斯噪声</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//添加高斯噪声</span></span><br><span class="line">		Mat src_add_gause_noise;</span><br><span class="line">		src.<span class="built_in">convertTo</span>(src_add_gause_noise, CV_8UC1);</span><br><span class="line">		my_flitter.<span class="built_in">add_gause_noise</span>(src_add_gause_noise);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;添加高斯噪声&quot;</span>, src_add_gause_noise);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中值滤波</span></span><br><span class="line">		Mat Trans_Median = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//均值滤波</span></span><br><span class="line">		Mat Trans_Mean = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//高斯滤波</span></span><br><span class="line">		<span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		Mat Trans_Gause = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//椒盐+高斯噪声</span></span><br><span class="line">	&#123;</span><br><span class="line">		Mat src_add_salt_and_gause_noise;</span><br><span class="line">		src.<span class="built_in">convertTo</span>(src_add_salt_and_gause_noise, CV_8UC1);</span><br><span class="line">		<span class="comment">//添加椒盐噪声</span></span><br><span class="line">		my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_and_gause_noise, <span class="number">3000</span>);</span><br><span class="line">		<span class="comment">//添加高斯噪声</span></span><br><span class="line">		my_flitter.<span class="built_in">add_gause_noise</span>(src_add_salt_and_gause_noise);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐+高斯噪声&quot;</span>, src_add_salt_and_gause_noise);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中值滤波</span></span><br><span class="line">		Mat Trans_Median = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//均值滤波</span></span><br><span class="line">		Mat Trans_Mean = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//高斯滤波</span></span><br><span class="line">		<span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		Mat Trans_Gause = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——什么是接口</title>
    <url>/posts/333442d9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——什么是接口"><a href="#ROS2——什么是接口" class="headerlink" title="ROS2——什么是接口"></a>ROS2——什么是接口</h1><h2 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h2><p>在机器人系统中, 往往有许许多多的硬件, 比如摄像头, 激光雷达, 每一个硬件发送的数据/数据类型是不同的, 那么ROS2是如何使用这些数据的呢?</p>
<p>前文<code>KFC</code>和<code>Hamburger</code>中我们使用过这些定义:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/u_int32.hpp&quot;</span></span></span><br><span class="line">...</span><br><span class="line">&lt;std_msgs::msg::String&gt;</span><br><span class="line">&lt;std_msgs::msg::UInt32&gt;</span><br></pre></td></tr></table></figure>
<p>这里的<code>std_msgs</code>是ROS2内置的一个接口功能包. </p>
<p>查看某一个接口包下所有的接口: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface package std_msgs</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-package-std_msgs.png" alt="ros2-interface-package-std_msgs" style="zoom:67%;"></p>
<p>当然, 这些内置接口也许不能满足你的需求, 此时就可以自定义接口.</p>
<h2 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h2><p>针对ROS2的通信方式, 接口可以分为:</p>
<ul>
<li><p>话题接口</p>
<p>文件名: <code>*.msg</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int64 num</span><br></pre></td></tr></table></figure>
<p>This is your custom message that transfers a single 64-bit integer called <code>num</code>.</p>
</li>
<li><p>服务接口</p>
<p>文件名:<code>*.srv</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">int64 c</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>
<p>This is your custom service that requests three integers named <code>a</code>, <code>b</code>, and <code>c</code>, and responds with an integer called <code>sum</code>.</p>
</li>
<li><p>动作接口</p>
<p>文件名:<code>*.action</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int32 order</span><br><span class="line">---</span><br><span class="line">int32[] sequence</span><br><span class="line">---</span><br><span class="line">int32[] partial_sequence</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义话题接口"><a href="#自定义话题接口" class="headerlink" title="自定义话题接口"></a>自定义话题接口</h3><p>前情提要: 前面的KFC实例中, KFC会定时发送一条广告话题, 如果要发送图片信息怎么办? 这就需要自定义KFC专属消息接口.</p>
<h4 id="编辑-msg文件"><a href="#编辑-msg文件" class="headerlink" title="编辑.msg文件"></a>编辑.msg文件</h4><p>cd到工作空间的<code>/src</code>文件夹下, 新建接口包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br><span class="line">ros2 pkg create topic_interfaces --build-type ament_cmake</span><br></pre></td></tr></table></figure>
<p>cd进入<code>topic_interfaces</code>文件夹, 新建<code>KFC.msg</code>文件(首字母要求大写)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir msg</span><br><span class="line">touch msg/KFC.msg</span><br></pre></td></tr></table></figure>
<p>编辑<code>KFC.msg</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 原始数据类型string</span><br><span class="line">string txt</span><br><span class="line"></span><br><span class="line"># 原始数据类型 uint32</span><br><span class="line">uint32 money</span><br><span class="line"></span><br><span class="line"># 图像消息，调用sensor_msgs下的Image类型</span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure>
<h4 id="修改Cmakelist-txt"><a href="#修改Cmakelist-txt" class="headerlink" title="修改Cmakelist.txt"></a>修改Cmakelist.txt</h4><p>注意:<code>rosidl_generate_interfaces()</code>必须在 <code>ament_package()</code>前</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这两句添加依赖</span></span><br><span class="line"><span class="keyword">find_package</span>(sensor_msgs REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明msg文件所属的工程名字, 文件位置, 依赖DEPENDENCIES</span></span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/Ad.msg&quot;</span></span><br><span class="line">   DEPENDENCIES sensor_msgs</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<h4 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加如下内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>sensor_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="编译并刷新环境变量"><a href="#编译并刷新环境变量" class="headerlink" title="编译并刷新环境变量"></a>编译并刷新环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select topic_interfaces</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="使用自定义话题接口修改KFC与Customer"><a href="#使用自定义话题接口修改KFC与Customer" class="headerlink" title="使用自定义话题接口修改KFC与Customer"></a>使用自定义话题接口修改KFC与Customer</h4><p>上代码! 请读者自行对比区别, <code>// CHANGE</code>为修改的地方</p>
<p>新建文件<code>Customer_with_interfaces.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 这个头文件是topic_interfaces接口包编译后自动生成的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;topic_interfaces/msg/kfc.hpp&quot;</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CustomerNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好,我是一个%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        sub_hamburger = <span class="keyword">this</span>-&gt;create_subscription&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::hamburger_callback, <span class="keyword">this</span>, _1)); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        sub_advertisement = <span class="keyword">this</span>-&gt;create_subscription&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::advertisement_callback, <span class="keyword">this</span>, _1)); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        hungry_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;CustomerNode::hungry_timer_callback, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        pub_money = <span class="keyword">this</span>-&gt;create_publisher&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        money.money = <span class="number">10</span>; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我饿了, 我要吃汉堡! 付款 %d 元&quot;</span>, money.money); <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    topic_interfaces::msg::KFC money; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::TimerBase::SharedPtr hungry_timer;</span><br><span class="line"></span><br><span class="line">    rclcpp::Subscription&lt;topic_interfaces::msg::KFC&gt;::SharedPtr sub_hamburger; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::Publisher&lt;topic_interfaces::msg::KFC&gt;::SharedPtr pub_money; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::Subscription&lt;topic_interfaces::msg::KFC&gt;::SharedPtr sub_advertisement; <span class="comment">// CHANGE</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hamburger_callback</span><span class="params">(<span class="keyword">const</span> topic_interfaces::msg::KFC::SharedPtr msg)</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我吃的 %s &quot;</span>, msg-&gt;txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我又饿了, 还想再吃一个! 付款 %d 元&quot;</span>, money.money); <span class="comment">// CHANGE</span></span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_callback</span><span class="params">(<span class="keyword">const</span> topic_interfaces::msg::KFC::SharedPtr msg)</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我收到了一条广告: %s &quot;</span>, msg-&gt;txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;CustomerNode&gt;(<span class="string">&quot;Customer&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建文件<code>KFC_with_interfaces.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;topic_interfaces/msg/kfc.hpp&quot;</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KFCNode</span>(std::string name) : <span class="built_in">Node</span>(name), <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我是%s的服务员.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        pub_hamburger = <span class="keyword">this</span>-&gt;create_publisher&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        pub_advertisement = <span class="keyword">this</span>-&gt;create_publisher&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        advertisement_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">5000</span>ms, std::<span class="built_in">bind</span>(&amp;KFCNode::advertisement_timer_callback, <span class="keyword">this</span>));</span><br><span class="line">        </span><br><span class="line">        sub_money = <span class="keyword">this</span>-&gt;create_subscription&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;KFCNode::money_callback, <span class="keyword">this</span>, _1)); <span class="comment">// CHANGE</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line">    rclcpp::TimerBase::SharedPtr advertisement_timer;</span><br><span class="line"></span><br><span class="line">    rclcpp::Publisher&lt;topic_interfaces::msg::KFC&gt;::SharedPtr pub_hamburger; <span class="comment">// CHANGE</span></span><br><span class="line">    </span><br><span class="line">    rclcpp::Subscription&lt;topic_interfaces::msg::KFC&gt;::SharedPtr sub_money; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::Publisher&lt;topic_interfaces::msg::KFC&gt;::SharedPtr pub_advertisement; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> str_advertisement = topic_interfaces::msg::<span class="built_in">KFC</span>(); <span class="comment">// CHANGE</span></span><br><span class="line">        str_advertisement.txt = <span class="string">&quot;大鸡腿降价啦&quot;</span>; <span class="comment">// CHANGE</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;KFC发布了一个广告:%s&quot;</span>, str_advertisement.txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">        pub_advertisement-&gt;<span class="built_in">publish</span>(str_advertisement);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">money_callback</span><span class="params">(<span class="keyword">const</span> topic_interfaces::msg::KFC::SharedPtr msg)</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg-&gt;money == <span class="number">10</span>) <span class="comment">// CHANGE</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收款 %d 元&quot;</span>, msg-&gt;money); <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> str_hamburger_num = topic_interfaces::msg::<span class="built_in">KFC</span>(); <span class="comment">// CHANGE</span></span><br><span class="line">            str_hamburger_num.txt = <span class="string">&quot;第&quot;</span> + std::<span class="built_in">to_string</span>(count++) + <span class="string">&quot;个汉堡&quot;</span>; <span class="comment">// CHANGE</span></span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我卖出的%s&quot;</span>, str_hamburger_num.txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">            </span><br><span class="line">            pub_hamburger-&gt;<span class="built_in">publish</span>(str_hamburger_num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;KFCNode&gt;(<span class="string">&quot;KFC&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改Cmakelist.txt, 添加/修改: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(topic_interfaces REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Customer_with_interfaces_node src/Customer_with_interfaces.cpp)</span><br><span class="line">ament_target_dependencies(Customer_with_interfaces_node rclcpp topic_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(KFC_with_interfaces_node src/KFC_with_interfaces.cpp)</span><br><span class="line">ament_target_dependencies(KFC_with_interfaces_node rclcpp topic_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  Customer_node</span><br><span class="line">  KFC_node</span><br><span class="line">  Customer_with_interfaces_node</span><br><span class="line">  KFC_with_interfaces_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>修改package.xml, 添加: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>topic_interfaces<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编译并刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select customer_and_kfc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>开启两个终端, 分别运行使用自定义接口的KFC与Customer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run customer_and_kfc Customer_with_interfaces_node</span><br><span class="line">ros2 run customer_and_kfc KFC_with_interfaces_node</span><br></pre></td></tr></table></figure>
<p>成功~</p>
<h4 id="详细查看接口"><a href="#详细查看接口" class="headerlink" title="详细查看接口"></a>详细查看接口</h4><p>要想详细查看接口, 可以使用<code>ros2 interface</code>命令</p>
<ol>
<li><p>查看包下所有接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface package topic_interfaces</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-package-topic-interfaces.png" alt="ros2-interface-package-topic-interfaces" style="zoom:67%;"></p>
</li>
<li><p>查看内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show topic_interfaces/msg/Ad</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-show-topic-interfaces-msg-Ad.png" alt="ros2-interface-show-topic-interfaces-msg-Ad" style="zoom:67%;"></p>
</li>
<li><p>显示属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface proto topic_interfaces/msg/Ad</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-proto-topic-interfaces-msg-Ad.png" alt="ros2-interface-proto-topic-interfaces-msg-Ad" style="zoom:67%;"></p>
</li>
</ol>
<h3 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h3><p>自定义服务接口将在下一篇文章讲解服务时一起讲解.</p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——参数的使用</title>
    <url>/posts/7219ca14.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——参数的使用"><a href="#ROS2——参数的使用" class="headerlink" title="ROS2——参数的使用"></a>ROS2——参数的使用</h1><p>上回说到, <code>Organization</code>给每个人免费送2个汉堡, 有一天<code>Organization</code>正在营业中, 汉堡突然供不应求了, 领导决定临时改变规则, 之后的每个人只能领取一个汉堡. 但是此时节点已经在运行中, 该如何改变这个值呢? 这就需要用到参数<code>parameters</code></p>
<h2 id="参数简介"><a href="#参数简介" class="headerlink" title="参数简介"></a>参数简介</h2><p>参数是节点的配置参数值。你可以认为参数是节点配置的一部分。参数为整数，浮点数，布尔值，字符串和列表。在ROS2中，每个节点都有自己的参数。所有参数都是可动态重新配置的，并且是基于ROS2服务构建的。</p>
<p>在这个案例中, 每个人领取的汉堡数量就可以是<code>Organization</code>节点的一个参数.</p>
<p>下面, 我们将修改这段服务程序, 通过修改参数来改变人均汉堡数</p>
<h2 id="修改服务程序"><a href="#修改服务程序" class="headerlink" title="修改服务程序"></a>修改服务程序</h2><p>新建<code>Organization_with_parameter.cpp</code>文件</p>
<p>代码由<code>Organization.cpp</code>修改而来, 不同的地方均使用<code>// CHANGE:</code>标注出了, 请读者自行与上节代码进行对比.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;service_interfaces/srv/calculate.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Organization</span> :</span> <span class="keyword">public</span> rclcpp::Node </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Organization</span>() : <span class="built_in">Node</span>(<span class="string">&quot;Organization&quot;</span>), <span class="built_in">NumOfAll</span>(<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我们是热心组织, 我们只给poorer发汉堡.&quot;</span>);</span><br><span class="line">        callback_group_organization = <span class="keyword">this</span>-&gt;<span class="built_in">create_callback_group</span>(rclcpp::CallbackGroupType::MutuallyExclusive);</span><br><span class="line">        Organization_Server = <span class="keyword">this</span>-&gt;create_service&lt;service_interfaces::srv::Calculate&gt;(<span class="string">&quot;Calculate&quot;</span>,</span><br><span class="line">                                    std::<span class="built_in">bind</span>(&amp;Organization::organization_callback,<span class="keyword">this</span>,_1,_2),</span><br><span class="line">                                    rmw_qos_profile_services_default,</span><br><span class="line">                                    callback_group_organization);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// CHANGE: 声明参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;declare_parameter&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;NumOfEachPerson&quot;</span>, NumOfEachPerson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> NumOfAll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHANGE: 声明每个人分得的汉堡数, 默认为2</span></span><br><span class="line">    <span class="keyword">int</span> NumOfEachPerson = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    rclcpp::CallbackGroup::SharedPtr callback_group_organization;</span><br><span class="line">    rclcpp::Service&lt;service_interfaces::srv::Calculate&gt;::SharedPtr Organization_Server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">organization_callback</span><span class="params">(<span class="keyword">const</span> service_interfaces::srv::Calculate::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> service_interfaces::srv::Calculate::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request-&gt;status == <span class="string">&quot;Poorer&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个来自%s的请求，他家有%d个人.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>(), request-&gt;num_of_people);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CHANGE: 更新参数</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">get_parameter</span>(<span class="string">&quot;NumOfEachPerson&quot;</span>, NumOfEachPerson);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CHANGE: 计算应给汉堡数量，由参数给定</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> NumOfRequired = request-&gt;num_of_people * NumOfEachPerson;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(NumOfRequired &gt; NumOfAll)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;当前汉堡库里只剩%d个汉堡啦! 已经不够分了, 请明日再来.&quot;</span>, NumOfRequired);</span><br><span class="line">                response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                NumOfAll -= NumOfRequired;</span><br><span class="line">                response-&gt;num_of_hamburger = NumOfRequired;</span><br><span class="line">                response-&gt;success = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;成功送出%d个汉堡~ 还剩余%d个汉堡&quot;</span>, NumOfRequired, NumOfAll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            response-&gt;num_of_hamburger = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个非法请求，这人是个%s, 不满足送汉堡资格.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;Organization&gt;();</span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h3><p>添加:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Organization_with_parameters_node src/Organization_with_parameters.cpp)</span><br><span class="line">ament_target_dependencies(Organization_with_parameters_node rclcpp service_interfaces)</span><br></pre></td></tr></table></figure>
<p>添加:<code>Organization_with_parameters_node</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  ...</span><br><span class="line">  Organization_with_parameters_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>不用修改</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>--packages-select</code>指定编译<code>customer_and_kfc</code>功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select poor_and_organization</span><br></pre></td></tr></table></figure>
<p>刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>新建一个终端窗口, 运行带参数的Organization服务端节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Organization_with_parameters_node</span><br></pre></td></tr></table></figure>
<p>再另新建一个终端, 运行Poor客户端节点</p>
<p>一开始每人领取两个汉堡, 直接运行客户端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 5</span><br></pre></td></tr></table></figure>
<p>Organization服务端: 成功发出10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-Organization1.png" alt="Parameters-Organization1" style="zoom:67%;"></p>
<p>Poor客户端: 成功领取10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-change-Poor1.png" alt="Parameters-change-Poor1" style="zoom:67%;"></p>
<p>此时需要修改参数, 另起一个终端, 运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param <span class="built_in">set</span> /Organization NumOfEachPerson 1</span><br></pre></td></tr></table></figure>
<p>提示如下即为成功</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-change.png" alt="Parameters-change" style="zoom:67%;"></p>
<p>再次运行客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 50</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 50个人领取了50个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-change-Poor2.png" alt="Parameters-change-Poor2" style="zoom:67%;"></p>
<p>Organization服务端: 成功发出50个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-Organization2.png" alt="Parameters-Organization2" style="zoom:67%;"></p>
<p>由此可见, 参数成功被修改了, 但此时的参数不会被保留, 参数所在的节点重启后即恢复至初始值. 那如果一个节点的参数特别多, 修改完之后想将当前的参数保存下来供下次调用应该怎么操作呢? 请继续阅读.</p>
<h2 id="参数常用命令"><a href="#参数常用命令" class="headerlink" title="参数常用命令"></a>参数常用命令</h2><p>使用 <code>ros2 param</code></p>
<h3 id="查看参数列表"><a href="#查看参数列表" class="headerlink" title="查看参数列表"></a>查看参数列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param list</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-list.png" alt="Parameters-ros2-param-list" style="zoom:67%;"></p>
<p>也可具体到某个节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param list /Organization</span><br></pre></td></tr></table></figure>
<h3 id="查看参数描述"><a href="#查看参数描述" class="headerlink" title="查看参数描述"></a>查看参数描述</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param describe /Organization NumOfEachPerson</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-describe-Organization-NumOfEachPerson.png" alt="Parameters-ros2-param-describe-Organization-NumOfEachPerson" style="zoom:67%;"></p>
<h3 id="获取参数值"><a href="#获取参数值" class="headerlink" title="获取参数值"></a>获取参数值</h3><p><code>ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param get /Organization NumOfEachPerson</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-get-Organization-NumOfEachPerson-2.png" alt="Parameters-ros2-param-get-Organization-NumOfEachPerson-2" style="zoom:67%;"></p>
<h3 id="设置参数值"><a href="#设置参数值" class="headerlink" title="设置参数值"></a>设置参数值</h3><p><code>ros2 param set &lt;node_name&gt; &lt;parameter_name&gt; &lt;value&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param <span class="built_in">set</span> /Organization NumOfEachPerson 1</span><br></pre></td></tr></table></figure>
<p>再次获取参数值, 发生了改变:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-get-Organization-NumOfEachPerson-1.png" alt="Parameters-ros2-param-get-Organization-NumOfEachPerson-1" style="zoom:67%;"></p>
<h3 id="保存参数"><a href="#保存参数" class="headerlink" title="保存参数"></a>保存参数</h3><p><code>ros2 param dump &lt;node_name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param dump /Organization</span><br></pre></td></tr></table></figure>
<p>在当前终端的根目录下, 可以看到增加了一个<code>Organization.yaml</code>文件, 打开此文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/Organization:</span></span><br><span class="line">  <span class="attr">ros__parameters:</span></span><br><span class="line">    <span class="attr">NumOfEachPerson:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">use_sim_time:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>有了这个参数文件, 就可以通过这个文件设置节点的参数</p>
<h3 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h3><h4 id="节点启动后加载参数"><a href="#节点启动后加载参数" class="headerlink" title="节点启动后加载参数"></a>节点启动后加载参数</h4><p><code>ros2 param load &lt;node_name&gt; &lt;parameter_file&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param load /Organization ./Organization.yaml</span><br></pre></td></tr></table></figure>
<p>返回如下表示加载成功:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-load-Organization-Organization-yaml.png" alt="Parameters-ros2-param-load-Organization-Organization-yaml" style="zoom:67%;"></p>
<h4 id="节点启动前加载参数"><a href="#节点启动前加载参数" class="headerlink" title="节点启动前加载参数"></a>节点启动前加载参数</h4><p><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt; --ros-args --params-file &lt;file_name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Organization_with_parameters_node --ros-args --params-file ./Organization.yaml </span><br></pre></td></tr></table></figure>
<p>请读者尝试自行获取一下当前的<code>NumOfEachPerson</code>值作为练习.</p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——手把手编写一个服务</title>
    <url>/posts/fa9bc3ba.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——手把手教你编写一个服务"><a href="#ROS2——手把手教你编写一个服务" class="headerlink" title="ROS2——手把手教你编写一个服务"></a>ROS2——手把手教你编写一个服务</h1><h2 id="服务简介"><a href="#服务简介" class="headerlink" title="服务简介"></a>服务简介</h2><p>上一篇文章讲的话题通信是基于订阅/发布机制的，无论有没有订阅者，发布者都会周期发布数据，这种模式适合持续数据的收发，比如传感器数据。机器人系统中还有另外一些配置性质的数据，并不需要周期处理，此时就要用到另外一种ROS通信方式——服务（Service）。服务是基于客户端/服务器模型的通信机制，服务器端只在接收到客户端请求时才会提供反馈数据。  </p>
<p>服务有着以下特点:</p>
<ul>
<li><p>同一个服务（名称相同）有且只能有一个节点来提供</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Service-SingleServiceClient.gif" alt="Service-SingleServiceClient" style="zoom:67%;"></p>
</li>
<li><p>同一个服务可以被多个客户端调用(可以一对一也可一对多)</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Service-MultipleServiceClient.gif" alt="Service-MultipleServiceClient" style="zoom:67%;"></p>
</li>
</ul>
<p>下面, 我们将从一个实例出发, 手把手写一段服务程序</p>
<h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>来看一个案例: (以下均使用<code>-er</code>表示名词, 虽然没有这个词)</p>
<ul>
<li>有一些穷人<code>Poorer</code>和一个发放免费汉堡的爱心机构<code>Organization</code>.</li>
<li><code>Organization</code>总共有一定数量的汉堡. </li>
<li><code>Poorer</code>可以为家人代领汉堡, 家里有n个人, 就可以领取2n个汉堡.</li>
<li>当然, 还有一些有钱人<code>Richer</code>想蹭吃蹭喝, <code>Organization</code>不会给这些人发放食物</li>
<li>当汉堡发完了, <code>Organization</code>发出通知, 不再发放.</li>
</ul>
<p>以上案例实际上就实现了一个服务, <code>Organization</code>为服务端,  <code>Poorer</code>和<code>Richer</code>为客户端</p>
<h2 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h2><p>上一篇文章我们自定义了话题接口, 服务与话题不同, 服务是双向的, 所以要定义来回两个数据类型</p>
<h3 id="编辑-srv文件"><a href="#编辑-srv文件" class="headerlink" title="编辑.srv文件"></a>编辑.srv文件</h3><p>cd到工作空间的<code>/src</code>文件夹下, 新建接口包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br><span class="line">ros2 pkg create service_interfaces --build-type ament_cmake </span><br></pre></td></tr></table></figure>
<p>cd进入<code>service_interfaces</code>文件夹, 新建<code>Organization.srv</code>文件(首字母要求大写)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir srv</span><br><span class="line">touch srv/Organization.srv</span><br></pre></td></tr></table></figure>
<p>编辑<code>Organization.srv</code></p>
<p>来回两个数据中间用<code>---</code>分隔开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 是穷人还是富人</span><br><span class="line">string status</span><br><span class="line"># 家里的人数</span><br><span class="line">uint32 num_of_people</span><br><span class="line">---</span><br><span class="line"># 是否发出成功</span><br><span class="line"><span class="keyword">bool</span> success</span><br><span class="line"># 发出的汉堡数量</span><br><span class="line">uint32 num_of_hamburger</span><br></pre></td></tr></table></figure>
<h3 id="修改Cmakelist-txt"><a href="#修改Cmakelist-txt" class="headerlink" title="修改Cmakelist.txt"></a>修改Cmakelist.txt</h3><p>注意:<code>rosidl_generate_interfaces()</code>必须在 <code>ament_package()</code>前</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加依赖</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明srv文件所属的工程名字, 文件位置, 依赖DEPENDENCIES</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;srv/Calculate.srv&quot;</span></span><br><span class="line">  DEPENDENCIES </span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<h3 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加如下内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编译并刷新环境变量"><a href="#编译并刷新环境变量" class="headerlink" title="编译并刷新环境变量"></a>编译并刷新环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select service_interfaces</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="详细查看接口"><a href="#详细查看接口" class="headerlink" title="详细查看接口"></a>详细查看接口</h3><p>要想详细查看接口, 可以使用<code>ros2 interface</code>命令, 前面的博客已经讲过, 不再赘述</p>
<h2 id="服务程序实现"><a href="#服务程序实现" class="headerlink" title="服务程序实现"></a>服务程序实现</h2><p>下面来编写这段程序</p>
<h3 id="新建工作空间"><a href="#新建工作空间" class="headerlink" title="新建工作空间"></a>新建工作空间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br></pre></td></tr></table></figure>
<p><code>mkdir -p</code>: 递归创建目录,即使上级目录不存在,会按目录层级自动创建目录</p>
<h3 id="新建功能包"><a href="#新建功能包" class="headerlink" title="新建功能包"></a>新建功能包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create poor_and_organization --build-type ament_cmake --dependencies rclcpp service_interfaces</span><br></pre></td></tr></table></figure>
<p>使用<code>ament_cmake</code>作为编译类型, 并使用依赖<code>rclcpp</code>和前文定义的<code>service_interfaces</code>接口包</p>
<p>在<code>ros2_ws/src/poor_and_organization/src</code>下创建<code>Poor.cpp</code>和<code>Organization.cpp</code></p>
<h3 id="编写服务端节点"><a href="#编写服务端节点" class="headerlink" title="编写服务端节点"></a>编写服务端节点</h3><p>直接献出程序, 每句都有注释, 看不懂你打我</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;service_interfaces/srv/calculate.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类节点，名字叫做Organization,继承自Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Organization</span> :</span> <span class="keyword">public</span> rclcpp::Node </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化汉堡总数NumOfAll为100</span></span><br><span class="line">    <span class="built_in">Organization</span>() : <span class="built_in">Node</span>(<span class="string">&quot;Organization&quot;</span>), <span class="built_in">NumOfAll</span>(<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 热心组织的自我介绍</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我们是热心组织, 我们只给poorer发汉堡.&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化回调组, 作用为避免死锁(请自行百度ROS2死锁)</span></span><br><span class="line">        callback_group_organization = <span class="keyword">this</span>-&gt;<span class="built_in">create_callback_group</span>(rclcpp::CallbackGroupType::MutuallyExclusive);</span><br><span class="line">        <span class="comment">// 实例化发汉堡的的服务</span></span><br><span class="line">        Organization_Server = <span class="keyword">this</span>-&gt;create_service&lt;service_interfaces::srv::Calculate&gt;(<span class="string">&quot;Calculate&quot;</span>,</span><br><span class="line">                                    std::<span class="built_in">bind</span>(&amp;Organization::organization_callback,<span class="keyword">this</span>,_1,_2),</span><br><span class="line">                                    rmw_qos_profile_services_default,</span><br><span class="line">                                    callback_group_organization);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 剩余汉堡总数</span></span><br><span class="line">    <span class="keyword">size_t</span> NumOfAll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个服务回调组</span></span><br><span class="line">    rclcpp::CallbackGroup::SharedPtr callback_group_organization;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个服务端</span></span><br><span class="line">    rclcpp::Service&lt;service_interfaces::srv::Calculate&gt;::SharedPtr Organization_Server;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个回调函数，当收到要汉堡请求时调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">organization_callback</span><span class="params">(<span class="keyword">const</span> service_interfaces::srv::Calculate::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> service_interfaces::srv::Calculate::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断是不是穷人</span></span><br><span class="line">        <span class="keyword">if</span>(request-&gt;status == <span class="string">&quot;Poorer&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印Poorer家的人数</span></span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个来自%s的请求，他家有%d个人.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>(), request-&gt;num_of_people);</span><br><span class="line">            <span class="comment">// 计算应给汉堡数量，每人两个</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> NumOfRequired = request-&gt;num_of_people*<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 检查剩余汉堡够不够分</span></span><br><span class="line">            <span class="keyword">if</span>(NumOfRequired &gt; NumOfAll)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 不够分了, 返回false</span></span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;当前汉堡库里只剩%d个汉堡啦! 已经不够分了, 请明日再来.&quot;</span>, NumOfRequired);</span><br><span class="line">                response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 够分, 更新剩余汉堡数量</span></span><br><span class="line">                NumOfAll -= NumOfRequired;</span><br><span class="line">                <span class="comment">// 返回给几个汉堡</span></span><br><span class="line">                response-&gt;num_of_hamburger = NumOfRequired;</span><br><span class="line">                <span class="comment">// 成功送出, 返回true</span></span><br><span class="line">                response-&gt;success = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;成功送出%d个汉堡~ 还剩余%d个汉堡&quot;</span>, NumOfRequired, NumOfAll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 富人不给汉堡, 同样返回false, 同时返回送出汉堡数量为0</span></span><br><span class="line">            response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            response-&gt;num_of_hamburger = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个非法请求，这人是个%s, 不满足送汉堡资格.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;Organization&gt;();</span><br><span class="line">    <span class="comment">// 把节点的执行器变成多线程执行器, 避免死锁</span></span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写客户端Poor节点"><a href="#编写客户端Poor节点" class="headerlink" title="编写客户端Poor节点"></a>编写客户端Poor节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;service_interfaces/srv/calculate.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类节点，名字叫做Poorer,继承自Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poorer</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Poorer</span>() : <span class="built_in">Node</span>(<span class="string">&quot;Poorer&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我是一个来领汉堡的人.&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化客户端, 指明客户端的接口类型，同时指定要请求的服务的名称Calculate.</span></span><br><span class="line">        Poorer_Client = <span class="keyword">this</span>-&gt;create_client&lt;service_interfaces::srv::Calculate&gt;(<span class="string">&quot;Calculate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">take_hamburger</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;现在去领取汉堡&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造请求</span></span><br><span class="line">        <span class="keyword">auto</span> request = std::make_shared&lt;service_interfaces::srv::Calculate::Request&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待服务端上线</span></span><br><span class="line">        <span class="keyword">while</span> (!Poorer_Client-&gt;<span class="built_in">wait_for_service</span>(<span class="number">1</span>s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待时检测rclcpp的状态</span></span><br><span class="line">            <span class="keyword">if</span> (!rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 检测到Ctrl+C直接退出</span></span><br><span class="line">                <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;等待被打断, 不等了&quot;</span>);</span><br><span class="line">                rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则一直等</span></span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;等待热心组织开门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入参数格式错误的时候报错并退出程序</span></span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;输入格式错误, 格式为: 什么人 几口人. 例如: ros2 run poor_and_organization Poor_node Poorer 3&quot;</span>);</span><br><span class="line">            rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 格式正确, 获取参数, 放入request中</span></span><br><span class="line">            request-&gt;status =             argv[<span class="number">1</span>];</span><br><span class="line">            request-&gt;num_of_people = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我是%s, 我家有%d个人&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>(), request-&gt;num_of_people);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送异步请求，然后等待返回，返回时调用回调函数</span></span><br><span class="line">        Poorer_Client-&gt;<span class="built_in">async_send_request</span>(request, std::<span class="built_in">bind</span>(&amp;Poorer::poorer_callback, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建一个客户端</span></span><br><span class="line">    rclcpp::Client&lt;service_interfaces::srv::Calculate&gt;::SharedPtr Poorer_Client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建接收到小说的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">poorer_callback</span><span class="params">(rclcpp::Client&lt;service_interfaces::srv::Calculate&gt;::SharedFuture response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 使用response的get()获取</span></span><br><span class="line">        <span class="keyword">auto</span> result = response.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 如果确实是Poorer, 则领取成功</span></span><br><span class="line">        <span class="keyword">if</span>(result-&gt;success == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;成功领取%d个汉堡&quot;</span>, result-&gt;num_of_hamburger);</span><br><span class="line">            rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是Poorer或者汉堡数量不够, 则领取失败</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;领取汉堡失败, 原因可能为: 1.你不是Poorer 2.汉堡不够了&quot;</span>);</span><br><span class="line">            rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 产生一个Poorer的节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;Poorer&gt;();</span><br><span class="line">    node-&gt;<span class="built_in">take_hamburger</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 运行节点，并检测rclcpp状态</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(service_interfaces REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Poor_node src/Poor.cpp)</span><br><span class="line">ament_target_dependencies(Poor_node rclcpp service_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Organization_node src/Organization.cpp)</span><br><span class="line">ament_target_dependencies(Organization_node rclcpp service_interfaces)</span><br></pre></td></tr></table></figure>
<p>将编译好的文件安装到<code>install/poor_and_organization/lib/poor_and_organization</code>下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  Poor_node</span><br><span class="line">  Organization_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>同样地, 新建功能包的时候没有加<code>--dependencies rclcpp service_interfaces</code>等功能包, 则需要手动添加, 放置于<code>&lt;package&gt;</code>标签下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>service_interfaces<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可自行修改下面这些声明, 与实现功能无关, 但是最好写全</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;fanziqi@fanziqi.site&quot;</span>&gt;</span>fanziqi<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>--packages-select</code>指定编译<code>customer_and_kfc</code>功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select poor_and_organization</span><br></pre></td></tr></table></figure>
<p>刷新环境</p>
<p>前文应该已经echo了环境, 如果没有, 请添加<code>echo &quot;source /ros2_ws/install/setup.zsh&quot; &gt;&gt; ~/.bashrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>新建一个终端窗口, 运行Organization服务端节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Organization_node</span><br></pre></td></tr></table></figure>
<p>再另新建一个终端, 运行Poor客户端节点</p>
<p>第一个参数为节点名称<code>Poor_node</code>, 第二个参数为人员类型<code>Poorer</code>, 第三个参数为家里人数<code>5</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 5</span><br></pre></td></tr></table></figure>
<p>此时应该可以看见: </p>
<p>Organization服务端: 成功发出10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-1.png" alt="Organization-1" style="zoom:67%;"></p>
<p>Poor客户端: 成功领取10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-1.png" alt="Poor-1" style="zoom:67%;"></p>
<p>也可以手动发布客户端一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service call /Calculate service_interfaces/srv/Calculate <span class="string">&quot;&#123;num_of_people: 40, status: &#x27;Poorer&#x27;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Poor客户端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-2.png" alt="Poor-2" style="zoom:67%;"></p>
<p>Organization服务端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-2.png" alt="Organization-2" style="zoom:67%;"></p>
<p>此时如果再申请20个汉堡, 会发生什么呢?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 10</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 提示领取失败</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-3.png" alt="Poor-3" style="zoom:67%;"></p>
<p>Organization服务端: 提示不够分了</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-3.png" alt="Organization-3" style="zoom:67%;"></p>
<p>这时候有一个Richer来骗汉堡吃</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Richer 1</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 提示领取失败</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-4.png" alt="Poor-4" style="zoom:67%;"></p>
<p>Organization服务端: 就算有汉堡也不分给Richer</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-4.png" alt="Organization-4" style="zoom:67%;"></p>
<p>这时, Organization关门下班了(Ctrl+C关闭Organization_Node节点)</p>
<p>又来了一个人想要领汉堡:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 2</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 提示等待开门, 不想等待的话直接按Ctrl+C退出</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-5.png" alt="Poor-5" style="zoom:67%;"></p>
<p>经验证, 需求全部实现~</p>
<h2 id="服务常用命令"><a href="#服务常用命令" class="headerlink" title="服务常用命令"></a>服务常用命令</h2><p>使用 <code>ros2 service</code></p>
<h3 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service list</span><br></pre></td></tr></table></figure>
<p>具体点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service list -t</span><br></pre></td></tr></table></figure>
<h3 id="查看服务的接口"><a href="#查看服务的接口" class="headerlink" title="查看服务的接口"></a>查看服务的接口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service <span class="built_in">type</span> &lt;service_name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="查看接口的服务"><a href="#查看接口的服务" class="headerlink" title="查看接口的服务"></a>查看接口的服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service find &lt;type_name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="查看服务接口类型"><a href="#查看服务接口类型" class="headerlink" title="查看服务接口类型"></a>查看服务接口类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show ***/srv/***</span><br></pre></td></tr></table></figure>
<h3 id="手动调用服务"><a href="#手动调用服务" class="headerlink" title="手动调用服务"></a>手动调用服务</h3><p>前文使用过, 还记得吗</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——手把手编写一个话题</title>
    <url>/posts/7d4be8c5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——手把手教你编写一个话题"><a href="#ROS2——手把手教你编写一个话题" class="headerlink" title="ROS2——手把手教你编写一个话题"></a>ROS2——手把手教你编写一个话题</h1><h2 id="话题简介"><a href="#话题简介" class="headerlink" title="话题简介"></a>话题简介</h2><p>ROS2将复杂的机器人系统拆解成许多模块节点，而这些节点之间则是通过一个至关重要的通道完成数据交换的，这个通道就是“话题”。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-1-1.gif" alt="ros2-topic-1-1" style="zoom: 67%;"></p>
<p>一个节点可以通过多个话题向外发布数据，也可以同时订阅多个其他节点发布的话题，相当于话题是一个多对多的订阅/发布模型。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-n-n.gif" alt="ros2-topic-n-n" style="zoom: 67%;"></p>
<p>可见，话题是节点之间实现数据传输的重要途径，也是机器人各个子系统之间交换数据的重要方式。 </p>
<p>下面, 我们将从一个实例出发, 手把手写一段话题程序</p>
<h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>来看一个案例: </p>
<ul>
<li>有一家<code>KFC</code>和一个饥肠辘辘的<code>Customer</code>.</li>
<li><code>Customer</code>给<code>KFC</code>10元钱就能买到一个汉堡, 这个<code>Customer</code>饿得很快, 每秒都要吃一个汉堡. </li>
<li><code>KFC</code>收到<code>Customer</code>发来的10元钱, 向<code>Customer</code>发送汉堡, 为了推销大鸡腿, 每5秒发布一条广告.</li>
</ul>
<p>以上案例实际上就实现了一个话题, <code>KFC</code>和<code>Customer</code>是两个节点<code>Node</code>, 付钱/发送汉堡/发送广告即为发布者, 收钱/接收汉堡/收取广告即为订阅者.</p>
<p>下面来编写这段程序</p>
<h2 id="新建工作空间"><a href="#新建工作空间" class="headerlink" title="新建工作空间"></a>新建工作空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br></pre></td></tr></table></figure>
<p><code>mkdir -p</code>: 递归创建目录,即使上级目录不存在,会按目录层级自动创建目录</p>
<h2 id="新建功能包"><a href="#新建功能包" class="headerlink" title="新建功能包"></a>新建功能包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create customer_and_kfc --build-type ament_cmake --dependencies rclcpp std_msgs</span><br></pre></td></tr></table></figure>
<p>使用<code>ament_cmake</code>作为编译类型, 并使用依赖<code>rclcpp</code>和<code>std_msgs</code></p>
<p>在<code>ros2_ws/src/customer_and_kfc/src</code>下创建<code>KFC.cpp</code>和<code>Customer.cpp</code></p>
<h2 id="编写KFC节点"><a href="#编写KFC节点" class="headerlink" title="编写KFC节点"></a>编写KFC节点</h2><p>直接献出程序, 每句都有注释, 看不懂你打我</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rclcpp库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 基本消息类型库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/u_int32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样在下文可以使用1000ms这种表示方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占位符,下面会详细说</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类节点，起名叫做KFCNode,继承自Node,这样就能使用Node所有的功能了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数,第一个参数为节点名称, 并初始化count为1</span></span><br><span class="line">    <span class="built_in">KFCNode</span>(std::string name) : <span class="built_in">Node</span>(name), <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印KFC的自我介绍</span></span><br><span class="line">      	<span class="comment">// c_str()函数是string类的一个函数，作用是把string类型转化为char类型(%s要求是一个字符串)</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我是%s的服务员.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建发布者, 发布hamburger, 发布的消息类型为&lt;std_msgs::msg::String&gt;</span></span><br><span class="line">      	<span class="comment">// 格式: 发布者名字 = this-&gt;create_publisher&lt;要发布的话题类型&gt;(&quot;要发布的话题名称&quot;, 通信Qos);</span></span><br><span class="line">        pub_hamburger = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::String&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建发布者, 发布advertisement</span></span><br><span class="line">        pub_advertisement = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::String&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建定时器,每5000ms发布一个广告</span></span><br><span class="line">      	<span class="comment">// 格式: 定时器名字 = his-&gt;create_wall_timer(1000ms, std::bind(&amp;定时器回调函数, this));</span></span><br><span class="line">        advertisement_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">5000</span>ms, std::<span class="built_in">bind</span>(&amp;KFCNode::advertisement_timer_callback, <span class="keyword">this</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建订阅者,订阅money</span></span><br><span class="line">      	<span class="comment">// 格式: 订阅者名字 = this-&gt;create_subscription&lt;要订阅的话题类型&gt;(&quot;要订阅的话题名称&quot;, 通信Qos, std::bind(&amp;订阅者回调函数, this, _1));</span></span><br><span class="line">      	<span class="comment">// std::bind()是干啥的呢? 举个例子: </span></span><br><span class="line">      	<span class="comment">// 		auto f = std::bind(fun, placeholders::_2, placeholders::_1, 80);</span></span><br><span class="line">      	<span class="comment">// 		f(60,70) 等效于 fun(70, 60, 80) </span></span><br><span class="line">      	<span class="comment">// 还记得前文提到的占位符吗,placeholders::_1 就是f(60,70) 中的那个参数&quot;1&quot;</span></span><br><span class="line">        sub_money = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;KFCNode::money_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义一个汉堡售出计数器</span></span><br><span class="line">  	<span class="comment">// 在32位系统中size_t是4字节的，在64位系统中，size_t是8字节的，这样利用该类型可以增加程序移植性。</span></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个定时器</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr advertisement_timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个发布者,用于发布汉堡</span></span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_hamburger;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明一个订阅者,用于收钱</span></span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::UInt32&gt;::SharedPtr sub_money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个发布者,用于发布广告</span></span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_advertisement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广告定时器回调函数(无参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义一个String类型的字符串, 其中字符串存在.data中, %s使用时别忘了使用.c_str()转换为char类型.</span></span><br><span class="line">        <span class="keyword">auto</span> str_advertisement = std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">        str_advertisement.data = <span class="string">&quot;大鸡腿降价啦&quot;</span>;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;KFC发布了一个广告:%s&quot;</span>, str_advertisement.data.<span class="built_in">c_str</span>());</span><br><span class="line">        pub_advertisement-&gt;<span class="built_in">publish</span>(str_advertisement);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收钱订阅者回调函数(有参数, 参数类型跟上面订阅者订阅的参数类型相同, 注意要加上::SharedPtr, 因为传进来的是一个指针)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">money_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::UInt32::SharedPtr msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果收到了十元钱,才发布汉堡. 订阅的信息在msg-&gt;data中</span></span><br><span class="line">        <span class="keyword">if</span>(msg-&gt;data == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收款 %d 元&quot;</span>, msg-&gt;data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串流</span></span><br><span class="line">            <span class="keyword">auto</span> str_hamburger_num = std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">            str_hamburger_num.data = <span class="string">&quot;第&quot;</span> + std::<span class="built_in">to_string</span>(count++) + <span class="string">&quot;个汉堡&quot;</span>;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我卖出的%s&quot;</span>, str_hamburger_num.data.<span class="built_in">c_str</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发布字符串流</span></span><br><span class="line">          	<span class="comment">// 发布就这么写 &quot;发布器-&gt;publish(要发布的);&quot;, 简单吧</span></span><br><span class="line">            pub_hamburger-&gt;<span class="built_in">publish</span>(str_hamburger_num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化rclcpp</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 产生一个KFC的节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;KFCNode&gt;(<span class="string">&quot;KFC&quot;</span>);</span><br><span class="line">  	<span class="comment">// spin函数: 一旦进入spin函数，相当于它在自己的函数里面死循环了。只要回调函数队列里面有callback函数在，它就会马上去执行callback函数。如果没有的话，它就会阻塞，不会占用CPU。注意不要再spin后面放其他东西, 他们都不会执行的</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  	<span class="comment">// 检测退出信号(ctrl+c)</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="编写Customer节点"><a href="#编写Customer节点" class="headerlink" title="编写Customer节点"></a>编写Customer节点</h2><p>此段程序与上面相同的语句不再解释, 请读者自行类比</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/u_int32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就能使用1000ms这种表示方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占位符</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类节点，名字叫做CustomerNode,继承自Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数,第一个参数为节点名称</span></span><br><span class="line">    <span class="built_in">CustomerNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印Customer的自我介绍</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好,我是一个%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建订阅者,订阅hamburger</span></span><br><span class="line">        <span class="comment">// 占位符还记得吗? 复习一下, 此处的_1 表示const std_msgs::msg::String::SharedPtr msg</span></span><br><span class="line">        sub_hamburger = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::hamburger_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建订阅者,订阅advertisement</span></span><br><span class="line">        sub_advertisement = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::advertisement_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建定时器,每1000ms饿一次</span></span><br><span class="line">        hungry_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;CustomerNode::hungry_timer_callback, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建发布者,发布money</span></span><br><span class="line">        pub_money = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给money赋值</span></span><br><span class="line">        money.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次给钱</span></span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我饿了, 我要吃汉堡! 付款 %d 元&quot;</span>, money.data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 新建一张钱</span></span><br><span class="line">    std_msgs::msg::UInt32 money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个定时器</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr hungry_timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个订阅者,用于订阅发出的汉堡</span></span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_hamburger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个发布者,用于给KFC钱</span></span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::UInt32&gt;::SharedPtr pub_money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个订阅者,用于订阅广告</span></span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_advertisement;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 汉堡订阅者回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hamburger_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::String::SharedPtr msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我吃的 %s &quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饥饿定时器回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我又饿了, 还想再吃一个! 付款 %d 元&quot;</span>, money.data);</span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广告订阅者回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::String::SharedPtr msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我收到了一条广告: %s &quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化rclcpp</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">//产生一个Customer的节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;CustomerNode&gt;(<span class="string">&quot;Customer&quot;</span>);</span><br><span class="line">    <span class="comment">//运行节点，并检测退出信号</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h2><p>如果新建功能包的时候没有加<code>--dependencies rclcpp std_msgs</code>等功能包, 则需要手动添加: (任意位置均可)</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(std_msgs REQUIRED)</span><br></pre></td></tr></table></figure>
<p>下面两对代码的作用是: </p>
<p><code>add_executable()</code> 让编译器编译<code>Customer.cpp</code>和<code>KFC.cpp</code>这两个文件. 并生成可执行文件<code>Customer_node</code>和<code>KFC_node</code></p>
<p><code>ament_target_dependencies</code> 添加编译的依赖</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Customer_node src/Customer.cpp)</span><br><span class="line">ament_target_dependencies(Customer_node rclcpp std_msgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(KFC_node src/KFC.cpp)</span><br><span class="line">ament_target_dependencies(KFC_node rclcpp std_msgs)</span><br></pre></td></tr></table></figure>
<p>将编译好的文件安装到<code>install/customer_and_kfc/lib/customer_and_kfc</code>下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  Customer_node</span><br><span class="line">  KFC_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h2><p>同样地, 新建功能包的时候没有加<code>--dependencies rclcpp std_msgs</code>等功能包, 则需要手动添加, 放置于<code>&lt;package&gt;</code>标签下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可自行修改下面这些声明, 与实现功能无关, 但是最好写全</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;fanziqi@fanziqi.site&quot;</span>&gt;</span>fanziqi<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>--packages-select</code>指定编译<code>customer_and_kfc</code>功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select customer_and_kfc </span><br></pre></td></tr></table></figure>
<p>刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /ros2_ws/install/setup.zsh&quot;</span> &gt;&gt; ~/.bashrc  </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>新建一个终端窗口, 运行Customer节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run customer_and_kfc Customer_node</span><br></pre></td></tr></table></figure>
<p>再另新建一个终端, 运行KFC节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run customer_and_kfc KFC_node</span><br></pre></td></tr></table></figure>
<p>此时应该可以看见: </p>
<p>Customer端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS2-Customer.png" alt="ROS2-Customer"></p>
<p>KFC端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS2-KFC.png" alt="ROS2-KFC"></p>
<p>经验证, 需求全部实现~</p>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph"></a>rqt_graph</h3><p>使用<code>rqt_graph</code>这个工具可以可视化显示节点和话题的连接关系</p>
<p>另起一个终端, 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS2-rqt_graph.png" alt="ROS2-rqt_graph" style="zoom:67%;"></p>
<p>上图清晰地展示了ROS计算图的网络形态, 可以清楚地看出一个节点的输入和输出是什么.</p>
<h3 id="ros2-topic"><a href="#ros2-topic" class="headerlink" title="ros2 topic"></a>ros2 topic</h3><h4 id="查看系统中所有话题"><a href="#查看系统中所有话题" class="headerlink" title="查看系统中所有话题"></a>查看系统中所有话题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-list.png" alt="ros2-topic-list" style="zoom:67%;"></p>
<p>想具体查看每个话题传输的数据类型, 则添加<code>-t</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-list-t.png" alt="ros2-topic-list-t" style="zoom:67%;"></p>
<h4 id="输出实时话题内容"><a href="#输出实时话题内容" class="headerlink" title="输出实时话题内容"></a>输出实时话题内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /hamburger </span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-echo-hamburger.png" alt="ros2-topic-echo-hamburger" style="zoom:67%;"></p>
<h4 id="查看主题信息"><a href="#查看主题信息" class="headerlink" title="查看主题信息"></a>查看主题信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic info /hamburger</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-info-hamburger.png" alt="ros2-topic-info-hamburger" style="zoom:67%;"></p>
<h4 id="查看话题的数据类型"><a href="#查看话题的数据类型" class="headerlink" title="查看话题的数据类型"></a>查看话题的数据类型</h4><p>节点之间要想成功建立数据传输，必须发布和订阅同样数据类型的消息，发布者发布的是速度指令，订阅者想订阅位置信息可是行不通的。</p>
<p>上文用<code>ros2 topic list -t</code>查看得知, <code>/advertisement</code>的类型为<code>std_msgs/msg/String</code></p>
<p>通过如下指令查看这个数据类型的具体数据结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-show.png" alt="ros2-interface-show" style="zoom:67%;"></p>
<p>可以看到, <code>std_msgs/msg/String</code>中包含了<code>string data</code></p>
<h4 id="发布一个话题消息"><a href="#发布一个话题消息" class="headerlink" title="发布一个话题消息"></a>发布一个话题消息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic pub /test_topic std_msgs/msg/String <span class="string">&#x27;data: &quot;123&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-pub-test-topic.png" alt="ros2-topic-pub-test-topic" style="zoom:67%;"></p>
<h4 id="查看某一个话题的发布频率"><a href="#查看某一个话题的发布频率" class="headerlink" title="查看某一个话题的发布频率"></a>查看某一个话题的发布频率</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic hz /hamburger</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-hz-hamburger.png" alt="ros2-topic-hz-hamburger" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——教你写新版Launch文件</title>
    <url>/posts/7a5950c4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——教你写新版Launch文件"><a href="#ROS2——教你写新版Launch文件" class="headerlink" title="ROS2——教你写新版Launch文件"></a>ROS2——教你写新版Launch文件</h1><h2 id="为什么需要launch"><a href="#为什么需要launch" class="headerlink" title="为什么需要launch"></a>为什么需要launch</h2><p>如需启动一个节点，只需要执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run package-name execute-name</span><br></pre></td></tr></table></figure>
<p>但如果需要启动多个节点，一个一个启动需要开很多终端输入很多条命令，所以可以使用launch文件批量启动。</p>
<h2 id="如何编写launch文件"><a href="#如何编写launch文件" class="headerlink" title="如何编写launch文件"></a>如何编写launch文件</h2><p>在ROS1中launch文件是一种格式以<code>.launch</code>结尾的xml文档；而在ROS2中推荐使用Python方式编写launch文件，此时的launch文件是一种格式以<code>.launch.py</code>结尾的Python脚本。</p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>对于一个基础的启动节点的launch文件，需要引用以下库，然后创建一个名为做<code>generate_launch_description</code>的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_launch_description</span>():</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><strong>下文中未注明的均在<code>generate_launch_description()</code>函数中进行操作。</strong></p>
<p>创建<code>LaunchDescription</code>的对象<code>ld</code>（名字任意）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ld = LaunchDescription()</span><br></pre></td></tr></table></figure>
<p>然后创建一个<code>Actions.Node</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">example-node = Node(</span><br><span class="line">    package=<span class="string">&#x27;package-name&#x27;</span>, <span class="comment">#节点所在的功能包</span></span><br><span class="line">    namespace=<span class="string">&#x27;package-namespace&#x27;</span>, <span class="comment">#命名空间。如果存在同名节点，这一选项会有用</span></span><br><span class="line">    executable=<span class="string">&#x27;execute-name/script-name.py&#x27;</span>, <span class="comment">#表示要运行的可执行文件名或脚本名字.py</span></span><br><span class="line">    parameters=[&#123;<span class="string">&#x27;parameter-name&#x27;</span>: parameter-value&#125;], <span class="comment">#参数</span></span><br><span class="line">    arguments=[<span class="string">&#x27;-xxx&#x27;</span>, xxx,  <span class="string">&#x27;-xxx&#x27;</span>, xxx ], <span class="comment">#启动参数</span></span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>, <span class="comment">#用于将话题信息打印到屏幕</span></span><br><span class="line">    name=<span class="string">&#x27;node-name&#x27;</span> <span class="comment">#表示启动后的节点名，可以没有</span></span><br><span class="line">    remappings=[ <span class="comment">#重映射</span></span><br><span class="line">        (<span class="string">&#x27;/xxx/xxx-new&#x27;</span>, <span class="string">&#x27;/xxx/xxx-old&#x27;</span>),</span><br><span class="line">	]</span><br><span class="line">)</span><br><span class="line">example-node2 = Node(</span><br><span class="line">	......</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>将上面所有的Node对象加入<code>ld</code>，然后返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ld.add_action(example-node)</span><br><span class="line">ld.add_action(example-node2)</span><br><span class="line"><span class="keyword">return</span> launch_description</span><br></pre></td></tr></table></figure>
<h3 id="调用shell命令"><a href="#调用shell命令" class="headerlink" title="调用shell命令"></a>调用shell命令</h3><p>需要添加头文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess</span><br></pre></td></tr></table></figure>
<p>使用<code>ExecuteProcess</code>调用shell命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">example_cmd = ExecuteProcess(</span><br><span class="line">    cmd=[<span class="string">&#x27;some-cmd&#x27;</span>, <span class="string">&#x27;some-cmd&#x27;</span>], <span class="comment">#命令，用逗号隔开</span></span><br><span class="line">    additional_env=&#123;<span class="string">&#x27;EXAMPLE_PATH&#x27;</span>: path&#125;, <span class="comment">#可以添加临时的环境变量</span></span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(example_cmd)</span><br></pre></td></tr></table></figure>
<h3 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h3><p>使用<code>FindPackageShare</code>获取package路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch_ros.substitutions <span class="keyword">import</span> FindPackageShare</span><br><span class="line">......</span><br><span class="line">package-name = ‘example-package’</span><br><span class="line">package-path = FindPackageShare(package = package-name).find(package-name) </span><br></pre></td></tr></table></figure>
<p>或者使用<code>get_package_share_directory</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ament_index_python.packages <span class="keyword">import</span> get_package_share_directory</span><br><span class="line">......</span><br><span class="line">package-name = ‘example-package’</span><br><span class="line">package-path = get_package_share_directory(package-name),</span><br></pre></td></tr></table></figure>
<h3 id="连接路径"><a href="#连接路径" class="headerlink" title="连接路径"></a>连接路径</h3><h4 id="使用join"><a href="#使用join" class="headerlink" title="使用join"></a>使用join</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">...</span><br><span class="line"><span class="comment">#文件</span></span><br><span class="line">file-name = <span class="string">&#x27;example-file.xxx&#x27;</span></span><br><span class="line"><span class="comment">#字符串前加`f`表示可以在字符串里面使用用花括号括起来的变量和表达式，如定义好的`file-name`</span></span><br><span class="line">file-path = os.path.join(package-path, <span class="string">f&#x27;example-folder/<span class="subst">&#123;file-name&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment">#或者使用逗号隔开</span></span><br><span class="line">file-path = os.path.join(package-path, <span class="string">&#x27;example-folder&#x27;</span>, file-name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#路径</span></span><br><span class="line"><span class="built_in">dir</span>-path = os.path.join(package-path, <span class="string">&#x27;example-folder/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用替换"><a href="#使用替换" class="headerlink" title="使用替换"></a>使用替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> PathJoinSubstitution</span><br><span class="line">...</span><br><span class="line">PathJoinSubstitution([</span><br><span class="line">    FindPackageShare(<span class="string">&#x27;example-package&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;example-folder&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;example-file.xxx&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h3 id="改变参数"><a href="#改变参数" class="headerlink" title="改变参数"></a>改变参数</h3><p>一般需要用到以下两个模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> LaunchConfiguration</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> DeclareLaunchArgument</span><br></pre></td></tr></table></figure>
<p><code>LaunchConfiguration</code>用于在变量中存储启动参数的值并将它们传递给所需的操作，允许我们在launch文件的任何部分获取启动参数的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">example-cfg = LaunchConfiguration(<span class="string">&#x27;arg-name&#x27;</span>, default=<span class="string">&#x27;true&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>DeclareLaunchArgument</code>用于定义可以从上述启动文件或控制台传递的启动参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">example-arg = DeclareLaunchArgument(</span><br><span class="line">    <span class="string">&#x27;arg-name&#x27;</span>,</span><br><span class="line">    default_value=<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;some description&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(example-arg)</span><br></pre></td></tr></table></figure>
<h3 id="启动另一个launch文件"><a href="#启动另一个launch文件" class="headerlink" title="启动另一个launch文件"></a>启动另一个launch文件</h3><p>假设已经存在很多的单独的launch文件用于启动不同的功能，如果需要同时启动这些launch文件，可以使用<code>IncludeLaunchDescription</code>在launch文件中嵌套启动launch文件，这样可以提高复用率。</p>
<p>需要以下两个头文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> IncludeLaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.launch_description_sources <span class="keyword">import</span> PythonLaunchDescriptionSource</span><br></pre></td></tr></table></figure>
<p>使用<code>IncludeLaunchDescription</code>嵌套launch文件，其中同样可以使用上文所述的传递参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">another-launch = IncludeLaunchDescription(</span><br><span class="line">    PythonLaunchDescriptionSource(</span><br><span class="line">    	os.path.join(launch_file_dir, <span class="string">&#x27;launch-file-name.launch.py&#x27;</span>)</span><br><span class="line">    ),</span><br><span class="line">    launch_arguments=&#123;<span class="string">&#x27;arg-name&#x27;</span>: example-arg&#125;.items()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(another-launch)</span><br></pre></td></tr></table></figure>
<h3 id="在另一个launch文件中使用参数"><a href="#在另一个launch文件中使用参数" class="headerlink" title="在另一个launch文件中使用参数"></a>在另一个launch文件中使用参数</h3><p>这是一个困扰了我两天的，比较麻烦的简单问题。我们来看一个实例：这个launch文件有一个字符串格式的路径作为参数，其中的<code>robot_state_publisher</code>需要传入<code>robot_description</code>作为参数，而这个参数需要使用<code>open()</code>，也就是需要那个路径参数。我们自然而然会想到使用<code>LaunchConfiguration</code>，但是当你试图获取<code>urdf_path_cfg</code>的时候会发现这根本不是一个字符串。具体解决方案如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> DeclareLaunchArgument</span><br><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> LaunchConfiguration</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> OpaqueFunction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launch_setup</span>(<span class="params">context, *args, **kwargs</span>):</span></span><br><span class="line">    use_sim_time_cfg = LaunchConfiguration(<span class="string">&#x27;use_sim_time&#x27;</span>)</span><br><span class="line">    urdf_path_cfg = LaunchConfiguration(<span class="string">&#x27;urdf_path&#x27;</span>)</span><br><span class="line">    urdf_path = urdf_path_cfg.perform(context)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[92m&#x27;</span> + <span class="string">&quot;robot_state_publisher: Use urdf dir: &quot;</span> + urdf_path + <span class="string">&#x27;\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(urdf_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infp:</span><br><span class="line">        robot_desc = infp.read()</span><br><span class="line"></span><br><span class="line">    robot_state_publisher_node = Node(</span><br><span class="line">        package=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        name=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">        parameters=[&#123;</span><br><span class="line">            <span class="string">&#x27;use_sim_time&#x27;</span>: use_sim_time_cfg,</span><br><span class="line">            <span class="string">&#x27;robot_description&#x27;</span>: robot_desc</span><br><span class="line">        &#125;]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        robot_state_publisher_node,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_launch_description</span>():</span></span><br><span class="line"></span><br><span class="line">    ld = LaunchDescription()</span><br><span class="line"></span><br><span class="line">    use_sim_time_arg = DeclareLaunchArgument(</span><br><span class="line">        <span class="string">&#x27;use_sim_time&#x27;</span>,</span><br><span class="line">        default_value=<span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">        description=<span class="string">&#x27;Use simulation (Gazebo) clock if true&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    urdf_path_arg = DeclareLaunchArgument(</span><br><span class="line">        <span class="string">&#x27;urdf_path&#x27;</span>,</span><br><span class="line">        default_value=<span class="string">&#x27;robot.urdf&#x27;</span>,</span><br><span class="line">        description=<span class="string">&#x27;urdf_path&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ld.add_action(urdf_path_arg)</span><br><span class="line">    ld.add_action(use_sim_time_arg)</span><br><span class="line">    ld.add_action(OpaqueFunction(function=launch_setup))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ld</span><br></pre></td></tr></table></figure>
<p>这种写法我个人认为极其不优雅，但是确实能解决实际问题。</p>
<p>强烈建议ROS加入获取参数内容的方法！！！！！</p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS机器人学习——ROS基础</title>
    <url>/posts/eb3a5cff.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS机器人学习——ROS基础"><a href="#ROS机器人学习——ROS基础" class="headerlink" title="ROS机器人学习——ROS基础"></a>ROS机器人学习——ROS基础</h1><h2 id="ROS系统结构"><a href="#ROS系统结构" class="headerlink" title="ROS系统结构"></a>ROS系统结构</h2><ol>
<li>节点(Node) : 软件模块</li>
<li>节点管理器(ROS Master) : 控制中心,提供参数管理</li>
<li>话题(Topic) : 异步通信机制,传输消息Message,可有多个发布者和订阅者</li>
<li>服务(Service) : 同步通信机制,传输请求/应答数据,只允许有一个节点提供指定命名的服务</li>
</ol>
<h2 id="ROS工作空间"><a href="#ROS工作空间" class="headerlink" title="ROS工作空间"></a>ROS工作空间</h2><p>工作空间(workspace)是存放工程相关文件的文件夹,包括以下四个目录空间</p>
<ul>
<li><code>src</code>:代码空间,存放源码</li>
<li><code>build</code>:编译空间,存储编译的缓存和中间文件</li>
<li><code>devel</code>:开发空间,存放编译生成的可执行文件</li>
<li><code>install</code>:安装空间,非必须</li>
</ul>
<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p>(以下使用<code>WORKSPACE</code>代表你的工作空间名)</p>
<ol>
<li><p>创建工作空间</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    mkdir -p ~/WORKSPACE/src</span><br><span class="line">    <span class="built_in">cd</span> ~/WORKSPACE/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译工作空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/WORKSPACE/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量</p>
<p> 编译完成后,会自动产生<code>build</code>和<code>devel</code>,<code>devel</code>文件夹中会产生<code>setup.*sh</code>样子的环境变量设置脚本,用<code>source</code>运行脚本,以生效工作空间中的环境变量.</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>
<p> 但是这么设置环境变量只能在当前终端下生效,如希望在所有终端都生效,则需要在终端的配置文件中添加环境变量的设置:</p>
</li>
</ol>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /WORKSPACE/devel/setup.bash&quot;</span>&gt;&gt;~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>检查环境变量</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<p> 如果打印的路径中包含当前工作空间的路径,说明环境变量设置成功.</p>
<p> <strong>TODO:添加成功的截图</strong></p>
</li>
</ol>
<h3 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h3><p>(以下使用<code>PACKAGE</code>代表创建的功能包)</p>
<p>功能包结构:</p>
<p>PACKAGE/</p>
<p>​        CmakeList.txt    -&gt; 纪录功能报的编译规则</p>
<p>​        package.xml    -&gt; 描述功能包属性的信息</p>
<p>​        ……</p>
<p><strong>功能包不能嵌套,多个功能包需平行放置于代码空间<code>src</code>中</strong></p>
<ol>
<li><p>创建功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># catkin_create_pkg命令使用方法:</span></span><br><span class="line"><span class="comment"># catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</span></span><br><span class="line"><span class="built_in">cd</span> ~/WORKSPACE/src</span><br><span class="line">catkin_create_pkg learning_communication std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>
<p>创建完成后,src下会生成一个<code>learning_communication</code>文件夹,已包含<code>CmakeList.txt</code>和<code>package.xml</code></p>
</li>
<li><p>编译功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/WORKSPACE</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ~/WORKSPACE/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p><strong>同一工作空间下不能存在同名功能包</strong></p>
<p><strong>不同工作空间下可以存在同名功能包</strong></p>
</li>
</ol>
<p>所有工作空间的路径会依次顺序记录在ROS_PACKAGE_PATH环境变量中,即新的路径会排在前面.当在不同工作空间下存在同名功能包,ROS会优先查找纪录在最前端的工作空间中有没有需要的功能包,如果不存在则继续向下查找.</p>
<p>可通过以下命令查看所有ROS的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env | grep ros</span><br></pre></td></tr></table></figure>
<p>查找功能包存放路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rospack find PACKAGE</span><br></pre></td></tr></table></figure>
<p><strong>TODO:添加查找功能包的路径图片</strong></p>
<h2 id="ROS通信编程"><a href="#ROS通信编程" class="headerlink" title="ROS通信编程"></a>ROS通信编程</h2><h3 id="话题编程"><a href="#话题编程" class="headerlink" title="话题编程"></a>话题编程</h3><p>话题编程流程</p>
<ol>
<li>创建发布者</li>
<li>创建订阅者</li>
<li>添加编译选项</li>
<li>添加可执行程序</li>
</ol>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros-%E8%AF%9D%E9%A2%98.png" alt="截屏2021-08-25 下午7.46.04" style="zoom: 33%;"></p>
<h4 id="创建发布者Publisher"><a href="#创建发布者Publisher" class="headerlink" title="创建发布者Publisher"></a>创建发布者Publisher</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * talker.cpp</span></span><br><span class="line"><span class="comment"> * 创建一个Publisher,发布chatter话题,发布字符串&quot;Hello World&quot;,类型为string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS节点初始化,节点名称为talker</span></span><br><span class="line">  <span class="comment">// 注:节点名称必须唯一 </span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建节点句柄,方便管理节电资源的使用和管理</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个Publisher，发布名为chatter的topic，消息类型为std_msgs::String</span></span><br><span class="line">  <span class="comment">// 1000为消息发布队列大小,当发布消息实际速度较慢时,Publisher会将消息存储在一定空间的队列中,当消息数量超过队列大小时,ROS会自动删除队列中最早入队的消息</span></span><br><span class="line">  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置循环的频率,单位为Hz</span></span><br><span class="line">  <span class="comment">// 当调用Rate::sleep()时,ROS节点会根据此处设置的频率休眠响应的时间,以保证维持一致的时间周期.</span></span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 发生异常,ros::ok()返回false,跳出循环</span></span><br><span class="line">  <span class="comment">// 异常包括 1.Ctrl+C/2.被另外同名节点踢掉线/3.节点调用了关闭函数ros::shutdown()/4.所有ros::NodeHandles句柄被销毁</span></span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 初始化std_msgs::String类型的消息msg,msg只有一个成员data</span></span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;hello world &quot;</span> &lt;&lt; count;</span><br><span class="line">    <span class="comment">/*这一句一般出现在创建ROS话题的发布者（Publisher）节点程序中，是利用c++自带的头文件sstream，来实现利用输入输出流的方式往string里写东西，并且还可以拼接string和其他类型的变量。</span></span><br><span class="line"><span class="comment">    *该语句实现了string型的数据&quot;hello world&quot;和int型变量count的拼接，形成一个新的string。即如果count是１，那么hello world1会作为string被存放在ss当中。</span></span><br><span class="line"><span class="comment">    *使用ss.str()调用这个string。最后可以用ROS_INFO输出。  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ROS_INFO类似于printf/cout,用来打印日志信息</span></span><br><span class="line">    <span class="comment">// c_str()函数返回一个指向正规C字符串的指针常量, 内容与本string串相同. </span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    chatter_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来处理节点订阅话题的所有回调函数(目前的发布节点没有订阅信息,此函数非必须,但为了保证不出错所以所有节点都默认加入该函数)</span></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 目前为止,Publisher一个周期的工作完成了,让他休息一段时间,100ms后开始下一周期的工作</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建订阅者Subscriber"><a href="#创建订阅者Subscriber" class="headerlink" title="创建订阅者Subscriber"></a>创建订阅者Subscriber</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * listener.cpp</span></span><br><span class="line"><span class="comment"> * 创建一个Subscriber,订阅chatter话题，消息类型String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 订阅节点需要声明订阅信息,该信息会在ROS Master中注册,Master会关注系统中是否存在发布该话题的节点,若存在则会帮助两个节点建立连接,完成数据传输</span></span><br><span class="line">  <span class="comment">// 创建一个Subscriber，订阅名为chatter的topic，注册回调函数chatterCallback</span></span><br><span class="line">  ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>, chatterCallback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环等待回调函数,此函数在ros::ok()返回false时退出</span></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译功能包"><a href="#编译功能包" class="headerlink" title="编译功能包"></a>编译功能包</h4><p>设置编译规则<code>CmakeList.txt</code></p>
<ol>
<li><p>设置头文件路径</p>
<p> <code>include_directories(头文件相对路径)</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Specify additional locations of header files</span></span><br><span class="line"><span class="comment">## Your package locations should be listed before other locations </span></span><br><span class="line">include_directories(</span><br><span class="line">  include</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置需要编译的代码和可生成的可执行文件 </p>
<p><code>add_executable(生成的可执行文件 参与编译的源码文件1 参与编译的源码文件2)</code></p>
</li>
<li><p>配置链接的第三方库文件</p>
<p><code>target_link_libraries(生成的可执行文件 链接的库1 链接的库2)</code></p>
</li>
<li><p>若生成的可执行文件需要依赖其他文件生成的代码,如消息类型,则需设置依赖</p>
<p><code>add_dependencies(生成的可执行文件 $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">target_link_libraries(talker <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="comment">#add_dependencies(talker $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span></span><br><span class="line"></span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line">target_link_libraries(listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="comment">#add_dependencies(listener $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在工作空间路径下编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/WORKSPACE</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>系统会生成<code>talker</code>和<code>listener</code>两个可执行文件,位于<code>~/WORKSPACE/devel/lib/PACKAGE</code>路径下</p>
<h4 id="运行功能包"><a href="#运行功能包" class="headerlink" title="运行功能包"></a>运行功能包</h4><p>每次编译之后都需要设置环境变量,假定已将环境变量脚本添加到终端配置文件中,运行以下代码刷新环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<ol>
<li><p>启动<code>roscore</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>Publisher</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication talker</span><br></pre></td></tr></table></figure>
<p><strong>(TODO:添加运行截图)</strong></p>
</li>
<li><p>启动<code>Subscriber</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication listener</span><br></pre></td></tr></table></figure>
<p><strong>(TODO:添加运行截图)</strong></p>
<p>若先运行<code>Subscriber</code>,节点会处于等待状态直到<code>Publisher</code>启动</p>
</li>
</ol>
<p>至此,已经完成了话题通信.</p>
<h4 id="自定义话题消息"><a href="#自定义话题消息" class="headerlink" title="自定义话题消息"></a>自定义话题消息</h4><p>以上,<code>chatter</code>话题的消息类型为ROS预定的<code>String</code>,在ROS元功能包<code>common_msgs</code>中提供了许多不同消息类型,几乎满足一般需求.但有些情况下需要针对自己的机器人设计特定的消息类型</p>
<p>.msg文件是ROS中定义消息类型的文件,放置在功能包根目录下的msg文件夹中</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br></pre></td></tr></table></figure>
<p>还可以定义常量,在发布或订阅消息数据时可直接使用,相当于宏定义.如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 unknown = 0</span><br><span class="line">uint8 male    = 1</span><br><span class="line">uint8 female  = 2</span><br></pre></td></tr></table></figure>
<p>很多消息定义中还会包含一个标准格式的头信息<code>std_msgs/Header</code>,此处定义消息类型较为简单,也可以不加头信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint32 seq</span><br><span class="line">time stamp</span><br><span class="line">string frame_id</span><br></pre></td></tr></table></figure>
<p><code>seq</code>为消息顺序标识无,无需手动设置,<code>Publisher</code>发布消息时会自动累加;</p>
<p><code>stamp</code>为消息中与数据相关联的时间戳,可用于时间同步</p>
<p><code>frame_id</code>为消息中与数据相关联的参考坐标系id</p>
<p>为了使用这个自定义的消息类型,需要编译msg文件</p>
<ol>
<li><p>在<code>package.xml</code>中添加以下功能包依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>CmakeList.txt</code></p>
<ol>
<li><p><code>find_package</code>中添加消息声称依赖的功能包<code>message_generation</code></p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">	geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>catkin</code>依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">	......</span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs message_runtime</span><br><span class="line">	......</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置需要编译的msg文件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">	FILES</span><br><span class="line">	Person.msg</span><br><span class="line">)</span><br><span class="line">generate_messages(</span><br><span class="line">	DEPENDENCIES</span><br><span class="line">	std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在根目录下<code>catkin_make</code>编译,使用如下命令查看自定义的Person消息类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosmsg show person</span><br></pre></td></tr></table></figure>
<p><strong>(TODO:添加运行截图)</strong></p>
<p>即可在代码中使用,参考<code>String</code>类型使用方法</p>
</li>
</ol>
<h3 id="服务编程"><a href="#服务编程" class="headerlink" title="服务编程"></a>服务编程</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros-%E6%9C%8D%E5%8A%A1.png" alt="ros-服务" style="zoom: 33%;"></p>
<p>下面以加法运算为例,<code>Client</code>发布两个需要相加的<code>int</code>变量,<code>Server</code>节点接收请求后完成运算并返回结果</p>
<h4 id="自定义服务数据"><a href="#自定义服务数据" class="headerlink" title="自定义服务数据"></a>自定义服务数据</h4><p>通过<code>.srv</code>文件进行接口定义,放置于功能包根目录下的<code>srv</code>文件夹中.</p>
<p>该文件包含请求与应答两个数据域,中间用—-分割,内容格式与自定义话题相同</p>
<p>以加法运算为例,创建<code>AddTwoInts.srv</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>
<p>与话题一样,需要在<code>package.xml</code>和<code>CMakeList.txt</code>中配置依赖和编译规则</p>
<ol>
<li><p><code>package.xml</code>添加以下依赖(与话题相同)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CMakeList.txt</code>添加以下配置</p>
<ol>
<li><p><code>find_package</code>中添加消息声称依赖的功能包<code>message_generation</code>(与话题相同)</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line"> geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置需要编译的srv文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_service_files(</span><br><span class="line">	FILES</span><br><span class="line">	AddTwoInts.srv</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="创建服务器Server"><a href="#创建服务器Server" class="headerlink" title="创建服务器Server"></a>创建服务器Server</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * server.cpp</span></span><br><span class="line"><span class="comment"> * AddTwoInts Server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="comment">// 使用ROS中的服务,必须包含服务数据类型的头文件,这个头文件是前文AddTwoInts.srv自动生成的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_communication/AddTwoInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(learning_communication::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         learning_communication::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 将输入参数中的请求数据相加，结果放到应答变量中,反馈到Client,回调函数返回true</span></span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;request: x=%ld, y=%ld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)req.a, (<span class="keyword">long</span> <span class="keyword">int</span>)req.b);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)res.sum);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS节点初始化</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_two_ints_server&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个名为add_two_ints的server，注册回调函数add()</span></span><br><span class="line">  ros::ServiceServer service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;add_two_ints&quot;</span>, add);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 循环等待回调函数</span></span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见,Server类似于话题中的Subscriber</p>
<h4 id="创建客户端Client"><a href="#创建客户端Client" class="headerlink" title="创建客户端Client"></a>创建客户端Client</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * client.cpp</span></span><br><span class="line"><span class="comment"> * AddTwoInts Client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_communication/AddTwoInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS节点初始化</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_two_ints_client&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从终端命令行获取两个加数</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;usage: add_two_ints_client X Y&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个add_two_int的Client实例，服务类型是learning_communication::AddTwoInts</span></span><br><span class="line">  ros::ServiceClient client = n.serviceClient&lt;learning_communication::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化一个服务数据类型的变量,包含两个成员:request和response</span></span><br><span class="line">  <span class="comment">// 创建learning_communication::AddTwoInts类型的service消息</span></span><br><span class="line">  learning_communication::AddTwoInts srv;</span><br><span class="line">  srv.request.a = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  srv.request.b = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布service请求，等待加法运算的应答结果</span></span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(srv))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sum: %ld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)srv.response.sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service add_two_ints&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见,Client类似于话题中的Publisher</p>
<h4 id="编译功能包-1"><a href="#编译功能包-1" class="headerlink" title="编译功能包"></a>编译功能包</h4><p>设置编译规则<code>CmakeList.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(server src/server.cpp)</span><br><span class="line">target_link_libraries(server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line">add_dependencies(server <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br><span class="line">add_executable(client src/client.cpp)</span><br><span class="line">target_link_libraries(client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line">add_dependencies(client <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br></pre></td></tr></table></figure>
<p>catkin_make编译,刷新环境变量</p>
<h4 id="运行功能包-1"><a href="#运行功能包-1" class="headerlink" title="运行功能包"></a>运行功能包</h4><ol>
<li><p>启动<code>roscore</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>启动<code>Server</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​        <strong>(TODO:添加运行截图)</strong></p>
<ol>
<li><p>启动<code>Client</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication client 3 5</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​        <strong>(TODO:添加运行截图)</strong></p>
<h2 id="分布式多机通信"><a href="#分布式多机通信" class="headerlink" title="分布式多机通信"></a>分布式多机通信</h2><p><strong>(TODO:待添加)</strong></p>
<h2 id="ROS常用组件"><a href="#ROS常用组件" class="headerlink" title="ROS常用组件"></a>ROS常用组件</h2><h3 id="launch启动文件"><a href="#launch启动文件" class="headerlink" title="launch启动文件"></a>launch启动文件</h3><p>每当我们需要运行一个ROS节点或工具时，都需要打开一个新的终端运行一个命令。当系统中的节点数量不断增加时，每个节点一个终端的模式会变得非常麻烦。启动文件（Launch File）便是ROS中一种同时启动多个节点的途径，还可以自动启动ROSMaster节点管理器，而且可以实现每个节点的各种配置，为多个节点的操作提供了很大便利。</p>
<p>下面是一个最简单的launch文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><ol>
<li><p><code>&lt;launch&gt;</code></p>
<p> XML文件必须要包含一个根元素，launch文件中的根元素采用<code>&lt;launch&gt;</code>标签定义，文件中的其他内容都必须包含在这个标签之中：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;node&gt;</code></p>
<p> 启动文件的核心是启动ROS节点，采用<code>&lt;node&gt;</code>标签定义，语法如下：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package-name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;executable-name&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 从上边的定义规则可以看出，在启动文件中启动一个节点需要三个属性：name、pkg和type。</p>
<ul>
<li><p><code>name</code> : 节点运行的名称，将覆盖节点中<code>ros::init()</code>定义的节点名称；</p>
</li>
<li><p><code>pkg</code> : 节点所在的功能包名称</p>
</li>
<li><p><code>type</code> : 节点的可执行文件名称</p>
<p>在某些情况下，我们还有可能用到以下属性：</p>
<p>| 属性                 | 属性作用                                                     |<br>| :—————————- | —————————————————————————————— |<br>| <code>output=&quot;screen&quot;</code>    | 终端输出转储在当前的控制台上，而不是在日志文件中             |<br>| <code>respawn=&quot;true&quot;</code>     | 当roslaunch启动完所有该启动的节点之后，会监测每一个节点，保证它们正常的运行状态。对于任意节点，当它终止时，roslaunch 会将该节点重启 |<br>| <code>required=&quot;true&quot;</code>    | 当被此属性标记的节点终止时，roslaunch会将其他的节点一并终止。注意此属性不可以与<code>respawn=&quot;true&quot;</code>一起描述同一个节点 |<br>| <code>ns = &quot;NAME_SPACE&quot;</code>  | 这个属性可以让你在自定义的命名空间里运行节点                 |<br>| <code>args = &quot;arguments&quot;</code> | 节点需要的输入参数                                           |</p>
</li>
</ul>
</li>
</ol>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><ol>
<li><p><code>&lt;param&gt;</code></p>
<p> parameter是ROS系统运行中的参数，存储在参数服务器中。在launch文件中可以通过<code>&lt;param&gt;</code>元素加载parameter。launch文件执行后，parameter就加载到ROS的参数服务器上了。</p>
<p> 每个活跃的节点都可以通过 ros::param::get()接口来获取parameter的值，用户也可以在终端中通过rosparam命令获得parameter的值。</p>
<p> <code>&lt;param&gt;</code>使用方法:</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 运行launch文件后，output_frame这个parameter的值就设置为odom，并且加载到ROS参数服务器上了。但是在很多复杂的系统中，参数的数量很多，如果这样一个一个的设置会非常麻烦，ROS也为我们提供了另外一种类似的参数加载方式:<code>&lt;rosparam&gt;</code></p>
<p> <code>&lt;rosparam&gt;</code>使用方法</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find 2dnav_pr2)/config/costmap_common_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;local_costmap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>&lt;rosparam&gt;</code>可以帮助我们将一个yaml格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为“load”，还可以选择设置命名空间“ns”。</p>
</li>
<li><p><code>&lt;arg&gt;</code></p>
<p> argument是launch文件内部的局部变量,仅限于launch文件内部使用,便于launch文件的重构,与ROS节点内部无关</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;MyArg&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 像上面这样，就简单地声明了一个参数，名叫demo，但是声明不等于定义，我们需要给他赋值，在赋值之后参数才能够发挥作用。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;MyArg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;MyArg2&quot;</span> <span class="attr">default</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 以上是两种简单的赋值方法，两者的区别是使用后者赋值的参数可以在命令行中像下面这样被修改，前者则不行。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch xxx xxx.launch MyArg2=1234</span><br></pre></td></tr></table></figure>
<p> launch文件中需要使用到argument时，可以使用如下方式调用：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;arg-name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg arg-name)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;type &quot;</span><span class="attr">args</span>=<span class="string">&quot;$(arg arg-name)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> 当<code>$(arg arg_name)</code>出现在launch文件任意位置时，将会自动替代为所给参数的值。</p>
</li>
</ol>
<h4 id="重映射机制"><a href="#重映射机制" class="headerlink" title="重映射机制"></a>重映射机制</h4><p>ROS的设计目标是提高代码的复用率，所以ROS社区中的很多功能包我们都可以拿来直接使用，而不需要关注功能包的内部实现。那么问题就来了，别人功能包的接口不一定和我们的系统兼容呀？</p>
<p>ROS提供一种重映射的机制，简单来说就是取别名，类似于C++中的别名机制，我们不需要修改别人功能包的接口，只需要将接口名称重映射一下，取个别名，我们的系统就认识了（接口的数据类型必须相同）。launch文件中的<code>&lt;remap&gt;</code>标签顾名思义重映射，emap标签里包含一个<code>original-name</code>和一个<code>new-name</code>，及原名称和新名称。</p>
<p>比如turtlebot的键盘控制节点，发布的速度控制指令话题可能是<code>/turtlebot/cmd_vel</code>，但是我们自己的机器人订阅的速度控制话题是<code>/cmd_vel</code>，这个时候使用<code>&lt;remap&gt;</code>就可以轻松解决问题，将<code>/turtlebot/cmd_vel</code>重映射为<code>/cmd_vel</code>，我们的机器人就可以接收到速度控制指令了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>重映射机制在ROS中的使用非常广泛，也非常重要，方法不止这一种，也可以在终端rosrun命令中实现重映射.</p>
<h4 id="嵌套复用"><a href="#嵌套复用" class="headerlink" title="嵌套复用"></a>嵌套复用</h4><p>在复杂的系统当中，launch文件往往有很多，这些launch文件之间也会存在依赖关系。如果需要直接复用一个已有launch文件中的内容，可以使用<code>&lt;include&gt;</code>标签包含其他launch文件，这和C语言中的include几乎是一样的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>launch是ROS框架中非常实用、灵活的功能，它类似于一种高级编程语言，可以帮助我们管理启动系统时的方方面面。在使用ROS的过程中，很多情况下我们并不需要编写大量代码，仅需要使用已有的功能包，编辑一下launch文件，就可以完成很多机器人功能。</p>
<ul>
<li><p>注 : 使用 <code>roslaunch</code> 命令 和 使用 <code>rosrun</code> 命令 单独运行每个节点之间的重要区别</p>
<p>默认情况下，roslaunch 命令 从启动节点开始，标准输出信息会重定向到一个日志文件中，而不会像 rosrun 命令那样，将 log 信息显示在终端(console)上。日志文件所在路径： <code>∼/.ros/log/run_id/node_name-number-stdout.log</code>.如果想将标准输出信息显示在终端(console)上,需要在 node 元素中使用 output 属性：output=”screen”.但node 元素的 output 属性只能影响这个节点自己。除了 output 属性，我们可以使用 roslaunch命令行工具的 –screen 命令行选项强制性的在终端的窗口中显示所有节点的输出信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch --screen package-name launch-file-name</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="TF坐标变换"><a href="#TF坐标变换" class="headerlink" title="TF坐标变换"></a>TF坐标变换</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS-ABTF%E5%8F%98%E6%8D%A2.png" alt="ROS-ABTF变换" style="zoom: 33%;"></p>
<p>如图所示A,B两个坐标系,A坐标系下的位姿可以通过平移和旋转变换成B坐标系下的位姿,这里的平移和旋转可以用一个4*4的变换矩阵来描述(详见机器人学)</p>
<h4 id="创建TF广播器"><a href="#创建TF广播器" class="headerlink" title="创建TF广播器"></a>创建TF广播器</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * turtle_tf_broadcaster.cpp</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// tf广播器</span></span><br><span class="line">    <span class="keyword">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据乌龟当前的位姿，设置相对于世界坐标系的坐标变换</span></span><br><span class="line">    tf::Transform transform;</span><br><span class="line">    transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">    tf::Quaternion q;</span><br><span class="line">    q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">    transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布坐标变换</span></span><br><span class="line">    br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅乌龟的pose信息</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line">    ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建TF监听器"><a href="#创建TF监听器" class="headerlink" title="创建TF监听器"></a>创建TF监听器</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * turtle_tf_listener.cpp</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过服务调用，产生第二只乌龟turtle2</span></span><br><span class="line">    ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;spawn&quot;</span>);</span><br><span class="line">    ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;spawn&quot;</span>);</span><br><span class="line">    turtlesim::Spawn srv;</span><br><span class="line">    add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义turtle2的速度控制发布器</span></span><br><span class="line">    ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tf监听器</span></span><br><span class="line">    tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tf::StampedTransform transform;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查找turtle2与turtle1的坐标变换</span></span><br><span class="line">            listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">            listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">            ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据turtle1和turtle2之间的坐标变换，计算turtle2需要运动的线速度和角速度</span></span><br><span class="line">        <span class="comment">// 并发布速度控制指令，使turtle2向turtle1移动</span></span><br><span class="line">        geometry_msgs::Twist vel_msg;</span><br><span class="line">        vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">                                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">        vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">                                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">        turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译功能包-2"><a href="#编译功能包-2" class="headerlink" title="编译功能包"></a>编译功能包</h4><p>设置编译规则<code>CmakeList.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)</span><br><span class="line">target_link_libraries(turtle_tf_broadcaster <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"></span><br><span class="line">add_executable(turtle_tf_listener src/turtle_tf_listener.cpp)</span><br><span class="line">target_link_libraries(turtle_tf_listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>catkin_make编译,刷新环境变量</p>
<h4 id="launch文件启动"><a href="#launch文件启动" class="headerlink" title="launch文件启动"></a>launch文件启动</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 海龟仿真器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 键盘控制 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;teleop&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 两只海龟的tf广播 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;/turtle1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_tf_broadcaster&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;/turtle2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle2_tf_broadcaster&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 监听tf广播，并且控制turtle2移动 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_listener&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS机器人学习——机器人建模与仿真</title>
    <url>/posts/7859c9f3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS机器人学习——TF坐标变换</title>
    <url>/posts/5b37128a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS机器人学习——TF坐标变换"><a href="#ROS机器人学习——TF坐标变换" class="headerlink" title="ROS机器人学习——TF坐标变换"></a>ROS机器人学习——TF坐标变换</h1><h2 id="什么是TF"><a href="#什么是TF" class="headerlink" title="什么是TF"></a>什么是TF</h2><p><a href="http://wiki.ros.org/tf">tf-wiki</a></p>
<blockquote>
<p>tf is a package that lets the user keep track of multiple coordinate frames over time. tf maintains the relationship between coordinate frames in a tree structure buffered in time, and lets the user transform points, vectors, etc between any two coordinate frames at any desired point in time.</p>
</blockquote>
<p>将多个坐标系联系起来,使用tf树定义不同坐标系之间的平移与旋转变换关系，并且持续追踪多个坐标系内的变化情况。</p>
<h2 id="为什么需要坐标变换"><a href="#为什么需要坐标变换" class="headerlink" title="为什么需要坐标变换?"></a>为什么需要坐标变换?</h2><p>在ROS中定义了许多坐标系，有机器人坐标系(base_link)，有雷达坐标系(base_laser)，地图坐标系(map)，里程计坐标系(odom)等。以机器人中心为原点的坐标系，称为base_link坐标系，以激光雷达中心为原点的坐标系，称为base_laser坐标系。以下图机器人与激光雷达为例</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros-tf-1.png" alt="ros-tf-1"></p>
<p>机器人在运行过程中，激光雷达可以采集到周围障碍物的数据，这些数据是以激光雷达为原点(base_laser参考系)下的测量值。如果我们想使用这些数据帮助机器人完成避障功能，由于激光雷达并不在机器人的中心(base_link)之上，会始终存在一个雷达与机器人中心的偏差值。这个时候，如果我们采用一种坐标变换，将激光数据从base_laser参考系变换到base_link参考下，问题就解决了。所以我们需要定义这两个坐标系之间的变换关系,也就是<strong>TF坐标变换</strong></p>
<h2 id="TF变换实例"><a href="#TF变换实例" class="headerlink" title="TF变换实例"></a>TF变换实例</h2><p>在 <a href="https://www.fanziqi.site/posts/b6e9d4e.html">麦克纳姆轮运动学解算</a> 一文中,我提到了ROS的坐标系统与单位制,这里不再累述,请读者自行阅读</p>
<p>以机器人四轮与地面的接触面为X-Y平面，四轮轴心连线的点做垂线，与x-y平面的交点为base_link坐标系原点，车头朝向方向为X轴，正左方向为Y轴，向上为Z轴。如图所示:</p>
<p><strong>TODO:添加图片</strong></p>
<p>以思岚激光雷达为例，我们一般在安装时都习惯将雷达不带线的一端朝车头方向，雷达USB端的朝车尾方向,如图所示:</p>
<p><strong>TODO:添加图片</strong></p>
<p>雷达正中心为坐标原点，USB端的方向为X轴正方向，正左方向为Y轴，向上为Z轴。</p>
<p>测量雷达中心相对机器人坐标原点(0,0,0)的距离，得到雷达在机器人坐标系中(x:0.1,y:0.0,z:0.2)。前面我们提到，思岚雷达的X轴正方向与机器人的X轴正方向为相反方向，雷达坐标系需要绕Z轴顺时针旋转180度才能与机器人base_link坐标系重合 ，旋转(yaw:3.14,roll:0,pitch:0)。</p>
<p>根据这些数据，当我们获取激光数据后，采用(x: 0.1m, y: 0.0m, z: 0.2m, yaw:3.14, roll:0, pitch:0)的坐标变换，就可以将数据从base_laser参考系变换到base_link参考系，这就定义出了两个参考系之间的变换关系。</p>
<p>为了定义和存储base_link和base_laser两个参考系之间的关系，我们需要将他们添加到tf树中。从树的概念上来讲，tf树中的每个节点都对应一个参考系，而节点之间的边对应于参考系之间的变换关系。tf就是使用这样的树结构，保证每两个参考系之间只有一种遍历方式，而且所有变换关系，都是母节点到子节点的变换。</p>
<p>为了定义参考系，我们需要定义两个节点，一个对应于base_link参考系，一个对应于base_laser参考系。为了创建两个节点之间的边，我们首先需要决定哪一个节点作为母节点，哪一个节点作为子节点，这一点在tf树中是非常重要的。这里我们选择base_link作为母节点，这样会方便后边为机器人添加更多的传感器作为子节点.</p>
<h2 id="发布TF变换"><a href="#发布TF变换" class="headerlink" title="发布TF变换"></a>发布TF变换</h2><p>我们最常使用的是tf包中的static_transform_publisher，它即可在命令行直接运行，也可写在launch文件中配置坐标转换关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;node pkg=<span class="string">&quot;tf&quot;</span> type=<span class="string">&quot;static_transform_publisher&quot;</span> name=<span class="string">&quot;base_link_to_laser&quot;</span> args=<span class="string">&quot;0.065 0.0 0.245 1.57 0.0 0.0 /base_link /lidar 50&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>pkg：包名，tf</li>
<li>type：类型，static_transform_publisher</li>
<li>name：名称，自定，便于理解</li>
<li>arg：tf参数， x y z yaw pitch roll frame_id child_frame_id period_in_ms<ul>
<li>x y z 分别代表着相应轴的平移，单位是 米。</li>
<li>yaw pitch roll 分别代表着绕z y x 三个轴的转动，单位是 弧度。</li>
<li>frame_id 为坐标系变换中的父坐标系， child_frame_id为坐标系变换中的子坐标系。(传感器的frame_id的名称根据厂商或有不同，一般在驱动启动launch可查看，思岚激光雷达的frame_id为/lidar)</li>
<li>period_in_ms 为发布频率，单位为 毫秒。通常取100。一毫秒为一秒的千分之一，100毫秒即为0.1秒，也就是10Hz。</li>
</ul>
</li>
</ul>
<h2 id="TF常用工具"><a href="#TF常用工具" class="headerlink" title="TF常用工具"></a>TF常用工具</h2><ul>
<li><p>tf_monitor 打印tf树中所有参考系信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf_monitor &lt;source_frame&gt; &lt;target_frame&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tf_echo 查看指定作消息之间的变换关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf_echo &lt;source_frame&gt; &lt;target_frame&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static_transform_publisher 发布两个参考系之间的的静态坐标关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static_transform_publisher x y z yaw pitch roll frame id child frame id period</span><br></pre></td></tr></table></figure>
</li>
<li><p>view_frame 可视化的调试工具,可以生成pdf文件显示tf树信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun tf view_frames</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/autolabor/article/details/86492895">https://blog.csdn.net/autolabor/article/details/86492895</a></p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>RT-Thread配置SPI-Flash(W25Q256)</title>
    <url>/posts/358fc8e8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RT-Thread配置SPI-Flash-W25Q256"><a href="#RT-Thread配置SPI-Flash-W25Q256" class="headerlink" title="RT-Thread配置SPI-Flash(W25Q256)"></a>RT-Thread配置SPI-Flash(W25Q256)</h1><h3 id="1-开启SPI总线"><a href="#1-开启SPI总线" class="headerlink" title="1.开启SPI总线"></a>1.开启SPI总线</h3><p>新建一个空白的RT-Thread项目，本文基于STM32F103芯片。<br>首先在drivers目录下打开board.h文件，找到SPI对应部分。根据指导，一步一步做下去。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204143331118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-1打开SPI及SFUD"><a href="#1-1打开SPI及SFUD" class="headerlink" title="1.1打开SPI及SFUD"></a>1.1打开SPI及SFUD</h4><p>打开RT-Thread Settings,点击更多配置来到组件一栏，勾选如下。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204144847310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-2打开SPI宏定义"><a href="#1-2打开SPI宏定义" class="headerlink" title="1.2打开SPI宏定义"></a>1.2打开SPI宏定义</h4><p>board.h文件中，打开SPI宏定义。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204145854510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-3产生初始化函数"><a href="#1-3产生初始化函数" class="headerlink" title="1.3产生初始化函数"></a>1.3产生初始化函数</h4><p>使用stm32cubemx产生初始化函数，将其粘贴于board.c文件末尾。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204152938102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>然后选择芯片型号-&gt;填写项目名称，双击IOC文件后如图操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204153731512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>复制初始化函数到<code>board.c</code>文件。<img src="https://img-blog.csdnimg.cn/20201204154654140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-4打开SPI驱动"><a href="#1-4打开SPI驱动" class="headerlink" title="1.4打开SPI驱动"></a>1.4打开SPI驱动</h4><p>在drivers目录下的stm32f1xx_hal_conf.h文件中打开SPI驱动。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204160217954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>配置完成，编译下载,使用list_device指令查看设备，可以看到SPI总线已经存在了。</p>
<p><img src="https://img-blog.csdnimg.cn/2020120416192982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-挂载片外flash"><a href="#2-挂载片外flash" class="headerlink" title="2.挂载片外flash"></a>2.挂载片外flash</h3><p>接下来，我们将片外flash(W25Q256)挂到SPI总线上。</p>
<p>在application目录下，新增flash.c文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rt_hw_spi_flash_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处为片选引脚</span></span><br><span class="line">    rt_hw_spi_device_attach(W25Q_SPI_BUS_NAME, W25Q_SPI_DEVICE_NAME, GPIOA, GPIO_PIN_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//flash名称要正确</span></span><br><span class="line">    <span class="keyword">if</span> (RT_NULL == rt_sfud_flash_probe(<span class="string">&quot;W25Q256&quot;</span>, W25Q_SPI_DEVICE_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出到自动初始化 */</span></span><br><span class="line">INIT_COMPONENT_EXPORT(rt_hw_spi_flash_init);</span><br></pre></td></tr></table></figure>
<p>经过验证，flash已经挂载成功.</p>
<p><img src="https://img-blog.csdnimg.cn/20201204164850870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>下面开始搭建FAL。</p>
<h3 id="3-搭建FAL抽象层"><a href="#3-搭建FAL抽象层" class="headerlink" title="3.搭建FAL抽象层"></a>3.搭建FAL抽象层</h3><p>FAL是RT-Thread的一个软件包，主要是用于Flash 抽象层的实现，负责管理 Flash 设备和 Flash 分区。关于FAL的详细功能，大家可以参考RT-Thread软件包友情链接。文档非常详细，这里也参考了文档中的内容。</p>
<h4 id="3-1添加FAL"><a href="#3-1添加FAL" class="headerlink" title="3.1添加FAL"></a>3.1添加FAL</h4><p>打开RT-Thread Settings点击立即添加，然后搜索FAL。</p>
<p><img src="https://img-blog.csdnimg.cn/20201206161335974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201206161344745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020120616140293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201209201814662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-2配置FAL"><a href="#3-2配置FAL" class="headerlink" title="3.2配置FAL"></a>3.2配置FAL</h4><p>因为我们只用到了片外flash，所以可以将fal_cfg.h中关于片外flash的部分删除，并且定义自己的分区表。</p>
<p>将<code>samples-&gt;porting-&gt;fal_cfg.h</code>复制到<code>inc</code>中并修改为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _FAL_CFG_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FAL_CFG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtconfig.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;board.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOR_FLASH_DEV_NAME             <span class="meta-string">&quot;W25Q256&quot;</span>    <span class="comment">/*一定要改为自己的flash名称*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================== Flash device Configuration ========================= */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_flash_dev</span> <span class="title">nor_flash0</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* flash device table(定义设备表，删掉了片上flash) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAL_FLASH_DEV_TABLE                                          \</span></span><br><span class="line"><span class="meta">&#123;                                                                    \</span></span><br><span class="line"><span class="meta">    &amp;nor_flash0,                                                     \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">/* ====================== Partition Configuration ========================== */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FAL_PART_HAS_TABLE_CFG</span></span><br><span class="line"><span class="comment">/* partition table ps：可根据需要自行分区*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAL_PART_TABLE                                                               \</span></span><br><span class="line"><span class="meta">&#123;                                                                                   \</span></span><br><span class="line"><span class="meta">    &#123;FAL_PART_MAGIC_WORD, <span class="meta-string">&quot;easyflash&quot;</span>, NOR_FLASH_DEV_NAME,         0, 1024*1024, 0&#125;, \</span></span><br><span class="line"><span class="meta">    &#123;FAL_PART_MAGIC_WORD,  <span class="meta-string">&quot;download&quot;</span>, NOR_FLASH_DEV_NAME, 1024*1024, 1024*1024, 0&#125;, \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* FAL_PART_HAS_TABLE_CFG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _FAL_CFG_H_ */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处暂时并未做太大改动,可以根据需要自行分区、命名。</p>
<h4 id="3-3初始化FAL"><a href="#3-3初始化FAL" class="headerlink" title="3.3初始化FAL"></a>3.3初始化FAL</h4><p>在<code>main.c</code>文件中，包含<code>fal.h</code>并调用<code>fal_init()</code>初始化程序。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204174654126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-4验证"><a href="#3-4验证" class="headerlink" title="3.4验证"></a>3.4验证</h4><p><img src="https://img-blog.csdnimg.cn/20201204175752858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32CubeMX重定向printf输出至串口</title>
    <url>/posts/f00798b9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STM32CubeMX重定向printf输出至串口"><a href="#STM32CubeMX重定向printf输出至串口" class="headerlink" title="STM32CubeMX重定向printf输出至串口"></a>STM32CubeMX重定向printf输出至串口</h1><p>第一步,CubeMX配置串口(GPIO配置略)</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113161902135.png" alt="image-20220113161902135"></p>
<p>第二步,包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第三步,勾选Use Microlib</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113161451008.png" alt="image-20220113161451008"></p>
<p>第四步,重定向printf,此处需要将huart2改为上面配置的串口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart2, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;c, <span class="number">1</span>, <span class="number">1000</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时即可使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,num);</span><br></pre></td></tr></table></figure>
<p>代替</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf_len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\r\n&quot;</span>,num);</span><br><span class="line">HAL_UART_Transmit(&amp;huart2, (<span class="keyword">uint8_t</span> *)buf, buf_len, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/posts/5e339248.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><ol>
<li>最大标题：command + 1 或者：#</li>
<li>大标题：command + 2 或者：##</li>
<li>标准标题：command + 3 或者：###</li>
<li>中标题：command + 4 或者：####</li>
<li>小标题：command + 5 或者：#####</li>
<li>插入表格：command + T</li>
<li>插入代码：command + alt +c</li>
<li>行间公式 command + Alt + b</li>
<li>段落：command + 0</li>
<li>竖线 ： command + Alt +q</li>
<li>有序列表（1. 2.） ：输入数字+“.”之后输入空格 或者：command + Alt + o</li>
<li>黑点标记：command + Alt + u</li>
<li>隔离线shift + command + -</li>
<li>超链接：command + Alt + l</li>
<li>插入链接：command +k</li>
<li>下划线：command +u</li>
<li>加粗：command +b</li>
<li>搜索：command +f</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32学习笔记</title>
    <url>/posts/8cc52eb9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>STM32 命名规则</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/stm32-learn-1.png" alt="1"></p>
<hr>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>头文件：stm32f10x_gpio.h</p>
<p>源文件：stm32f10x_gpio.c</p>
<h3 id="重要函数："><a href="#重要函数：" class="headerlink" title="重要函数："></a>重要函数：</h3><ul>
<li><p>初始化函数：<br><code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</code></p>
<p>初始化一个或者多个IO口（同一组）的工作方式和速度。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">  	<span class="keyword">uint16_t</span> GPIO_Pin;                           <span class="comment">//指定要初始化的IO口         </span></span><br><span class="line">    GPIOSpeed_TypeDef GPIO_Speed; <span class="comment">//设置IO口输出速度</span></span><br><span class="line">    GPIOMode_TypeDef GPIO_Mode;    <span class="comment">//设置工作模式：8种中的一个</span></span><br><span class="line">	&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line">GPIOx: GPIOA~GPIOG</span><br></pre></td></tr></table></figure>
<p>​    GPIO_Init函数初始化样例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED0--&gt;PB.5 端口配置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//IO口速度为50MHz</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	 <span class="comment">//根据设定参数初始化GPIOB.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>2个读取输入电平函数：</p>
<ul>
<li><p><code>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：读取某个GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);<span class="comment">//读取GPIOA.5的输入电平</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);</code><br>作用：读取某组GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。<br>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadInputData(GPIOA);<span class="comment">//读取GPIOA组中所有io口输入电平</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2个读取输出电平函数：</p>
<ul>
<li><p><code>uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5);<span class="comment">//读取GPIOA.5的输出电平</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);</code><br>作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadOutputData(GPIOA);<span class="comment">//读取GPIOA组中所有io口输出电平</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>4个设置输出电平函数：</p>
<ul>
<li><code>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：设置某个IO口输出为高电平（1）。实际操作BSRR寄存器</li>
<li><code>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：设置某个IO口输出为低电平（0）。实际操作的BRR寄存器。</li>
<li><code>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);</code></li>
<li><code>void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);</code><br> 这两个函数不常用，也是用来设置IO口输出电平。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按键输入：</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(mode==<span class="number">1</span>) key_up=<span class="number">1</span>;<span class="comment">//支持连续按</span></span><br><span class="line">      <span class="keyword">if</span>（key_up &amp;&amp;  KEY按下）</span><br><span class="line">      &#123;</span><br><span class="line">        delay_ms(<span class="number">10</span>);<span class="comment">//延时，防抖</span></span><br><span class="line">        key_up=<span class="number">0</span>;<span class="comment">//标记这次key已经按下</span></span><br><span class="line">        <span class="keyword">if</span>(KEY确实按下)</span><br><span class="line">          &#123;</span><br><span class="line">           <span class="keyword">return</span> KEY_VALUE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY没有按下)  key_up=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> 没有按下</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h2><p>头文件: stm32f10x_rcc.h</p>
<p>源文件:stm32f10x_rcc.c</p>
<ol>
<li><p>时钟使能配置:</p>
<p>  <code>RCC_LSEConfig()</code> 、<code>RCC_HSEConfig()</code>、<code>RCC_HSICmd()</code> 、 <code>RCC_LSICmd()</code> 、 <code>RCC_PLLCmd()</code> ……</p>
</li>
<li><p>时钟源相关配置：<br>   <code>RCC_PLLConfig ()</code>、 <code>RCC_SYSCLKConfig()</code> 、<code>RCC_RTCCLKConfig()</code> …</p>
</li>
<li><p>分频系数选择配置：<br>  <code>RCC_HCLKConfig()</code> 、 <code>RCC_PCLK1Config()</code> 、 <code>RCC_PCLK2Config()</code>…</p>
</li>
<li><p>外设时钟使能：<br>  <code>RCC_APB1PeriphClockCmd():</code>  //APB1线上外设时钟使能<br>  <code>RCC_APB2PeriphClockCmd();</code>  //APB2线上外设时钟使能<br>  <code>RCC_AHBPeriphClockCmd();</code>   //AHB线上外设时钟使能</p>
</li>
<li><p>其他外设时钟配置：</p>
<p> <code>RCC_ADCCLKConfig ();</code>  <code>RCC_RTCCLKConfig();</code></p>
</li>
<li><p>状态参数获取参数：<br> <code>RCC_GetClocksFreq();</code><br> <code>RCC_GetSYSCLKSource();</code><br> <code>RCC_GetFlagStatus()</code></p>
</li>
<li><p>RCC中断相关函数 :<br> <code>RCC_ITConfig()</code> 、<code>RCC_GetITStatus()</code> 、 <code>RCC_ClearITPendingBit()</code>…</p>
</li>
</ol>
<hr>
<h2 id="NVIC中断优先级分组"><a href="#NVIC中断优先级分组" class="headerlink" title="NVIC中断优先级分组"></a>NVIC中断优先级分组</h2><ul>
<li><p>中断管理方法：</p>
<p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p>
</li>
<li><p>抢占优先级 &amp; 响应优先级区别：</p>
<p>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。</p>
<p>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。</p>
<p>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。</p>
<p>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</p>
</li>
<li><p>一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。</p>
</li>
<li><p>中断优先级分组函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</span><br><span class="line">  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>中断参数初始化函数：</p>
<p><code>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannel; <span class="comment">//设置中断通道</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelPreemptionPriority;<span class="comment">//设置响应优先级</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelSubPriority; <span class="comment">//设置抢占优先级</span></span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd; <span class="comment">//使能/使能</span></span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//串口1中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span> ;<span class="comment">// 抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;<span class="comment">// 子优先级位2</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);	<span class="comment">//根据上面指定的参数初始化NVIC寄存器</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>中断优先级设置步骤：</p>
<ol>
<li>系统运行后先设置中断优先级分组。调用函数：<br>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);<br> （整个系统执行过程中，只设置一次中断分组。）</li>
<li>针对每个中断，设置对应的抢占优先级和响应优先级：<br>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</li>
<li>如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">()</span></span>; <span class="comment">//串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Cmd</span><span class="params">()</span></span>;<span class="comment">//使能串口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">()</span></span>;<span class="comment">//使能相关中断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendData</span><span class="params">()</span></span>;<span class="comment">//发送数据到串口，DR</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">USART_ReceiveData</span><span class="params">()</span></span>;<span class="comment">//接受数据，从DR读取接受到的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function">FlagStatus <span class="title">USART_GetFlagStatus</span><span class="params">()</span></span>;<span class="comment">//获取状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearFlag</span><span class="params">()</span></span>;<span class="comment">//清除状态标志位</span></span><br><span class="line"><span class="function">ITStatus <span class="title">USART_GetITStatus</span><span class="params">()</span></span>;<span class="comment">//获取中断状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">()</span></span>;<span class="comment">//清除中断状态标志位</span></span><br></pre></td></tr></table></figure>
<p>波特率计算方法</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/stm32-learn-2.png" alt="2"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/stm32-learn-3.png" alt="3"></p>
<p>串口配置的一般步骤</p>
<ol>
<li>串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd();</li>
<li>串口复位:USART_DeInit(); 这一步不是必须的</li>
<li>GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP</li>
<li>串口参数初始化：USART_Init();</li>
<li>开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）<pre><code>  NVIC_Init();
  USART_ITConfig();
</code></pre></li>
<li>使能串口:USART_Cmd();</li>
<li>编写中断处理函数：USARTx_IRQHandler();</li>
<li>串口数据收发：<br>void USART_SendData();//发送数据到串口，DR<br>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据</li>
<li>串口传输状态获取：<br>FlagStatus USART_GetFlagStatus(USART_TypeDef<em> USARTx, uint16_t USART_FLAG);<br>void USART_ClearITPendingBit(USART_TypeDef</em> USARTx, uint16_t USART_IT);</li>
</ol>
<hr>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><ul>
<li><p><code>void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);</code><br>   //设置IO口与中断线的映射关系</p>
<p>   例:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);</code><br> //初始化中断线：触发方式等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line;   <span class="comment">//指定要配置的中断线           </span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;   <span class="comment">//模式：事件 OR中断</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;<span class="comment">//触发方式：上升沿/下降沿/双沿触发</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;  <span class="comment">//使能 OR失能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line2;	 </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);	 	</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);</code><br>//判断中断线中断状态，是否发生</p>
</li>
<li><p><code>void EXTI_ClearITPendingBit(uint32_t EXTI_Line);</code><br>//清除中断线上的中断标志位</p>
</li>
<li><p>外部中断的一般配置步骤：</p>
<ol>
<li>初始化IO口为输入。<pre><code>GPIO_Init();
</code></pre></li>
<li>开启IO口复用时钟。<pre><code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
</code></pre></li>
<li>设置IO口与中断线的映射关系。<pre><code>void GPIO_EXTILineConfig();
</code></pre></li>
<li>初始化线上中断，设置触发条件等。<pre><code>   EXTI_Init();
</code></pre></li>
<li>配置中断分组（NVIC），并使能中断。<pre><code>   NVIC_Init();
</code></pre></li>
<li>编写中断服务函数。<pre><code>  EXTIx_IRQHandler();
</code></pre></li>
<li>清除中断标志位<pre><code>  EXTI_ClearITPendingBit();
</code></pre></li>
</ol>
</li>
</ul>
<hr>
<h2 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h2><ul>
<li><p>定时器参数初始化：         </p>
<p><code>void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Prescaler;        </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_CounterMode;     </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Period;        </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ClockDivision;  </span><br><span class="line">  <span class="keyword">uint8_t</span> TIM_RepetitionCounter;</span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef; </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_Period = <span class="number">4999</span>; TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">7199</span>; TIM_TimeBaseStructure.TIM_ClockDivision =   TIM_CKD_DIV1; TIM_TimeBaseStructure.TIM_CounterMode =   TIM_CounterMode_Up; </span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); </span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器使能函数：</p>
<p><code>void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)</code></p>
</li>
<li><p>定时器中断使能函数：</p>
<p><code>void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);</code></p>
</li>
<li><p>状态标志位获取和清除：</p>
<p><code>FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);</code><br><code>void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);</code><br><code>ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);</code><br><code>void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);</code></p>
</li>
<li><p>定时器中断实现步骤</p>
<ol>
<li>能定时器时钟。<pre><code>  RCC_APB1PeriphClockCmd();
</code></pre></li>
<li>初始化定时器，配置ARR,PSC。<pre><code>TIM_TimeBaseInit();
</code></pre></li>
<li>开启定时器中断，配置NVIC。<pre><code>void TIM_ITConfig();
NVIC_Init();
</code></pre></li>
<li>使能定时器。<pre><code>TIM_Cmd();
</code></pre></li>
<li>编写中断服务函数。<pre><code>TIMx_IRQHandler();
</code></pre></li>
</ol>
</li>
</ul>
<hr>
<h2 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h2><ul>
<li><p>初始化：</p>
<p><code>void TIM_OCxInit(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCMode;  <span class="comment">//PWM模式1或者模式2</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OutputState; <span class="comment">//输出使能 OR失能</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OutputNState;</span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Pulse; <span class="comment">//比较值，写CCRx</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCPolarity; <span class="comment">//比较输出极性</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCNPolarity; </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCIdleState;  </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCNIdleState; </span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//PWM模式2</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">TIM_OCInitStructure. TIM_Pulse=<span class="number">100</span>;</span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性:TIM输出比较极性高</span></span><br><span class="line">TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  <span class="comment">//根据T指定的参数初始化外设TIM3 OC2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>设置比较值函数：</p>
<p><code>void TIM_SetCompareX(TIM_TypeDef* TIMx, uint16_t Compare2);</code></p>
</li>
<li><p>使能输出比较预装载：</p>
<p><code>void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);</code></p>
</li>
<li><p>使能自动重装载的预装载寄存器允许位：</p>
<p><code>void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);</code></p>
</li>
<li><p>PWM输出配置步骤：</p>
<ol>
<li>使能定时器3和相关IO口时钟。<pre><code>使能定时器3时钟：RCC_APB1PeriphClockCmd();
使能GPIOB时钟：RCC_APB2PeriphClockCmd();
</code></pre></li>
<li>初始化IO口为复用功能输出。函数：GPIO_Init();<pre><code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;      
</code></pre></li>
<li>这里我们是要把PB5用作定时器的PWM输出引脚，所以要重映射配置，<pre><code>所以需要开启AFIO时钟。同时设置重映射。
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
 GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); 
</code></pre></li>
<li>初始化定时器：ARR,PSC等：TIM_TimeBaseInit();</li>
<li>初始化输出比较参数:TIM_OC2Init()</li>
<li>使能预装载寄存器： TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); </li>
<li>使能定时器。TIM_Cmd();</li>
<li>不断改变比较值CCRx，达到不同的占空比效果:TIM_SetCompare2();</li>
</ol>
</li>
</ul>
<hr>
<h2 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h2><ul>
<li><p>初始化函数：</p>
<p><code>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Channel; <span class="comment">//捕获通道1-4   </span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICPolarity; <span class="comment">//捕获极性</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICSelection; <span class="comment">//映射关系</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICPrescaler; <span class="comment">//分频系数</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICFilter;  <span class="comment">//滤波器</span></span><br><span class="line">&#125; TIM_ICInitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; </span><br><span class="line">TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM5_ICInitStructure.TIM_ICFilter = <span class="number">0x00</span>;</span><br><span class="line">TIM_ICInit(TIM5, &amp;TIM5_ICInitStructure);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通道极性设置独立函数：</p>
<p><code>void 