<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chrome多设备书签同步方案</title>
    <url>/posts/a53da602.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Chrome多设备书签同步方案"><a href="#Chrome多设备书签同步方案" class="headerlink" title="Chrome多设备书签同步方案"></a>Chrome多设备书签同步方案</h1><p>众所周知因为某些原因Chrome无法与它的服务器正常通讯,这就影响到了我们书签的同步,这里介绍一个插件,将书签同步到GitHub或GItee上.</p>
<p>项目地址: ↓ </p>
<p><a href="https://github.com/CLDeveloping/chrome-bookmark">Github项目</a> | <a href="https://gitee.com/CLCoding/chrome-bookmark">Gitee项目</a></p>
<ul>
<li>将项目整个下载下来,解压缩,在浏览器地址栏输入：<code>chrome://extensions/</code>，进入扩展程序管理界面</li>
<li>点击【加载已解压的扩展程序】-&gt; 选择项目根目录，导入源码文件夹</li>
<li>这里只介绍GitHub操作.进入自己的GitHub创建一个私有项目,随便命名</li>
<li>获取Github项目<a href="https://github.com/settings/tokens">私有访问Token</a>（如何获取：Github -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token）选择repo,时间选无限,将生成的token拷贝下来,这个只会出现一次,最好拿小本本记下来</li>
<li>点击书签工具配置,将仓库地址和token填入,选择保存配置</li>
<li>重新点击书签图标工具，就可以选择上传或者下载书签了</li>
</ul>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium Designer导出Gerber文件的一般步骤</title>
    <url>/posts/a1423033.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Altium-Designer导出Gerber文件的一般步骤"><a href="#Altium-Designer导出Gerber文件的一般步骤" class="headerlink" title="Altium Designer导出Gerber文件的一般步骤"></a>Altium Designer导出Gerber文件的一般步骤</h1><p>PCB画完之后，需要生成Gerber文件提交给PCB工厂进行生产，本文将介绍生成Gerber的一般步骤</p>
<h2 id="一、导出非机械层"><a href="#一、导出非机械层" class="headerlink" title="一、导出非机械层"></a>一、导出非机械层</h2><h3 id="1-1-”文件“-gt-”制造输出“-gt-“Gerber-Files”"><a href="#1-1-”文件“-gt-”制造输出“-gt-“Gerber-Files”" class="headerlink" title="1.1 ”文件“ -&gt; ”制造输出“ -&gt; “Gerber Files”"></a>1.1 ”文件“ -&gt; ”制造输出“ -&gt; “Gerber Files”</h3><p>（“File”-&gt;“Fabrication Outputs”-&gt;“Gerber Files”）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-1.png" alt="image-20210806221126738"></p>
<h3 id="1-2-通用（General）"><a href="#1-2-通用（General）" class="headerlink" title="1.2 通用（General）"></a>1.2 通用（General）</h3><p>单位：英寸（Inches）</p>
<p>格式：2:5</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-2.png" alt="image-20210806221658661"></p>
<h3 id="1-3-层（Layers）"><a href="#1-3-层（Layers）" class="headerlink" title="1.3 层（Layers）"></a>1.3 层（Layers）</h3><p>左面出图层除机械层全选择，镜像层不选，最下面四个层的合集与上面层重复全部不选</p>
<p>右面机械层全不选</p>
<p>下面勾选”包括未连接的中间层焊盘“（Include unconnected mid-layer pads）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-3.png" alt="image-20210806222145277"></p>
<h3 id="1-4-钻孔图层（Drill-Drawing）"><a href="#1-4-钻孔图层（Drill-Drawing）" class="headerlink" title="1.4 钻孔图层（Drill Drawing）"></a>1.4 钻孔图层（Drill Drawing）</h3><p>全不选</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-4.png" alt="image-20210806222318634"></p>
<h3 id="1-5-光圈（Apertures）"><a href="#1-5-光圈（Apertures）" class="headerlink" title="1.5 光圈（Apertures）"></a>1.5 光圈（Apertures）</h3><p>选择嵌入的孔径（Embedded apertures）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-5.png" alt="image-20210806222832869"></p>
<h3 id="1-6-高级（Advanced）"><a href="#1-6-高级（Advanced）" class="headerlink" title="1.6 高级（Advanced）"></a>1.6 高级（Advanced）</h3><p>设置如图两项，其他默认即可</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-6.png" alt="image-20210806223016206"></p>
<h3 id="1-7-点击确定（OK）"><a href="#1-7-点击确定（OK）" class="headerlink" title="1.7 点击确定（OK）"></a>1.7 点击确定（OK）</h3><p>弹出的直接关掉，不用保存</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-1-7.png" alt="image-20210806223142508"></p>
<h2 id="二、导出机械层"><a href="#二、导出机械层" class="headerlink" title="二、导出机械层"></a>二、导出机械层</h2><h3 id="2-1-“文件“-gt-”制造输出“-gt-”Gerber-Files“"><a href="#2-1-“文件“-gt-”制造输出“-gt-”Gerber-Files“" class="headerlink" title="2.1 “文件“ -&gt; ”制造输出“ -&gt; ”Gerber Files“"></a>2.1 “文件“ -&gt; ”制造输出“ -&gt; ”Gerber Files“</h3><p>同2.1</p>
<h3 id="2-2-通用（General）"><a href="#2-2-通用（General）" class="headerlink" title="2.2 通用（General）"></a>2.2 通用（General）</h3><p>同2.1</p>
<h3 id="3-层（Layers）"><a href="#3-层（Layers）" class="headerlink" title="3. 层（Layers）"></a>3. 层（Layers）</h3><p>左面出图层全不选，镜像层全不选</p>
<p>右面机械层全选</p>
<p>取消勾选”包括未连接的中间层焊盘“（Include unconnected mid-layer pads）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-2-3.png" alt="image-20210806223538241"></p>
<h3 id="2-4-钻孔图层（Drill-Drawing）"><a href="#2-4-钻孔图层（Drill-Drawing）" class="headerlink" title="2.4 钻孔图层（Drill Drawing）"></a>2.4 钻孔图层（Drill Drawing）</h3><p>勾选钻孔图（Drill Drawing Plots）和钻孔向导图（Drill Guide Plots）下的输出所有使用的钻孔对（Plot all used drill pairs）</p>
<p>不勾选镜像输出</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-2-4.png" alt="image-20210806223735534"></p>
<h3 id="2-5-光圈（Apertures）"><a href="#2-5-光圈（Apertures）" class="headerlink" title="2.5 光圈（Apertures）"></a>2.5 光圈（Apertures）</h3><p>同1.5</p>
<h3 id="2-6-高级（Advanced）"><a href="#2-6-高级（Advanced）" class="headerlink" title="2.6 高级（Advanced）"></a>2.6 高级（Advanced）</h3><p>同1.6</p>
<h3 id="2-7-点击确定（OK）"><a href="#2-7-点击确定（OK）" class="headerlink" title="2.7 点击确定（OK）"></a>2.7 点击确定（OK）</h3><p>弹出的直接关掉，不用保存</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-2-7.png" alt="image-20210806223916694"></p>
<h2 id="三、导出钻孔层"><a href="#三、导出钻孔层" class="headerlink" title="三、导出钻孔层"></a>三、导出钻孔层</h2><h3 id="3-1-”文件”-gt-“制造输出”-gt-“NC-Drill-Files”"><a href="#3-1-”文件”-gt-“制造输出”-gt-“NC-Drill-Files”" class="headerlink" title="3.1 ”文件” -&gt; “制造输出” -&gt; “NC Drill Files”"></a>3.1 ”文件” -&gt; “制造输出” -&gt; “NC Drill Files”</h3><p>（“File”-&gt;“Fabrication Outputs”-&gt;“NC Drill Files”）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-3-1.png" alt="image-20210806224045854"></p>
<h3 id="3-2-如图设置"><a href="#3-2-如图设置" class="headerlink" title="3.2 如图设置"></a>3.2 如图设置</h3><p>单位：英寸（Inches）</p>
<p>格式：2:5</p>
<p>前导/尾数零（Leading/Trailing Zeroes）：摒弃前导零（Suppress leading zeroes）</p>
<p>其他默认即可</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-3-2.png" alt="image-20210806224252303"></p>
<h3 id="3-3-点击确定（OK）"><a href="#3-3-点击确定（OK）" class="headerlink" title="3.3 点击确定（OK）"></a>3.3 点击确定（OK）</h3><p>弹出“导入钻孔数据”（Import Drill Data），点击确定</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-3-3.png" alt="image-20210806224531631"></p>
<p>如果又弹出一个，同样点击确定即可</p>
<p>都不用保存，直接关掉</p>
<h2 id="四、到此为止，已经完成了Gerber文件的导出"><a href="#四、到此为止，已经完成了Gerber文件的导出" class="headerlink" title="四、到此为止，已经完成了Gerber文件的导出"></a>四、到此为止，已经完成了Gerber文件的导出</h2><p>Gerber默认导出在PCB所在目录下的“Project Outputs for XXX”文件夹，如图</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/AD-Gerber-4-1.png" alt="image-20210806225134364"></p>
<p>将整个文件夹打包，发给PCB厂家</p>
<hr>
<p>Github：<a href="https://github.com/fan-ziqi">点击进入</a></p>
]]></content>
      <categories>
        <category>Altium Designer</category>
      </categories>
      <tags>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>CubeMX配置SPI-Flash(W25Q256)</title>
    <url>/posts/7b613e40.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CubeMX配置SPI-Flash-W25Q256"><a href="#CubeMX配置SPI-Flash-W25Q256" class="headerlink" title="CubeMX配置SPI-Flash(W25Q256)"></a>CubeMX配置SPI-Flash(W25Q256)</h1><p>W25Q256（256Mb）将32M（字节byte）的容量分为512个块（block），每个块大小为64K字节，每个块又分为16个扇区（sector）,每个扇区4K字节。最小擦除单位为一个扇区，也就是4K字节。</p>
<p>首先应该配置SPI,但是这里有个大坑.</p>
<p>按照标准的SPI协议，当SPI被配置为主机模式后，通过SPI对从设备进行操作时，其NSS应该自动置低，从而选中（使能）从设备；一旦不对从设备进行操作，NSS立刻置为高。</p>
<p>但是，我在实际调试过程中发现：STM32 SPI NSS无法自动实现跳变。 一旦SPI初始化完成并使能SPI，NSS立刻置低，然后保持不变。</p>
<p>这个问题一直无法解决，直到我在ST官方论坛上看到国外有些技术人员也在讨论这个问题，他们得出的结论是：STM32 SPI NSS无法自动跳变。</p>
<p>ST官方技术人员也证实：STM32 SPI NSS是不会自动置位和复位的。按照官方说法，ST已经将其列入了改进计划。</p>
<p>对于这个问题，可以采用下面的方法解决：</p>
<p>在SPI初始化时，采用NSS soft模式，然后使能NSS输出功能。从而将NSS当做GPIO使用，通过软件set和reset来实现NSS的置位和复位。</p>
<p>具体在CubeMX中应将FLASH的NSS当成GPIO Output配置而不是SPI NSS.配置如图所示:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113160700854.png" alt="image-20220113160700854"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113160802730.png" alt="image-20220113160802730"></p>
<p>因为需要在flash中存入浮点数,所以需要类型转换,这里使用union联合体实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> union_float;</span><br><span class="line">    <span class="keyword">uint8_t</span> union_int8[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">test</span> <span class="title">Test_write</span>,<span class="title">Test_read</span>;</span></span><br><span class="line">Test_write.union_float=<span class="number">1.23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读flash的id</span></span><br><span class="line">BSP_W25Q256_Read_ID(id);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ID = 0x%02X%02X\r\n&quot;</span>, id[<span class="number">0</span>], id[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试flash的擦读写</span></span><br><span class="line">BSP_W25Q256_Erase_Block(<span class="number">0</span>);</span><br><span class="line">BSP_W25Q256_Write(Test_write.union_int8, <span class="number">0</span>, <span class="keyword">sizeof</span>(Test_write.union_int8));</span><br><span class="line">BSP_W25Q256_Read(Test_read.union_int8, <span class="number">0</span>, <span class="keyword">sizeof</span>(Test_read.union_int8));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Ready to write:  float: %f, trans to uint8: 0x%x 0x%x 0x%x 0x%x\r\n&quot;</span>, </span><br><span class="line">       Test_write.union_float, </span><br><span class="line">       Test_write.union_int8[<span class="number">0</span>],</span><br><span class="line">       Test_write.union_int8[<span class="number">1</span>], </span><br><span class="line">       Test_write.union_int8[<span class="number">2</span>],</span><br><span class="line">       Test_write.union_int8[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Read from Flash: uint8: 0x%x 0x%x 0x%x 0x%x, trans to float: %f\r\n&quot;</span>, </span><br><span class="line">       Test_read.union_int8[<span class="number">0</span>],</span><br><span class="line">       Test_read.union_int8[<span class="number">1</span>],</span><br><span class="line">       Test_read.union_int8[<span class="number">2</span>],</span><br><span class="line">       Test_read.union_int8[<span class="number">3</span>],</span><br><span class="line">       Test_read.union_float);</span><br></pre></td></tr></table></figure>
<p>参考:</p>
<p>关于STM32 SPI NSS的讨论 <a href="https://blog.csdn.net/chseangs/article/details/4520733">https://blog.csdn.net/chseangs/article/details/4520733</a></p>
<p>SPI problem with hardware NSS management <a href="https://community.st.com/s/question/0D50X00009XkbvdSAB/spi-problem-with-hardware-nss-management">https://community.st.com/s/question/0D50X00009XkbvdSAB/spi-problem-with-hardware-nss-management</a></p>
<p>STM32CbueMX之W25Q256 <a href="https://blog.csdn.net/sudaroot/article/details/93158309">https://blog.csdn.net/sudaroot/article/details/93158309</a></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitbook</title>
    <url>/posts/d5c8f039.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Gitbook"><a href="#Gitbook" class="headerlink" title="Gitbook"></a>Gitbook</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装gitbook"><a href="#安装gitbook" class="headerlink" title="安装gitbook"></a>安装gitbook</h3><p>gitbook基于Node.js，所以要先安装Node.js，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F">官网</a>。</p>
<p>安装好node后，安装gitbook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g gitbook-cli</span><br><span class="line">//当前目录下安装</span><br><span class="line">npm install gitbook-cli</span><br></pre></td></tr></table></figure>
<h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><p>安装好之后执行<code>gitbook -V</code>检查版本，不出意外应该会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CLI version: 2.3.2</span><br><span class="line">Installing GitBook 3.2.3</span><br><span class="line">/xxx/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287</span><br><span class="line">      <span class="keyword">if</span> (cb) cb.apply(this, arguments)</span><br><span class="line">                 ^</span><br><span class="line"></span><br><span class="line">TypeError: cb.apply is not a <span class="keyword">function</span></span><br><span class="line">    at /data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18</span><br><span class="line">    at FSReqCallback.oncomplete (fs.js:169:5)</span><br></pre></td></tr></table></figure>
<p>此时需要进入上面给出的目录，找到polyfills.js，将62-64注释掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs.stat = statFix(fs.stat)</span></span><br><span class="line"><span class="comment">//fs.fstat = statFix(fs.fstat)</span></span><br><span class="line"><span class="comment">//fs.lstat = statFix(fs.lstat)</span></span><br></pre></td></tr></table></figure>
<p>此时运行<code>gitbook -V</code>不会报错。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>新建一个工程目录，在目录下执行<code>gitbook init</code>，应该又报错了。这是因为node的版本太高了，需要对node进行降级。这里我推荐使用nvm来管理nodeJs的版本。因为我还有使用高版本node的需求，而且降级也挺麻烦的。nvm的<a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a>，选择nvm-setup.zip，安装时第二个路径要选择nodejs的安装路径。</p>
<p>查看安装的nodejs版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure>
<p>安装低版本nodejs，这个版本经测试可用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install v12.22.3</span><br></pre></td></tr></table></figure>
<p>等待安装完，切换版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm use v12.22.3</span><br></pre></td></tr></table></figure>
<p>回到工程根目录再次初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure>
<p>初始化成功，创建了<code>README.md</code>（书籍的介绍）和<code>SUMMARY.md</code>（书籍的目录结构）</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这里拿自动目录插件举例，在工程根目录下创建一个<code>book.json</code>，写入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;summary&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根目录下执行<code>gitbook install ./</code>即可安装插件。启动服务后这个插件会自动生成目录。下文会讲解如何生成目录。</p>
<h2 id="加入文章"><a href="#加入文章" class="headerlink" title="加入文章"></a>加入文章</h2><p>在根目录下创建文件夹，以数字和短横线开头：<code>0-Example</code>，同样<code>0-Example</code>下也可以创建子文件夹。每一个文件夹相当于一个目录，子文件夹就是多级目录。</p>
<p>每一个子文件夹下要有一个命名为<code>0-README.md</code>的文件，用于放置这个目录的简介，其他md文件也要以数字和短横线开头：<code>1-TestPage.md</code></p>
<h2 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h2><p>加入好文章之后，启动本地服务，前文安装的summary插件会自动生成层级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中打开<a href="http://localhost:4000/，检验你的成果！">http://localhost:4000/，检验你的成果！</a></p>
]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作</title>
    <url>/posts/c4c88997.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><ul>
<li><p>安装</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看版本</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成密钥</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUREMAIL&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看公钥</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub </span><br></pre></td></tr></table></figure>
</li>
<li><p>GIthub -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key</p>
</li>
<li><p>检查本地是否能远程访问github服务器，出现You’ve successfully authenticated，说明认证通过。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置自己的名称和电子邮件地址</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;YOURNAME&quot;</span><br><span class="line">git config --global user.email &quot;YOUREMAIL&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看设置</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>新项目</p>
<ul>
<li><p>建立新的repository</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/new</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建目录</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/test_project</span><br><span class="line">cd ~/test_project</span><br><span class="line">git init //初始化一个空的git repository  </span><br><span class="line">git remote add origin https://github.com//username//test_project.git //第一次初始化</span><br><span class="line">git checkout -b main //切换本地分支为main</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add . //添加文件</span><br><span class="line">git commit -am &quot;first commit&quot; //-m指定本次提交的描述信息 </span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置set-upstream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/main main</span><br><span class="line">git push //之后push用这个</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>已有项目</p>
<ul>
<li><p>clone下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:fan-ziqi/My_ROS_Robot.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/test_project</span><br><span class="line">cd ~/test_project</span><br><span class="line">git init //初始化一个空的git repository  </span><br><span class="line">git remote add origin https://github.com//username//test_project.git //第一次初始化</span><br><span class="line">git checkout -b main //切换本地分支为main</span><br></pre></td></tr></table></figure>
</li>
<li><p>pull下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置set-upstream</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/main main</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .   // .代表添加所有文件  </span><br><span class="line">git commit -am &quot;对文件操作的简易描述&quot;  </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>出现错误<code>error: failed to push some refs to &#39;https://github.com/xxx/xxx.git&#39;</code></p>
<p>出现错误的原因是github中的某些文件不在本地代码目录中。</p>
<p>也就是说我们需要先将远程代码库中的任何文件先pull到本地代码库中，才能push新的代码到github代码库中。</p>
<p>使用如下命令：git pull —rebase origin main</p>
<p>然后再进行上传: git push -u origin main</p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo部署至云服务器的宝塔面板</title>
    <url>/posts/6b69667c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo部署至云服务器的宝塔面板"><a href="#Hexo部署至云服务器的宝塔面板" class="headerlink" title="Hexo部署至云服务器的宝塔面板"></a>Hexo部署至云服务器的宝塔面板</h1><blockquote>
<p>本文为网络转载, 版权属于：Heson</p>
<p>原文链接：<a href="https://www.heson10.com/posts/51315.html">https://www.heson10.com/posts/51315.html</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo 博客部署方法有好多种，<code>github pages</code>、<code>gitee pages(pro)</code>、<code>vercel</code>，<code>cloudflare page</code>、<code>阿里云oss</code>、<code>腾讯存储桶</code>等等这些不需要购买服务器的部署方式。一般大部分都用以上方式部署自己的hexo博客，但也有少部分部署在<code>自己服务器</code>的同志。</p>
<p>新手部署服务器最常见的方法就是：直接把本地生成的<code>public</code>中的文件，直接ftp到服务器<code>www根目录</code>，简单粗暴。</p>
<p>还有一种更优雅地方式，那就是直接在服务器上搭建<code>git仓库</code>，hexo三连直接<code>deploy</code>上去（跟搭建在github pages上的方式一样）。</p>
<h2 id="为什么要部署至服务器？"><a href="#为什么要部署至服务器？" class="headerlink" title="为什么要部署至服务器？"></a>为什么要部署至服务器？</h2><p>个人感觉手头有闲置的网速较快的服务器，可以尝试部署至服务器。</p>
<p>比如我手头有一个<code>腾讯云香港二区 2核 4GB 5M的服务器。</code>对比了一下我放在又拍云cdn上的主站网速，可以看到：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-1.png" alt="hexo-bt-1"></p>
<p><strong>这速度可谓不相上下。</strong></p>
<p>相比起github pages的慢、coding pages的抽（移动宽带经常抽），服务器部署还是有一定优势的。</p>
<p>当然，如果域名<code>备案</code>了，手头没有闲置的<code>服务器</code>，还是建议嫖上国内的CDN（又拍云）。</p>
<h2 id="部署教程"><a href="#部署教程" class="headerlink" title="部署教程"></a>部署教程</h2><p>老样子，简单说下思路：</p>
<ul>
<li>服务器安装宝塔面板</li>
<li>创建git仓库，并配置git钩子，自动同步文件到网站目录</li>
<li>配置网站访问设置</li>
<li>本地<code>git deploy</code>设置</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.云服务安装宝塔面板</p>
<p>2.本地生成ssh秘钥备用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub的邮箱&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;GitHub的邮箱&quot;</span><br></pre></td></tr></table></figure>
<h3 id="连接服务器终端"><a href="#连接服务器终端" class="headerlink" title="连接服务器终端"></a>连接服务器终端</h3><p>宝塔面板用户可直接左侧导航栏<code>终端</code>登录（如图）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-2.png" alt="hexo-bt-2"></p>
<ul>
<li>切换到 <code>root</code> 账号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure>
<p>宝塔默认是root账号，注意看图：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-3.png" alt="hexo-bt-3"></p>
<ul>
<li>安装 <code>git</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure>
<h3 id="创建-Git-账户"><a href="#创建-Git-账户" class="headerlink" title="创建 Git 账户"></a>创建 Git 账户</h3><p>创建 Git 账户并赋予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br><span class="line">chmod 740 /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>编辑 <code>/etc/sudoers</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>键进入编辑模式，找到<code>root ALL=(ALL) ALL</code>，在其下方加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-4.png" alt="hexo-bt-4"></p>
<p>输入完成后按<code>esc</code>，再输入<code>:wq</code>，保存退出。</p>
<p>更变<code>/etc/sudoers</code>权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>设置 git 账户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure>
<p>输入密码，输入的时候是看不到任何显示的，输完回车即可。</p>
<p>切换至 <code>git 用户</code>，创建 <code>~/.ssh</code> 文件夹和 <code>~/.ssh/authorized_keys</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>同样<code>i</code>进入编辑模式，把之前本地准备的<code>id_rsa.pub</code>文件中的公钥复制进去，按<code>esc</code>后，输入<code>:wq</code>保存。<strong>(注意!!!!!!!!!!! 最后一行要加回车)</strong></p>
<p>更改权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 /home/git/.ssh/authorized_keys</span><br><span class="line">chmod 700 /home/git/.ssh</span><br></pre></td></tr></table></figure>
<p>本地测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -v git@服务器ip地址或域名</span><br></pre></td></tr></table></figure>
<p>不用输密码就成了。</p>
<h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p>切换为<code>root</code>用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su root</span><br></pre></td></tr></table></figure>
<p>创建<code>repo</code>作为仓库目录，并加权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/repo</span><br><span class="line">chown -R git:git /var/repo</span><br><span class="line">chmod -R 755 /var/repo</span><br></pre></td></tr></table></figure>
<p>创建 hexo 目录作为网站根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/hexo</span><br><span class="line">chown -R git:git /var/hexo</span><br><span class="line">chmod -R 755 /var/hexo</span><br></pre></td></tr></table></figure>
<p>创建一个空白的 git 仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure>
<p>编辑一个 Git 钩子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>进入编辑模式，添加下面的代码，按<code>esc</code>输入<code>:wq</code> 保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure>
<p>更改权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git /var/repo/hexo.git/hooks/post-receive</span><br><span class="line">chmod +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<h3 id="宝塔网站配置"><a href="#宝塔网站配置" class="headerlink" title="宝塔网站配置"></a>宝塔网站配置</h3><p>创建一个网站</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/hexo-bt-5.png" alt="hexo-bt-5"></p>
<h3 id="本地-Git-deploy-设置"><a href="#本地-Git-deploy-设置" class="headerlink" title="本地 Git deploy 设置"></a>本地 Git deploy 设置</h3><p>安装git部署插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>在博客根目录配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@服务器ip或域名:/var/repo/hexo.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>配置完成后，可直接hexo三连到自己的服务器。简单快捷。</p>
<p>如果报错:<code>error: remote unpack failed: index-pack abnormal exit</code>, 删除<code>/var/hexo</code>下的所有文件. 包括<code>.user.ini</code>, 这个文件作用为防跨站, 添加权限之后可以再添加回来.</p>
<p>重新给权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R git:git /var/repo</span><br><span class="line">chmod -R 755 /var/repo</span><br><span class="line"></span><br><span class="line">chown -R git:git /var/hexo</span><br><span class="line">chmod -R 755 /var/hexo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MPU6050-DMP读不出数据</title>
    <url>/posts/bfa5a820.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MPU6050-DMP读不出数据"><a href="#MPU6050-DMP读不出数据" class="headerlink" title="MPU6050-DMP读不出数据"></a>MPU6050-DMP读不出数据</h1><p>遇上一个很头疼的问题，MPU6050可以正常读取三个轴的数据，但是使用DMP方式读取数据时，会卡在这一句上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get a packet. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mpu_read_fifo_stream</span>(dmp.packet_length, fifo_data, more))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>进入此函数，通过逐句debug，发现卡在这一句上了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!st.chip_cfg.dmp_on)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>问题来了，这说的是dmp没有打开啊？？可是前面命名已经使能了DMP</p>
<p>于是打开百度，同样问题的解答有以下几点</p>
<ul>
<li>MPU6050供电问题，经检查确实为3.3V，故排除</li>
<li>FIFO没有使能，经检查也有使能，排除</li>
</ul>
<p>嘶 那问题出在哪呢</p>
<p><strong>MPU6050不讲武德，它坏了</strong></p>
<p><strong>换一个芯片就好了</strong></p>
<p><strong>RNM退钱！</strong></p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——什么是接口</title>
    <url>/posts/333442d9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——什么是接口"><a href="#ROS2——什么是接口" class="headerlink" title="ROS2——什么是接口"></a>ROS2——什么是接口</h1><h2 id="接口简介"><a href="#接口简介" class="headerlink" title="接口简介"></a>接口简介</h2><p>在机器人系统中, 往往有许许多多的硬件, 比如摄像头, 激光雷达, 每一个硬件发送的数据/数据类型是不同的, 那么ROS2是如何使用这些数据的呢?</p>
<p>前文<code>KFC</code>和<code>Hamburger</code>中我们使用过这些定义:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/u_int32.hpp&quot;</span></span></span><br><span class="line">...</span><br><span class="line">&lt;std_msgs::msg::String&gt;</span><br><span class="line">&lt;std_msgs::msg::UInt32&gt;</span><br></pre></td></tr></table></figure>
<p>这里的<code>std_msgs</code>是ROS2内置的一个接口功能包. </p>
<p>查看某一个接口包下所有的接口: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface package std_msgs</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-package-std_msgs.png" alt="ros2-interface-package-std_msgs" style="zoom:67%;"></p>
<p>当然, 这些内置接口也许不能满足你的需求, 此时就可以自定义接口.</p>
<h2 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h2><p>针对ROS2的通信方式, 接口可以分为:</p>
<ul>
<li><p>话题接口</p>
<p>文件名: <code>*.msg</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int64 num</span><br></pre></td></tr></table></figure>
<p>This is your custom message that transfers a single 64-bit integer called <code>num</code>.</p>
</li>
<li><p>服务接口</p>
<p>文件名:<code>*.srv</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">int64 c</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>
<p>This is your custom service that requests three integers named <code>a</code>, <code>b</code>, and <code>c</code>, and responds with an integer called <code>sum</code>.</p>
</li>
<li><p>动作接口</p>
<p>文件名:<code>*.action</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int32 order</span><br><span class="line">---</span><br><span class="line">int32[] sequence</span><br><span class="line">---</span><br><span class="line">int32[] partial_sequence</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义话题接口"><a href="#自定义话题接口" class="headerlink" title="自定义话题接口"></a>自定义话题接口</h3><p>前情提要: 前面的KFC实例中, KFC会定时发送一条广告话题, 如果要发送图片信息怎么办? 这就需要自定义KFC专属消息接口.</p>
<h4 id="编辑-msg文件"><a href="#编辑-msg文件" class="headerlink" title="编辑.msg文件"></a>编辑.msg文件</h4><p>cd到工作空间的<code>/src</code>文件夹下, 新建接口包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br><span class="line">ros2 pkg create topic_interfaces --build-type ament_cmake</span><br></pre></td></tr></table></figure>
<p>cd进入<code>topic_interfaces</code>文件夹, 新建<code>KFC.msg</code>文件(首字母要求大写)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir msg</span><br><span class="line">touch msg/KFC.msg</span><br></pre></td></tr></table></figure>
<p>编辑<code>KFC.msg</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 原始数据类型string</span><br><span class="line">string txt</span><br><span class="line"></span><br><span class="line"># 原始数据类型 uint32</span><br><span class="line">uint32 money</span><br><span class="line"></span><br><span class="line"># 图像消息，调用sensor_msgs下的Image类型</span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure>
<h4 id="修改Cmakelist-txt"><a href="#修改Cmakelist-txt" class="headerlink" title="修改Cmakelist.txt"></a>修改Cmakelist.txt</h4><p>注意:<code>rosidl_generate_interfaces()</code>必须在 <code>ament_package()</code>前</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这两句添加依赖</span></span><br><span class="line"><span class="keyword">find_package</span>(sensor_msgs REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明msg文件所属的工程名字, 文件位置, 依赖DEPENDENCIES</span></span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/Ad.msg&quot;</span></span><br><span class="line">   DEPENDENCIES sensor_msgs</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<h4 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加如下内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>sensor_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="编译并刷新环境变量"><a href="#编译并刷新环境变量" class="headerlink" title="编译并刷新环境变量"></a>编译并刷新环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select topic_interfaces</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="使用自定义话题接口修改KFC与Customer"><a href="#使用自定义话题接口修改KFC与Customer" class="headerlink" title="使用自定义话题接口修改KFC与Customer"></a>使用自定义话题接口修改KFC与Customer</h4><p>上代码! 请读者自行对比区别, <code>// CHANGE</code>为修改的地方</p>
<p>新建文件<code>Customer_with_interfaces.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 这个头文件是topic_interfaces接口包编译后自动生成的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;topic_interfaces/msg/kfc.hpp&quot;</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CustomerNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好,我是一个%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        sub_hamburger = <span class="keyword">this</span>-&gt;create_subscription&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::hamburger_callback, <span class="keyword">this</span>, _1)); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        sub_advertisement = <span class="keyword">this</span>-&gt;create_subscription&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::advertisement_callback, <span class="keyword">this</span>, _1)); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        hungry_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;CustomerNode::hungry_timer_callback, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        pub_money = <span class="keyword">this</span>-&gt;create_publisher&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        money.money = <span class="number">10</span>; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我饿了, 我要吃汉堡! 付款 %d 元&quot;</span>, money.money); <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    topic_interfaces::msg::KFC money; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::TimerBase::SharedPtr hungry_timer;</span><br><span class="line"></span><br><span class="line">    rclcpp::Subscription&lt;topic_interfaces::msg::KFC&gt;::SharedPtr sub_hamburger; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::Publisher&lt;topic_interfaces::msg::KFC&gt;::SharedPtr pub_money; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::Subscription&lt;topic_interfaces::msg::KFC&gt;::SharedPtr sub_advertisement; <span class="comment">// CHANGE</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hamburger_callback</span><span class="params">(<span class="keyword">const</span> topic_interfaces::msg::KFC::SharedPtr msg)</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我吃的 %s &quot;</span>, msg-&gt;txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我又饿了, 还想再吃一个! 付款 %d 元&quot;</span>, money.money); <span class="comment">// CHANGE</span></span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_callback</span><span class="params">(<span class="keyword">const</span> topic_interfaces::msg::KFC::SharedPtr msg)</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我收到了一条广告: %s &quot;</span>, msg-&gt;txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;CustomerNode&gt;(<span class="string">&quot;Customer&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建文件<code>KFC_with_interfaces.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;topic_interfaces/msg/kfc.hpp&quot;</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KFCNode</span>(std::string name) : <span class="built_in">Node</span>(name), <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我是%s的服务员.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        pub_hamburger = <span class="keyword">this</span>-&gt;create_publisher&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        pub_advertisement = <span class="keyword">this</span>-&gt;create_publisher&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>); <span class="comment">// CHANGE</span></span><br><span class="line">        </span><br><span class="line">        advertisement_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">5000</span>ms, std::<span class="built_in">bind</span>(&amp;KFCNode::advertisement_timer_callback, <span class="keyword">this</span>));</span><br><span class="line">        </span><br><span class="line">        sub_money = <span class="keyword">this</span>-&gt;create_subscription&lt;topic_interfaces::msg::KFC&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;KFCNode::money_callback, <span class="keyword">this</span>, _1)); <span class="comment">// CHANGE</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line">    rclcpp::TimerBase::SharedPtr advertisement_timer;</span><br><span class="line"></span><br><span class="line">    rclcpp::Publisher&lt;topic_interfaces::msg::KFC&gt;::SharedPtr pub_hamburger; <span class="comment">// CHANGE</span></span><br><span class="line">    </span><br><span class="line">    rclcpp::Subscription&lt;topic_interfaces::msg::KFC&gt;::SharedPtr sub_money; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    rclcpp::Publisher&lt;topic_interfaces::msg::KFC&gt;::SharedPtr pub_advertisement; <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> str_advertisement = topic_interfaces::msg::<span class="built_in">KFC</span>(); <span class="comment">// CHANGE</span></span><br><span class="line">        str_advertisement.txt = <span class="string">&quot;大鸡腿降价啦&quot;</span>; <span class="comment">// CHANGE</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;KFC发布了一个广告:%s&quot;</span>, str_advertisement.txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">        pub_advertisement-&gt;<span class="built_in">publish</span>(str_advertisement);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">money_callback</span><span class="params">(<span class="keyword">const</span> topic_interfaces::msg::KFC::SharedPtr msg)</span> <span class="comment">// CHANGE</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(msg-&gt;money == <span class="number">10</span>) <span class="comment">// CHANGE</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收款 %d 元&quot;</span>, msg-&gt;money); <span class="comment">// CHANGE</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> str_hamburger_num = topic_interfaces::msg::<span class="built_in">KFC</span>(); <span class="comment">// CHANGE</span></span><br><span class="line">            str_hamburger_num.txt = <span class="string">&quot;第&quot;</span> + std::<span class="built_in">to_string</span>(count++) + <span class="string">&quot;个汉堡&quot;</span>; <span class="comment">// CHANGE</span></span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我卖出的%s&quot;</span>, str_hamburger_num.txt.<span class="built_in">c_str</span>()); <span class="comment">// CHANGE</span></span><br><span class="line">            </span><br><span class="line">            pub_hamburger-&gt;<span class="built_in">publish</span>(str_hamburger_num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;KFCNode&gt;(<span class="string">&quot;KFC&quot;</span>);</span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改Cmakelist.txt, 添加/修改: </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(topic_interfaces REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Customer_with_interfaces_node src/Customer_with_interfaces.cpp)</span><br><span class="line">ament_target_dependencies(Customer_with_interfaces_node rclcpp topic_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(KFC_with_interfaces_node src/KFC_with_interfaces.cpp)</span><br><span class="line">ament_target_dependencies(KFC_with_interfaces_node rclcpp topic_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  Customer_node</span><br><span class="line">  KFC_node</span><br><span class="line">  Customer_with_interfaces_node</span><br><span class="line">  KFC_with_interfaces_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>修改package.xml, 添加: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>topic_interfaces<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编译并刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select customer_and_kfc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>开启两个终端, 分别运行使用自定义接口的KFC与Customer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run customer_and_kfc Customer_with_interfaces_node</span><br><span class="line">ros2 run customer_and_kfc KFC_with_interfaces_node</span><br></pre></td></tr></table></figure>
<p>成功~</p>
<h4 id="详细查看接口"><a href="#详细查看接口" class="headerlink" title="详细查看接口"></a>详细查看接口</h4><p>要想详细查看接口, 可以使用<code>ros2 interface</code>命令</p>
<ol>
<li><p>查看包下所有接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface package topic_interfaces</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-package-topic-interfaces.png" alt="ros2-interface-package-topic-interfaces" style="zoom:67%;"></p>
</li>
<li><p>查看内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show topic_interfaces/msg/Ad</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-show-topic-interfaces-msg-Ad.png" alt="ros2-interface-show-topic-interfaces-msg-Ad" style="zoom:67%;"></p>
</li>
<li><p>显示属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface proto topic_interfaces/msg/Ad</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-proto-topic-interfaces-msg-Ad.png" alt="ros2-interface-proto-topic-interfaces-msg-Ad" style="zoom:67%;"></p>
</li>
</ol>
<h3 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h3><p>自定义服务接口将在下一篇文章讲解服务时一起讲解.</p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——参数的使用</title>
    <url>/posts/7219ca14.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——参数的使用"><a href="#ROS2——参数的使用" class="headerlink" title="ROS2——参数的使用"></a>ROS2——参数的使用</h1><p>上回说到, <code>Organization</code>给每个人免费送2个汉堡, 有一天<code>Organization</code>正在营业中, 汉堡突然供不应求了, 领导决定临时改变规则, 之后的每个人只能领取一个汉堡. 但是此时节点已经在运行中, 该如何改变这个值呢? 这就需要用到参数<code>parameters</code></p>
<h2 id="参数简介"><a href="#参数简介" class="headerlink" title="参数简介"></a>参数简介</h2><p>参数是节点的配置参数值。你可以认为参数是节点配置的一部分。参数为整数，浮点数，布尔值，字符串和列表。在ROS2中，每个节点都有自己的参数。所有参数都是可动态重新配置的，并且是基于ROS2服务构建的。</p>
<p>在这个案例中, 每个人领取的汉堡数量就可以是<code>Organization</code>节点的一个参数.</p>
<p>下面, 我们将修改这段服务程序, 通过修改参数来改变人均汉堡数</p>
<h2 id="修改服务程序"><a href="#修改服务程序" class="headerlink" title="修改服务程序"></a>修改服务程序</h2><p>新建<code>Organization_with_parameter.cpp</code>文件</p>
<p>代码由<code>Organization.cpp</code>修改而来, 不同的地方均使用<code>// CHANGE:</code>标注出了, 请读者自行与上节代码进行对比.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;service_interfaces/srv/calculate.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Organization</span> :</span> <span class="keyword">public</span> rclcpp::Node </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Organization</span>() : <span class="built_in">Node</span>(<span class="string">&quot;Organization&quot;</span>), <span class="built_in">NumOfAll</span>(<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我们是热心组织, 我们只给poorer发汉堡.&quot;</span>);</span><br><span class="line">        callback_group_organization = <span class="keyword">this</span>-&gt;<span class="built_in">create_callback_group</span>(rclcpp::CallbackGroupType::MutuallyExclusive);</span><br><span class="line">        Organization_Server = <span class="keyword">this</span>-&gt;create_service&lt;service_interfaces::srv::Calculate&gt;(<span class="string">&quot;Calculate&quot;</span>,</span><br><span class="line">                                    std::<span class="built_in">bind</span>(&amp;Organization::organization_callback,<span class="keyword">this</span>,_1,_2),</span><br><span class="line">                                    rmw_qos_profile_services_default,</span><br><span class="line">                                    callback_group_organization);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// CHANGE: 声明参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;declare_parameter&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;NumOfEachPerson&quot;</span>, NumOfEachPerson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> NumOfAll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHANGE: 声明每个人分得的汉堡数, 默认为2</span></span><br><span class="line">    <span class="keyword">int</span> NumOfEachPerson = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    rclcpp::CallbackGroup::SharedPtr callback_group_organization;</span><br><span class="line">    rclcpp::Service&lt;service_interfaces::srv::Calculate&gt;::SharedPtr Organization_Server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">organization_callback</span><span class="params">(<span class="keyword">const</span> service_interfaces::srv::Calculate::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> service_interfaces::srv::Calculate::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request-&gt;status == <span class="string">&quot;Poorer&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个来自%s的请求，他家有%d个人.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>(), request-&gt;num_of_people);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CHANGE: 更新参数</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">get_parameter</span>(<span class="string">&quot;NumOfEachPerson&quot;</span>, NumOfEachPerson);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CHANGE: 计算应给汉堡数量，由参数给定</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> NumOfRequired = request-&gt;num_of_people * NumOfEachPerson;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(NumOfRequired &gt; NumOfAll)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;当前汉堡库里只剩%d个汉堡啦! 已经不够分了, 请明日再来.&quot;</span>, NumOfRequired);</span><br><span class="line">                response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                NumOfAll -= NumOfRequired;</span><br><span class="line">                response-&gt;num_of_hamburger = NumOfRequired;</span><br><span class="line">                response-&gt;success = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;成功送出%d个汉堡~ 还剩余%d个汉堡&quot;</span>, NumOfRequired, NumOfAll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            response-&gt;num_of_hamburger = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个非法请求，这人是个%s, 不满足送汉堡资格.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;Organization&gt;();</span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h3><p>添加:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Organization_with_parameters_node src/Organization_with_parameters.cpp)</span><br><span class="line">ament_target_dependencies(Organization_with_parameters_node rclcpp service_interfaces)</span><br></pre></td></tr></table></figure>
<p>添加:<code>Organization_with_parameters_node</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  ...</span><br><span class="line">  Organization_with_parameters_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>不用修改</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>--packages-select</code>指定编译<code>customer_and_kfc</code>功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select poor_and_organization</span><br></pre></td></tr></table></figure>
<p>刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>新建一个终端窗口, 运行带参数的Organization服务端节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Organization_with_parameters_node</span><br></pre></td></tr></table></figure>
<p>再另新建一个终端, 运行Poor客户端节点</p>
<p>一开始每人领取两个汉堡, 直接运行客户端:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 5</span><br></pre></td></tr></table></figure>
<p>Organization服务端: 成功发出10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-Organization1.png" alt="Parameters-Organization1" style="zoom:67%;"></p>
<p>Poor客户端: 成功领取10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-change-Poor1.png" alt="Parameters-change-Poor1" style="zoom:67%;"></p>
<p>此时需要修改参数, 另起一个终端, 运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param <span class="built_in">set</span> /Organization NumOfEachPerson 1</span><br></pre></td></tr></table></figure>
<p>提示如下即为成功</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-change.png" alt="Parameters-change" style="zoom:67%;"></p>
<p>再次运行客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 50</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 50个人领取了50个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-change-Poor2.png" alt="Parameters-change-Poor2" style="zoom:67%;"></p>
<p>Organization服务端: 成功发出50个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-Organization2.png" alt="Parameters-Organization2" style="zoom:67%;"></p>
<p>由此可见, 参数成功被修改了, 但此时的参数不会被保留, 参数所在的节点重启后即恢复至初始值. 那如果一个节点的参数特别多, 修改完之后想将当前的参数保存下来供下次调用应该怎么操作呢? 请继续阅读.</p>
<h2 id="参数常用命令"><a href="#参数常用命令" class="headerlink" title="参数常用命令"></a>参数常用命令</h2><p>使用 <code>ros2 param</code></p>
<h3 id="查看参数列表"><a href="#查看参数列表" class="headerlink" title="查看参数列表"></a>查看参数列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param list</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-list.png" alt="Parameters-ros2-param-list" style="zoom:67%;"></p>
<p>也可具体到某个节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param list /Organization</span><br></pre></td></tr></table></figure>
<h3 id="查看参数描述"><a href="#查看参数描述" class="headerlink" title="查看参数描述"></a>查看参数描述</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param describe /Organization NumOfEachPerson</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-describe-Organization-NumOfEachPerson.png" alt="Parameters-ros2-param-describe-Organization-NumOfEachPerson" style="zoom:67%;"></p>
<h3 id="获取参数值"><a href="#获取参数值" class="headerlink" title="获取参数值"></a>获取参数值</h3><p><code>ros2 param get &lt;node_name&gt; &lt;parameter_name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param get /Organization NumOfEachPerson</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-get-Organization-NumOfEachPerson-2.png" alt="Parameters-ros2-param-get-Organization-NumOfEachPerson-2" style="zoom:67%;"></p>
<h3 id="设置参数值"><a href="#设置参数值" class="headerlink" title="设置参数值"></a>设置参数值</h3><p><code>ros2 param set &lt;node_name&gt; &lt;parameter_name&gt; &lt;value&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param <span class="built_in">set</span> /Organization NumOfEachPerson 1</span><br></pre></td></tr></table></figure>
<p>再次获取参数值, 发生了改变:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-get-Organization-NumOfEachPerson-1.png" alt="Parameters-ros2-param-get-Organization-NumOfEachPerson-1" style="zoom:67%;"></p>
<h3 id="保存参数"><a href="#保存参数" class="headerlink" title="保存参数"></a>保存参数</h3><p><code>ros2 param dump &lt;node_name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param dump /Organization</span><br></pre></td></tr></table></figure>
<p>在当前终端的根目录下, 可以看到增加了一个<code>Organization.yaml</code>文件, 打开此文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/Organization:</span></span><br><span class="line">  <span class="attr">ros__parameters:</span></span><br><span class="line">    <span class="attr">NumOfEachPerson:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">use_sim_time:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>有了这个参数文件, 就可以通过这个文件设置节点的参数</p>
<h3 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h3><h4 id="节点启动后加载参数"><a href="#节点启动后加载参数" class="headerlink" title="节点启动后加载参数"></a>节点启动后加载参数</h4><p><code>ros2 param load &lt;node_name&gt; &lt;parameter_file&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 param load /Organization ./Organization.yaml</span><br></pre></td></tr></table></figure>
<p>返回如下表示加载成功:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Parameters-ros2-param-load-Organization-Organization-yaml.png" alt="Parameters-ros2-param-load-Organization-Organization-yaml" style="zoom:67%;"></p>
<h4 id="节点启动前加载参数"><a href="#节点启动前加载参数" class="headerlink" title="节点启动前加载参数"></a>节点启动前加载参数</h4><p><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt; --ros-args --params-file &lt;file_name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Organization_with_parameters_node --ros-args --params-file ./Organization.yaml </span><br></pre></td></tr></table></figure>
<p>请读者尝试自行获取一下当前的<code>NumOfEachPerson</code>值作为练习.</p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——手把手编写一个服务</title>
    <url>/posts/fa9bc3ba.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——手把手教你编写一个服务"><a href="#ROS2——手把手教你编写一个服务" class="headerlink" title="ROS2——手把手教你编写一个服务"></a>ROS2——手把手教你编写一个服务</h1><h2 id="服务简介"><a href="#服务简介" class="headerlink" title="服务简介"></a>服务简介</h2><p>上一篇文章讲的话题通信是基于订阅/发布机制的，无论有没有订阅者，发布者都会周期发布数据，这种模式适合持续数据的收发，比如传感器数据。机器人系统中还有另外一些配置性质的数据，并不需要周期处理，此时就要用到另外一种ROS通信方式——服务（Service）。服务是基于客户端/服务器模型的通信机制，服务器端只在接收到客户端请求时才会提供反馈数据。  </p>
<p>服务有着以下特点:</p>
<ul>
<li><p>同一个服务（名称相同）有且只能有一个节点来提供</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Service-SingleServiceClient.gif" alt="Service-SingleServiceClient" style="zoom:67%;"></p>
</li>
<li><p>同一个服务可以被多个客户端调用(可以一对一也可一对多)</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Service-MultipleServiceClient.gif" alt="Service-MultipleServiceClient" style="zoom:67%;"></p>
</li>
</ul>
<p>下面, 我们将从一个实例出发, 手把手写一段服务程序</p>
<h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>来看一个案例: (以下均使用<code>-er</code>表示名词, 虽然没有这个词)</p>
<ul>
<li>有一些穷人<code>Poorer</code>和一个发放免费汉堡的爱心机构<code>Organization</code>.</li>
<li><code>Organization</code>总共有一定数量的汉堡. </li>
<li><code>Poorer</code>可以为家人代领汉堡, 家里有n个人, 就可以领取2n个汉堡.</li>
<li>当然, 还有一些有钱人<code>Richer</code>想蹭吃蹭喝, <code>Organization</code>不会给这些人发放食物</li>
<li>当汉堡发完了, <code>Organization</code>发出通知, 不再发放.</li>
</ul>
<p>以上案例实际上就实现了一个服务, <code>Organization</code>为服务端,  <code>Poorer</code>和<code>Richer</code>为客户端</p>
<h2 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h2><p>上一篇文章我们自定义了话题接口, 服务与话题不同, 服务是双向的, 所以要定义来回两个数据类型</p>
<h3 id="编辑-srv文件"><a href="#编辑-srv文件" class="headerlink" title="编辑.srv文件"></a>编辑.srv文件</h3><p>cd到工作空间的<code>/src</code>文件夹下, 新建接口包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br><span class="line">ros2 pkg create service_interfaces --build-type ament_cmake </span><br></pre></td></tr></table></figure>
<p>cd进入<code>service_interfaces</code>文件夹, 新建<code>Organization.srv</code>文件(首字母要求大写)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir srv</span><br><span class="line">touch srv/Organization.srv</span><br></pre></td></tr></table></figure>
<p>编辑<code>Organization.srv</code></p>
<p>来回两个数据中间用<code>---</code>分隔开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 是穷人还是富人</span><br><span class="line">string status</span><br><span class="line"># 家里的人数</span><br><span class="line">uint32 num_of_people</span><br><span class="line">---</span><br><span class="line"># 是否发出成功</span><br><span class="line"><span class="keyword">bool</span> success</span><br><span class="line"># 发出的汉堡数量</span><br><span class="line">uint32 num_of_hamburger</span><br></pre></td></tr></table></figure>
<h3 id="修改Cmakelist-txt"><a href="#修改Cmakelist-txt" class="headerlink" title="修改Cmakelist.txt"></a>修改Cmakelist.txt</h3><p>注意:<code>rosidl_generate_interfaces()</code>必须在 <code>ament_package()</code>前</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加依赖</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明srv文件所属的工程名字, 文件位置, 依赖DEPENDENCIES</span></span><br><span class="line"><span class="keyword">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;srv/Calculate.srv&quot;</span></span><br><span class="line">  DEPENDENCIES </span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<h3 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加如下内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编译并刷新环境变量"><a href="#编译并刷新环境变量" class="headerlink" title="编译并刷新环境变量"></a>编译并刷新环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select service_interfaces</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="详细查看接口"><a href="#详细查看接口" class="headerlink" title="详细查看接口"></a>详细查看接口</h3><p>要想详细查看接口, 可以使用<code>ros2 interface</code>命令, 前面的博客已经讲过, 不再赘述</p>
<h2 id="服务程序实现"><a href="#服务程序实现" class="headerlink" title="服务程序实现"></a>服务程序实现</h2><p>下面来编写这段程序</p>
<h3 id="新建工作空间"><a href="#新建工作空间" class="headerlink" title="新建工作空间"></a>新建工作空间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br></pre></td></tr></table></figure>
<p><code>mkdir -p</code>: 递归创建目录,即使上级目录不存在,会按目录层级自动创建目录</p>
<h3 id="新建功能包"><a href="#新建功能包" class="headerlink" title="新建功能包"></a>新建功能包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create poor_and_organization --build-type ament_cmake --dependencies rclcpp service_interfaces</span><br></pre></td></tr></table></figure>
<p>使用<code>ament_cmake</code>作为编译类型, 并使用依赖<code>rclcpp</code>和前文定义的<code>service_interfaces</code>接口包</p>
<p>在<code>ros2_ws/src/poor_and_organization/src</code>下创建<code>Poor.cpp</code>和<code>Organization.cpp</code></p>
<h3 id="编写服务端节点"><a href="#编写服务端节点" class="headerlink" title="编写服务端节点"></a>编写服务端节点</h3><p>直接献出程序, 每句都有注释, 看不懂你打我</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;service_interfaces/srv/calculate.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类节点，名字叫做Organization,继承自Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Organization</span> :</span> <span class="keyword">public</span> rclcpp::Node </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化汉堡总数NumOfAll为100</span></span><br><span class="line">    <span class="built_in">Organization</span>() : <span class="built_in">Node</span>(<span class="string">&quot;Organization&quot;</span>), <span class="built_in">NumOfAll</span>(<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 热心组织的自我介绍</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我们是热心组织, 我们只给poorer发汉堡.&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化回调组, 作用为避免死锁(请自行百度ROS2死锁)</span></span><br><span class="line">        callback_group_organization = <span class="keyword">this</span>-&gt;<span class="built_in">create_callback_group</span>(rclcpp::CallbackGroupType::MutuallyExclusive);</span><br><span class="line">        <span class="comment">// 实例化发汉堡的的服务</span></span><br><span class="line">        Organization_Server = <span class="keyword">this</span>-&gt;create_service&lt;service_interfaces::srv::Calculate&gt;(<span class="string">&quot;Calculate&quot;</span>,</span><br><span class="line">                                    std::<span class="built_in">bind</span>(&amp;Organization::organization_callback,<span class="keyword">this</span>,_1,_2),</span><br><span class="line">                                    rmw_qos_profile_services_default,</span><br><span class="line">                                    callback_group_organization);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 剩余汉堡总数</span></span><br><span class="line">    <span class="keyword">size_t</span> NumOfAll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个服务回调组</span></span><br><span class="line">    rclcpp::CallbackGroup::SharedPtr callback_group_organization;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个服务端</span></span><br><span class="line">    rclcpp::Service&lt;service_interfaces::srv::Calculate&gt;::SharedPtr Organization_Server;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个回调函数，当收到要汉堡请求时调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">organization_callback</span><span class="params">(<span class="keyword">const</span> service_interfaces::srv::Calculate::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">const</span> service_interfaces::srv::Calculate::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 首先判断是不是穷人</span></span><br><span class="line">        <span class="keyword">if</span>(request-&gt;status == <span class="string">&quot;Poorer&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印Poorer家的人数</span></span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个来自%s的请求，他家有%d个人.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>(), request-&gt;num_of_people);</span><br><span class="line">            <span class="comment">// 计算应给汉堡数量，每人两个</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> NumOfRequired = request-&gt;num_of_people*<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 检查剩余汉堡够不够分</span></span><br><span class="line">            <span class="keyword">if</span>(NumOfRequired &gt; NumOfAll)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 不够分了, 返回false</span></span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;当前汉堡库里只剩%d个汉堡啦! 已经不够分了, 请明日再来.&quot;</span>, NumOfRequired);</span><br><span class="line">                response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 够分, 更新剩余汉堡数量</span></span><br><span class="line">                NumOfAll -= NumOfRequired;</span><br><span class="line">                <span class="comment">// 返回给几个汉堡</span></span><br><span class="line">                response-&gt;num_of_hamburger = NumOfRequired;</span><br><span class="line">                <span class="comment">// 成功送出, 返回true</span></span><br><span class="line">                response-&gt;success = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;成功送出%d个汉堡~ 还剩余%d个汉堡&quot;</span>, NumOfRequired, NumOfAll);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 富人不给汉堡, 同样返回false, 同时返回送出汉堡数量为0</span></span><br><span class="line">            response-&gt;success = <span class="literal">false</span>;</span><br><span class="line">            response-&gt;num_of_hamburger = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收到一个非法请求，这人是个%s, 不满足送汉堡资格.&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;Organization&gt;();</span><br><span class="line">    <span class="comment">// 把节点的执行器变成多线程执行器, 避免死锁</span></span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写客户端Poor节点"><a href="#编写客户端Poor节点" class="headerlink" title="编写客户端Poor节点"></a>编写客户端Poor节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;service_interfaces/srv/calculate.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个类节点，名字叫做Poorer,继承自Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poorer</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Poorer</span>() : <span class="built_in">Node</span>(<span class="string">&quot;Poorer&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我是一个来领汉堡的人.&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化客户端, 指明客户端的接口类型，同时指定要请求的服务的名称Calculate.</span></span><br><span class="line">        Poorer_Client = <span class="keyword">this</span>-&gt;create_client&lt;service_interfaces::srv::Calculate&gt;(<span class="string">&quot;Calculate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">take_hamburger</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;现在去领取汉堡&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造请求</span></span><br><span class="line">        <span class="keyword">auto</span> request = std::make_shared&lt;service_interfaces::srv::Calculate::Request&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待服务端上线</span></span><br><span class="line">        <span class="keyword">while</span> (!Poorer_Client-&gt;<span class="built_in">wait_for_service</span>(<span class="number">1</span>s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待时检测rclcpp的状态</span></span><br><span class="line">            <span class="keyword">if</span> (!rclcpp::<span class="built_in">ok</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 检测到Ctrl+C直接退出</span></span><br><span class="line">                <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;等待被打断, 不等了&quot;</span>);</span><br><span class="line">                rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则一直等</span></span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;等待热心组织开门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入参数格式错误的时候报错并退出程序</span></span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;输入格式错误, 格式为: 什么人 几口人. 例如: ros2 run poor_and_organization Poor_node Poorer 3&quot;</span>);</span><br><span class="line">            rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 格式正确, 获取参数, 放入request中</span></span><br><span class="line">            request-&gt;status =             argv[<span class="number">1</span>];</span><br><span class="line">            request-&gt;num_of_people = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我是%s, 我家有%d个人&quot;</span>, request-&gt;status.<span class="built_in">c_str</span>(), request-&gt;num_of_people);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送异步请求，然后等待返回，返回时调用回调函数</span></span><br><span class="line">        Poorer_Client-&gt;<span class="built_in">async_send_request</span>(request, std::<span class="built_in">bind</span>(&amp;Poorer::poorer_callback, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 创建一个客户端</span></span><br><span class="line">    rclcpp::Client&lt;service_interfaces::srv::Calculate&gt;::SharedPtr Poorer_Client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建接收到小说的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">poorer_callback</span><span class="params">(rclcpp::Client&lt;service_interfaces::srv::Calculate&gt;::SharedFuture response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 使用response的get()获取</span></span><br><span class="line">        <span class="keyword">auto</span> result = response.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 如果确实是Poorer, 则领取成功</span></span><br><span class="line">        <span class="keyword">if</span>(result-&gt;success == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;成功领取%d个汉堡&quot;</span>, result-&gt;num_of_hamburger);</span><br><span class="line">            rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是Poorer或者汉堡数量不够, 则领取失败</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;领取汉堡失败, 原因可能为: 1.你不是Poorer 2.汉堡不够了&quot;</span>);</span><br><span class="line">            rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 产生一个Poorer的节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;Poorer&gt;();</span><br><span class="line">    node-&gt;<span class="built_in">take_hamburger</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 运行节点，并检测rclcpp状态</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(service_interfaces REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Poor_node src/Poor.cpp)</span><br><span class="line">ament_target_dependencies(Poor_node rclcpp service_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(Organization_node src/Organization.cpp)</span><br><span class="line">ament_target_dependencies(Organization_node rclcpp service_interfaces)</span><br></pre></td></tr></table></figure>
<p>将编译好的文件安装到<code>install/poor_and_organization/lib/poor_and_organization</code>下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  Poor_node</span><br><span class="line">  Organization_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>同样地, 新建功能包的时候没有加<code>--dependencies rclcpp service_interfaces</code>等功能包, 则需要手动添加, 放置于<code>&lt;package&gt;</code>标签下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>service_interfaces<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可自行修改下面这些声明, 与实现功能无关, 但是最好写全</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;fanziqi@fanziqi.site&quot;</span>&gt;</span>fanziqi<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>--packages-select</code>指定编译<code>customer_and_kfc</code>功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select poor_and_organization</span><br></pre></td></tr></table></figure>
<p>刷新环境</p>
<p>前文应该已经echo了环境, 如果没有, 请添加<code>echo &quot;source /ros2_ws/install/setup.zsh&quot; &gt;&gt; ~/.bashrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>新建一个终端窗口, 运行Organization服务端节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Organization_node</span><br></pre></td></tr></table></figure>
<p>再另新建一个终端, 运行Poor客户端节点</p>
<p>第一个参数为节点名称<code>Poor_node</code>, 第二个参数为人员类型<code>Poorer</code>, 第三个参数为家里人数<code>5</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 5</span><br></pre></td></tr></table></figure>
<p>此时应该可以看见: </p>
<p>Organization服务端: 成功发出10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-1.png" alt="Organization-1" style="zoom:67%;"></p>
<p>Poor客户端: 成功领取10个汉堡</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-1.png" alt="Poor-1" style="zoom:67%;"></p>
<p>也可以手动发布客户端一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service call /Calculate service_interfaces/srv/Calculate <span class="string">&quot;&#123;num_of_people: 40, status: &#x27;Poorer&#x27;&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Poor客户端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-2.png" alt="Poor-2" style="zoom:67%;"></p>
<p>Organization服务端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-2.png" alt="Organization-2" style="zoom:67%;"></p>
<p>此时如果再申请20个汉堡, 会发生什么呢?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 10</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 提示领取失败</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-3.png" alt="Poor-3" style="zoom:67%;"></p>
<p>Organization服务端: 提示不够分了</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-3.png" alt="Organization-3" style="zoom:67%;"></p>
<p>这时候有一个Richer来骗汉堡吃</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Richer 1</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 提示领取失败</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-4.png" alt="Poor-4" style="zoom:67%;"></p>
<p>Organization服务端: 就算有汉堡也不分给Richer</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Organization-4.png" alt="Organization-4" style="zoom:67%;"></p>
<p>这时, Organization关门下班了(Ctrl+C关闭Organization_Node节点)</p>
<p>又来了一个人想要领汉堡:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run poor_and_organization Poor_node Poorer 2</span><br></pre></td></tr></table></figure>
<p>Poor客户端: 提示等待开门, 不想等待的话直接按Ctrl+C退出</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Poor-5.png" alt="Poor-5" style="zoom:67%;"></p>
<p>经验证, 需求全部实现~</p>
<h2 id="服务常用命令"><a href="#服务常用命令" class="headerlink" title="服务常用命令"></a>服务常用命令</h2><p>使用 <code>ros2 service</code></p>
<h3 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service list</span><br></pre></td></tr></table></figure>
<p>具体点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service list -t</span><br></pre></td></tr></table></figure>
<h3 id="查看服务的接口"><a href="#查看服务的接口" class="headerlink" title="查看服务的接口"></a>查看服务的接口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service <span class="built_in">type</span> &lt;service_name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="查看接口的服务"><a href="#查看接口的服务" class="headerlink" title="查看接口的服务"></a>查看接口的服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service find &lt;type_name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="查看服务接口类型"><a href="#查看服务接口类型" class="headerlink" title="查看服务接口类型"></a>查看服务接口类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show ***/srv/***</span><br></pre></td></tr></table></figure>
<h3 id="手动调用服务"><a href="#手动调用服务" class="headerlink" title="手动调用服务"></a>手动调用服务</h3><p>前文使用过, 还记得吗</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 service call &lt;service_name&gt; &lt;service_type&gt; &lt;arguments&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2——手把手编写一个话题</title>
    <url>/posts/7d4be8c5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——手把手教你编写一个话题"><a href="#ROS2——手把手教你编写一个话题" class="headerlink" title="ROS2——手把手教你编写一个话题"></a>ROS2——手把手教你编写一个话题</h1><h2 id="话题简介"><a href="#话题简介" class="headerlink" title="话题简介"></a>话题简介</h2><p>ROS2将复杂的机器人系统拆解成许多模块节点，而这些节点之间则是通过一个至关重要的通道完成数据交换的，这个通道就是“话题”。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-1-1.gif" alt="ros2-topic-1-1" style="zoom: 67%;"></p>
<p>一个节点可以通过多个话题向外发布数据，也可以同时订阅多个其他节点发布的话题，相当于话题是一个多对多的订阅/发布模型。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-n-n.gif" alt="ros2-topic-n-n" style="zoom: 67%;"></p>
<p>可见，话题是节点之间实现数据传输的重要途径，也是机器人各个子系统之间交换数据的重要方式。 </p>
<p>下面, 我们将从一个实例出发, 手把手写一段话题程序</p>
<h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>来看一个案例: </p>
<ul>
<li>有一家<code>KFC</code>和一个饥肠辘辘的<code>Customer</code>.</li>
<li><code>Customer</code>给<code>KFC</code>10元钱就能买到一个汉堡, 这个<code>Customer</code>饿得很快, 每秒都要吃一个汉堡. </li>
<li><code>KFC</code>收到<code>Customer</code>发来的10元钱, 向<code>Customer</code>发送汉堡, 为了推销大鸡腿, 每5秒发布一条广告.</li>
</ul>
<p>以上案例实际上就实现了一个话题, <code>KFC</code>和<code>Customer</code>是两个节点<code>Node</code>, 付钱/发送汉堡/发送广告即为发布者, 收钱/接收汉堡/收取广告即为订阅者.</p>
<p>下面来编写这段程序</p>
<h2 id="新建工作空间"><a href="#新建工作空间" class="headerlink" title="新建工作空间"></a>新建工作空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> ros2_ws/src</span><br></pre></td></tr></table></figure>
<p><code>mkdir -p</code>: 递归创建目录,即使上级目录不存在,会按目录层级自动创建目录</p>
<h2 id="新建功能包"><a href="#新建功能包" class="headerlink" title="新建功能包"></a>新建功能包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create customer_and_kfc --build-type ament_cmake --dependencies rclcpp std_msgs</span><br></pre></td></tr></table></figure>
<p>使用<code>ament_cmake</code>作为编译类型, 并使用依赖<code>rclcpp</code>和<code>std_msgs</code></p>
<p>在<code>ros2_ws/src/customer_and_kfc/src</code>下创建<code>KFC.cpp</code>和<code>Customer.cpp</code></p>
<h2 id="编写KFC节点"><a href="#编写KFC节点" class="headerlink" title="编写KFC节点"></a>编写KFC节点</h2><p>直接献出程序, 每句都有注释, 看不懂你打我</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rclcpp库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 基本消息类型库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/u_int32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样在下文可以使用1000ms这种表示方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占位符,下面会详细说</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类节点，起名叫做KFCNode,继承自Node,这样就能使用Node所有的功能了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数,第一个参数为节点名称, 并初始化count为1</span></span><br><span class="line">    <span class="built_in">KFCNode</span>(std::string name) : <span class="built_in">Node</span>(name), <span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印KFC的自我介绍</span></span><br><span class="line">      	<span class="comment">// c_str()函数是string类的一个函数，作用是把string类型转化为char类型(%s要求是一个字符串)</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好, 我是%s的服务员.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建发布者, 发布hamburger, 发布的消息类型为&lt;std_msgs::msg::String&gt;</span></span><br><span class="line">      	<span class="comment">// 格式: 发布者名字 = this-&gt;create_publisher&lt;要发布的话题类型&gt;(&quot;要发布的话题名称&quot;, 通信Qos);</span></span><br><span class="line">        pub_hamburger = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::String&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建发布者, 发布advertisement</span></span><br><span class="line">        pub_advertisement = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::String&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建定时器,每5000ms发布一个广告</span></span><br><span class="line">      	<span class="comment">// 格式: 定时器名字 = his-&gt;create_wall_timer(1000ms, std::bind(&amp;定时器回调函数, this));</span></span><br><span class="line">        advertisement_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">5000</span>ms, std::<span class="built_in">bind</span>(&amp;KFCNode::advertisement_timer_callback, <span class="keyword">this</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建订阅者,订阅money</span></span><br><span class="line">      	<span class="comment">// 格式: 订阅者名字 = this-&gt;create_subscription&lt;要订阅的话题类型&gt;(&quot;要订阅的话题名称&quot;, 通信Qos, std::bind(&amp;订阅者回调函数, this, _1));</span></span><br><span class="line">      	<span class="comment">// std::bind()是干啥的呢? 举个例子: </span></span><br><span class="line">      	<span class="comment">// 		auto f = std::bind(fun, placeholders::_2, placeholders::_1, 80);</span></span><br><span class="line">      	<span class="comment">// 		f(60,70) 等效于 fun(70, 60, 80) </span></span><br><span class="line">      	<span class="comment">// 还记得前文提到的占位符吗,placeholders::_1 就是f(60,70) 中的那个参数&quot;1&quot;</span></span><br><span class="line">        sub_money = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;KFCNode::money_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义一个汉堡售出计数器</span></span><br><span class="line">  	<span class="comment">// 在32位系统中size_t是4字节的，在64位系统中，size_t是8字节的，这样利用该类型可以增加程序移植性。</span></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个定时器</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr advertisement_timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个发布者,用于发布汉堡</span></span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_hamburger;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明一个订阅者,用于收钱</span></span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::UInt32&gt;::SharedPtr sub_money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个发布者,用于发布广告</span></span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_advertisement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广告定时器回调函数(无参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义一个String类型的字符串, 其中字符串存在.data中, %s使用时别忘了使用.c_str()转换为char类型.</span></span><br><span class="line">        <span class="keyword">auto</span> str_advertisement = std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">        str_advertisement.data = <span class="string">&quot;大鸡腿降价啦&quot;</span>;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;KFC发布了一个广告:%s&quot;</span>, str_advertisement.data.<span class="built_in">c_str</span>());</span><br><span class="line">        pub_advertisement-&gt;<span class="built_in">publish</span>(str_advertisement);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收钱订阅者回调函数(有参数, 参数类型跟上面订阅者订阅的参数类型相同, 注意要加上::SharedPtr, 因为传进来的是一个指针)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">money_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::UInt32::SharedPtr msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果收到了十元钱,才发布汉堡. 订阅的信息在msg-&gt;data中</span></span><br><span class="line">        <span class="keyword">if</span>(msg-&gt;data == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;收款 %d 元&quot;</span>, msg-&gt;data);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 字符串流</span></span><br><span class="line">            <span class="keyword">auto</span> str_hamburger_num = std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">            str_hamburger_num.data = <span class="string">&quot;第&quot;</span> + std::<span class="built_in">to_string</span>(count++) + <span class="string">&quot;个汉堡&quot;</span>;</span><br><span class="line">            <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我卖出的%s&quot;</span>, str_hamburger_num.data.<span class="built_in">c_str</span>());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发布字符串流</span></span><br><span class="line">          	<span class="comment">// 发布就这么写 &quot;发布器-&gt;publish(要发布的);&quot;, 简单吧</span></span><br><span class="line">            pub_hamburger-&gt;<span class="built_in">publish</span>(str_hamburger_num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化rclcpp</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 产生一个KFC的节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;KFCNode&gt;(<span class="string">&quot;KFC&quot;</span>);</span><br><span class="line">  	<span class="comment">// spin函数: 一旦进入spin函数，相当于它在自己的函数里面死循环了。只要回调函数队列里面有callback函数在，它就会马上去执行callback函数。如果没有的话，它就会阻塞，不会占用CPU。注意不要再spin后面放其他东西, 他们都不会执行的</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">  	<span class="comment">// 检测退出信号(ctrl+c)</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="编写Customer节点"><a href="#编写Customer节点" class="headerlink" title="编写Customer节点"></a>编写Customer节点</h2><p>此段程序与上面相同的语句不再解释, 请读者自行类比</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/msg/u_int32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就能使用1000ms这种表示方式</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占位符</span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类节点，名字叫做CustomerNode,继承自Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNode</span> :</span> <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数,第一个参数为节点名称</span></span><br><span class="line">    <span class="built_in">CustomerNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印Customer的自我介绍</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好,我是一个%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建订阅者,订阅hamburger</span></span><br><span class="line">        <span class="comment">// 占位符还记得吗? 复习一下, 此处的_1 表示const std_msgs::msg::String::SharedPtr msg</span></span><br><span class="line">        sub_hamburger = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;hamburger&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::hamburger_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建订阅者,订阅advertisement</span></span><br><span class="line">        sub_advertisement = <span class="keyword">this</span>-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;advertisement&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;CustomerNode::advertisement_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建定时器,每1000ms饿一次</span></span><br><span class="line">        hungry_timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;CustomerNode::hungry_timer_callback, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建发布者,发布money</span></span><br><span class="line">        pub_money = <span class="keyword">this</span>-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;money_of_hamburger&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给money赋值</span></span><br><span class="line">        money.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次给钱</span></span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我饿了, 我要吃汉堡! 付款 %d 元&quot;</span>, money.data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 新建一张钱</span></span><br><span class="line">    std_msgs::msg::UInt32 money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个定时器</span></span><br><span class="line">    rclcpp::TimerBase::SharedPtr hungry_timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个订阅者,用于订阅发出的汉堡</span></span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_hamburger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个发布者,用于给KFC钱</span></span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::UInt32&gt;::SharedPtr pub_money;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个订阅者,用于订阅广告</span></span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_advertisement;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 汉堡订阅者回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hamburger_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::String::SharedPtr msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;这是我吃的 %s &quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饥饿定时器回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hungry_timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我又饿了, 还想再吃一个! 付款 %d 元&quot;</span>, money.data);</span><br><span class="line">        pub_money-&gt;<span class="built_in">publish</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广告订阅者回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">advertisement_callback</span><span class="params">(<span class="keyword">const</span> std_msgs::msg::String::SharedPtr msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;我收到了一条广告: %s &quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化rclcpp</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">//产生一个Customer的节点</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::make_shared&lt;CustomerNode&gt;(<span class="string">&quot;Customer&quot;</span>);</span><br><span class="line">    <span class="comment">//运行节点，并检测退出信号</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Cmakelist-txt"><a href="#Cmakelist-txt" class="headerlink" title="Cmakelist.txt"></a>Cmakelist.txt</h2><p>如果新建功能包的时候没有加<code>--dependencies rclcpp std_msgs</code>等功能包, 则需要手动添加: (任意位置均可)</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(std_msgs REQUIRED)</span><br></pre></td></tr></table></figure>
<p>下面两对代码的作用是: </p>
<p><code>add_executable()</code> 让编译器编译<code>Customer.cpp</code>和<code>KFC.cpp</code>这两个文件. 并生成可执行文件<code>Customer_node</code>和<code>KFC_node</code></p>
<p><code>ament_target_dependencies</code> 添加编译的依赖</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Customer_node src/Customer.cpp)</span><br><span class="line">ament_target_dependencies(Customer_node rclcpp std_msgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(KFC_node src/KFC.cpp)</span><br><span class="line">ament_target_dependencies(KFC_node rclcpp std_msgs)</span><br></pre></td></tr></table></figure>
<p>将编译好的文件安装到<code>install/customer_and_kfc/lib/customer_and_kfc</code>下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  Customer_node</span><br><span class="line">  KFC_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h2><p>同样地, 新建功能包的时候没有加<code>--dependencies rclcpp std_msgs</code>等功能包, 则需要手动添加, 放置于<code>&lt;package&gt;</code>标签下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可自行修改下面这些声明, 与实现功能无关, 但是最好写全</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;fanziqi@fanziqi.site&quot;</span>&gt;</span>fanziqi<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>--packages-select</code>指定编译<code>customer_and_kfc</code>功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select customer_and_kfc </span><br></pre></td></tr></table></figure>
<p>刷新环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /ros2_ws/install/setup.zsh&quot;</span> &gt;&gt; ~/.bashrc  </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>新建一个终端窗口, 运行Customer节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run customer_and_kfc Customer_node</span><br></pre></td></tr></table></figure>
<p>再另新建一个终端, 运行KFC节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run customer_and_kfc KFC_node</span><br></pre></td></tr></table></figure>
<p>此时应该可以看见: </p>
<p>Customer端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS2-Customer.png" alt="ROS2-Customer"></p>
<p>KFC端:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS2-KFC.png" alt="ROS2-KFC"></p>
<p>经验证, 需求全部实现~</p>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph"></a>rqt_graph</h3><p>使用<code>rqt_graph</code>这个工具可以可视化显示节点和话题的连接关系</p>
<p>另起一个终端, 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS2-rqt_graph.png" alt="ROS2-rqt_graph" style="zoom:67%;"></p>
<p>上图清晰地展示了ROS计算图的网络形态, 可以清楚地看出一个节点的输入和输出是什么.</p>
<h3 id="ros2-topic"><a href="#ros2-topic" class="headerlink" title="ros2 topic"></a>ros2 topic</h3><h4 id="查看系统中所有话题"><a href="#查看系统中所有话题" class="headerlink" title="查看系统中所有话题"></a>查看系统中所有话题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-list.png" alt="ros2-topic-list" style="zoom:67%;"></p>
<p>想具体查看每个话题传输的数据类型, 则添加<code>-t</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-list-t.png" alt="ros2-topic-list-t" style="zoom:67%;"></p>
<h4 id="输出实时话题内容"><a href="#输出实时话题内容" class="headerlink" title="输出实时话题内容"></a>输出实时话题内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /hamburger </span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-echo-hamburger.png" alt="ros2-topic-echo-hamburger" style="zoom:67%;"></p>
<h4 id="查看主题信息"><a href="#查看主题信息" class="headerlink" title="查看主题信息"></a>查看主题信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic info /hamburger</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-info-hamburger.png" alt="ros2-topic-info-hamburger" style="zoom:67%;"></p>
<h4 id="查看话题的数据类型"><a href="#查看话题的数据类型" class="headerlink" title="查看话题的数据类型"></a>查看话题的数据类型</h4><p>节点之间要想成功建立数据传输，必须发布和订阅同样数据类型的消息，发布者发布的是速度指令，订阅者想订阅位置信息可是行不通的。</p>
<p>上文用<code>ros2 topic list -t</code>查看得知, <code>/advertisement</code>的类型为<code>std_msgs/msg/String</code></p>
<p>通过如下指令查看这个数据类型的具体数据结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-interface-show.png" alt="ros2-interface-show" style="zoom:67%;"></p>
<p>可以看到, <code>std_msgs/msg/String</code>中包含了<code>string data</code></p>
<h4 id="发布一个话题消息"><a href="#发布一个话题消息" class="headerlink" title="发布一个话题消息"></a>发布一个话题消息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic pub /test_topic std_msgs/msg/String <span class="string">&#x27;data: &quot;123&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-pub-test-topic.png" alt="ros2-topic-pub-test-topic" style="zoom:67%;"></p>
<h4 id="查看某一个话题的发布频率"><a href="#查看某一个话题的发布频率" class="headerlink" title="查看某一个话题的发布频率"></a>查看某一个话题的发布频率</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic hz /hamburger</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros2-topic-hz-hamburger.png" alt="ros2-topic-hz-hamburger" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS机器人学习——ROS基础</title>
    <url>/posts/eb3a5cff.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS机器人学习——ROS基础"><a href="#ROS机器人学习——ROS基础" class="headerlink" title="ROS机器人学习——ROS基础"></a>ROS机器人学习——ROS基础</h1><h2 id="ROS系统结构"><a href="#ROS系统结构" class="headerlink" title="ROS系统结构"></a>ROS系统结构</h2><ol>
<li>节点(Node) : 软件模块</li>
<li>节点管理器(ROS Master) : 控制中心,提供参数管理</li>
<li>话题(Topic) : 异步通信机制,传输消息Message,可有多个发布者和订阅者</li>
<li>服务(Service) : 同步通信机制,传输请求/应答数据,只允许有一个节点提供指定命名的服务</li>
</ol>
<h2 id="ROS工作空间"><a href="#ROS工作空间" class="headerlink" title="ROS工作空间"></a>ROS工作空间</h2><p>工作空间(workspace)是存放工程相关文件的文件夹,包括以下四个目录空间</p>
<ul>
<li><code>src</code>:代码空间,存放源码</li>
<li><code>build</code>:编译空间,存储编译的缓存和中间文件</li>
<li><code>devel</code>:开发空间,存放编译生成的可执行文件</li>
<li><code>install</code>:安装空间,非必须</li>
</ul>
<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p>(以下使用<code>WORKSPACE</code>代表你的工作空间名)</p>
<ol>
<li><p>创建工作空间</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    mkdir -p ~/WORKSPACE/src</span><br><span class="line">    <span class="built_in">cd</span> ~/WORKSPACE/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译工作空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/WORKSPACE/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置环境变量</p>
<p> 编译完成后,会自动产生<code>build</code>和<code>devel</code>,<code>devel</code>文件夹中会产生<code>setup.*sh</code>样子的环境变量设置脚本,用<code>source</code>运行脚本,以生效工作空间中的环境变量.</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure>
<p> 但是这么设置环境变量只能在当前终端下生效,如希望在所有终端都生效,则需要在终端的配置文件中添加环境变量的设置:</p>
</li>
</ol>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /WORKSPACE/devel/setup.bash&quot;</span>&gt;&gt;~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>检查环境变量</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure>
<p> 如果打印的路径中包含当前工作空间的路径,说明环境变量设置成功.</p>
<p> <strong>TODO:添加成功的截图</strong></p>
</li>
</ol>
<h3 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h3><p>(以下使用<code>PACKAGE</code>代表创建的功能包)</p>
<p>功能包结构:</p>
<p>PACKAGE/</p>
<p>​        CmakeList.txt    -&gt; 纪录功能报的编译规则</p>
<p>​        package.xml    -&gt; 描述功能包属性的信息</p>
<p>​        ……</p>
<p><strong>功能包不能嵌套,多个功能包需平行放置于代码空间<code>src</code>中</strong></p>
<ol>
<li><p>创建功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># catkin_create_pkg命令使用方法:</span></span><br><span class="line"><span class="comment"># catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</span></span><br><span class="line"><span class="built_in">cd</span> ~/WORKSPACE/src</span><br><span class="line">catkin_create_pkg learning_communication std_msgs rospy roscpp</span><br></pre></td></tr></table></figure>
<p>创建完成后,src下会生成一个<code>learning_communication</code>文件夹,已包含<code>CmakeList.txt</code>和<code>package.xml</code></p>
</li>
<li><p>编译功能包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/WORKSPACE</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ~/WORKSPACE/devel/setup.bash</span><br></pre></td></tr></table></figure>
<p><strong>同一工作空间下不能存在同名功能包</strong></p>
<p><strong>不同工作空间下可以存在同名功能包</strong></p>
</li>
</ol>
<p>所有工作空间的路径会依次顺序记录在ROS_PACKAGE_PATH环境变量中,即新的路径会排在前面.当在不同工作空间下存在同名功能包,ROS会优先查找纪录在最前端的工作空间中有没有需要的功能包,如果不存在则继续向下查找.</p>
<p>可通过以下命令查看所有ROS的环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env | grep ros</span><br></pre></td></tr></table></figure>
<p>查找功能包存放路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rospack find PACKAGE</span><br></pre></td></tr></table></figure>
<p><strong>TODO:添加查找功能包的路径图片</strong></p>
<h2 id="ROS通信编程"><a href="#ROS通信编程" class="headerlink" title="ROS通信编程"></a>ROS通信编程</h2><h3 id="话题编程"><a href="#话题编程" class="headerlink" title="话题编程"></a>话题编程</h3><p>话题编程流程</p>
<ol>
<li>创建发布者</li>
<li>创建订阅者</li>
<li>添加编译选项</li>
<li>添加可执行程序</li>
</ol>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros-%E8%AF%9D%E9%A2%98.png" alt="截屏2021-08-25 下午7.46.04" style="zoom: 33%;"></p>
<h4 id="创建发布者Publisher"><a href="#创建发布者Publisher" class="headerlink" title="创建发布者Publisher"></a>创建发布者Publisher</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * talker.cpp</span></span><br><span class="line"><span class="comment"> * 创建一个Publisher,发布chatter话题,发布字符串&quot;Hello World&quot;,类型为string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS节点初始化,节点名称为talker</span></span><br><span class="line">  <span class="comment">// 注:节点名称必须唯一 </span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建节点句柄,方便管理节电资源的使用和管理</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个Publisher，发布名为chatter的topic，消息类型为std_msgs::String</span></span><br><span class="line">  <span class="comment">// 1000为消息发布队列大小,当发布消息实际速度较慢时,Publisher会将消息存储在一定空间的队列中,当消息数量超过队列大小时,ROS会自动删除队列中最早入队的消息</span></span><br><span class="line">  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置循环的频率,单位为Hz</span></span><br><span class="line">  <span class="comment">// 当调用Rate::sleep()时,ROS节点会根据此处设置的频率休眠响应的时间,以保证维持一致的时间周期.</span></span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 发生异常,ros::ok()返回false,跳出循环</span></span><br><span class="line">  <span class="comment">// 异常包括 1.Ctrl+C/2.被另外同名节点踢掉线/3.节点调用了关闭函数ros::shutdown()/4.所有ros::NodeHandles句柄被销毁</span></span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 初始化std_msgs::String类型的消息msg,msg只有一个成员data</span></span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;hello world &quot;</span> &lt;&lt; count;</span><br><span class="line">    <span class="comment">/*这一句一般出现在创建ROS话题的发布者（Publisher）节点程序中，是利用c++自带的头文件sstream，来实现利用输入输出流的方式往string里写东西，并且还可以拼接string和其他类型的变量。</span></span><br><span class="line"><span class="comment">    *该语句实现了string型的数据&quot;hello world&quot;和int型变量count的拼接，形成一个新的string。即如果count是１，那么hello world1会作为string被存放在ss当中。</span></span><br><span class="line"><span class="comment">    *使用ss.str()调用这个string。最后可以用ROS_INFO输出。  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ROS_INFO类似于printf/cout,用来打印日志信息</span></span><br><span class="line">    <span class="comment">// c_str()函数返回一个指向正规C字符串的指针常量, 内容与本string串相同. </span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    chatter_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来处理节点订阅话题的所有回调函数(目前的发布节点没有订阅信息,此函数非必须,但为了保证不出错所以所有节点都默认加入该函数)</span></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 目前为止,Publisher一个周期的工作完成了,让他休息一段时间,100ms后开始下一周期的工作</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建订阅者Subscriber"><a href="#创建订阅者Subscriber" class="headerlink" title="创建订阅者Subscriber"></a>创建订阅者Subscriber</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * listener.cpp</span></span><br><span class="line"><span class="comment"> * 创建一个Subscriber,订阅chatter话题，消息类型String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 订阅节点需要声明订阅信息,该信息会在ROS Master中注册,Master会关注系统中是否存在发布该话题的节点,若存在则会帮助两个节点建立连接,完成数据传输</span></span><br><span class="line">  <span class="comment">// 创建一个Subscriber，订阅名为chatter的topic，注册回调函数chatterCallback</span></span><br><span class="line">  ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>, chatterCallback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环等待回调函数,此函数在ros::ok()返回false时退出</span></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译功能包"><a href="#编译功能包" class="headerlink" title="编译功能包"></a>编译功能包</h4><p>设置编译规则<code>CmakeList.txt</code></p>
<ol>
<li><p>设置头文件路径</p>
<p> <code>include_directories(头文件相对路径)</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Specify additional locations of header files</span></span><br><span class="line"><span class="comment">## Your package locations should be listed before other locations </span></span><br><span class="line">include_directories(</span><br><span class="line">  include</span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置需要编译的代码和可生成的可执行文件 </p>
<p><code>add_executable(生成的可执行文件 参与编译的源码文件1 参与编译的源码文件2)</code></p>
</li>
<li><p>配置链接的第三方库文件</p>
<p><code>target_link_libraries(生成的可执行文件 链接的库1 链接的库2)</code></p>
</li>
<li><p>若生成的可执行文件需要依赖其他文件生成的代码,如消息类型,则需设置依赖</p>
<p><code>add_dependencies(生成的可执行文件 $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Declare a C++ executable</span></span><br><span class="line"><span class="comment">## With catkin_make all packages are built within a single CMake context</span></span><br><span class="line"><span class="comment">## The recommended prefix ensures that target names across packages don&#x27;t collide</span></span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">target_link_libraries(talker <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="comment">#add_dependencies(talker $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span></span><br><span class="line"></span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line">target_link_libraries(listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="comment">#add_dependencies(listener $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在工作空间路径下编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/WORKSPACE</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure>
<p>系统会生成<code>talker</code>和<code>listener</code>两个可执行文件,位于<code>~/WORKSPACE/devel/lib/PACKAGE</code>路径下</p>
<h4 id="运行功能包"><a href="#运行功能包" class="headerlink" title="运行功能包"></a>运行功能包</h4><p>每次编译之后都需要设置环境变量,假定已将环境变量脚本添加到终端配置文件中,运行以下代码刷新环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<ol>
<li><p>启动<code>roscore</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>Publisher</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication talker</span><br></pre></td></tr></table></figure>
<p><strong>(TODO:添加运行截图)</strong></p>
</li>
<li><p>启动<code>Subscriber</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication listener</span><br></pre></td></tr></table></figure>
<p><strong>(TODO:添加运行截图)</strong></p>
<p>若先运行<code>Subscriber</code>,节点会处于等待状态直到<code>Publisher</code>启动</p>
</li>
</ol>
<p>至此,已经完成了话题通信.</p>
<h4 id="自定义话题消息"><a href="#自定义话题消息" class="headerlink" title="自定义话题消息"></a>自定义话题消息</h4><p>以上,<code>chatter</code>话题的消息类型为ROS预定的<code>String</code>,在ROS元功能包<code>common_msgs</code>中提供了许多不同消息类型,几乎满足一般需求.但有些情况下需要针对自己的机器人设计特定的消息类型</p>
<p>.msg文件是ROS中定义消息类型的文件,放置在功能包根目录下的msg文件夹中</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br></pre></td></tr></table></figure>
<p>还可以定义常量,在发布或订阅消息数据时可直接使用,相当于宏定义.如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 unknown = 0</span><br><span class="line">uint8 male    = 1</span><br><span class="line">uint8 female  = 2</span><br></pre></td></tr></table></figure>
<p>很多消息定义中还会包含一个标准格式的头信息<code>std_msgs/Header</code>,此处定义消息类型较为简单,也可以不加头信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint32 seq</span><br><span class="line">time stamp</span><br><span class="line">string frame_id</span><br></pre></td></tr></table></figure>
<p><code>seq</code>为消息顺序标识无,无需手动设置,<code>Publisher</code>发布消息时会自动累加;</p>
<p><code>stamp</code>为消息中与数据相关联的时间戳,可用于时间同步</p>
<p><code>frame_id</code>为消息中与数据相关联的参考坐标系id</p>
<p>为了使用这个自定义的消息类型,需要编译msg文件</p>
<ol>
<li><p>在<code>package.xml</code>中添加以下功能包依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>CmakeList.txt</code></p>
<ol>
<li><p><code>find_package</code>中添加消息声称依赖的功能包<code>message_generation</code></p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">	geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>catkin</code>依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">	......</span><br><span class="line">  CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs message_runtime</span><br><span class="line">	......</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置需要编译的msg文件</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">	FILES</span><br><span class="line">	Person.msg</span><br><span class="line">)</span><br><span class="line">generate_messages(</span><br><span class="line">	DEPENDENCIES</span><br><span class="line">	std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在根目录下<code>catkin_make</code>编译,使用如下命令查看自定义的Person消息类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosmsg show person</span><br></pre></td></tr></table></figure>
<p><strong>(TODO:添加运行截图)</strong></p>
<p>即可在代码中使用,参考<code>String</code>类型使用方法</p>
</li>
</ol>
<h3 id="服务编程"><a href="#服务编程" class="headerlink" title="服务编程"></a>服务编程</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros-%E6%9C%8D%E5%8A%A1.png" alt="ros-服务" style="zoom: 33%;"></p>
<p>下面以加法运算为例,<code>Client</code>发布两个需要相加的<code>int</code>变量,<code>Server</code>节点接收请求后完成运算并返回结果</p>
<h4 id="自定义服务数据"><a href="#自定义服务数据" class="headerlink" title="自定义服务数据"></a>自定义服务数据</h4><p>通过<code>.srv</code>文件进行接口定义,放置于功能包根目录下的<code>srv</code>文件夹中.</p>
<p>该文件包含请求与应答两个数据域,中间用—-分割,内容格式与自定义话题相同</p>
<p>以加法运算为例,创建<code>AddTwoInts.srv</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>
<p>与话题一样,需要在<code>package.xml</code>和<code>CMakeList.txt</code>中配置依赖和编译规则</p>
<ol>
<li><p><code>package.xml</code>添加以下依赖(与话题相同)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CMakeList.txt</code>添加以下配置</p>
<ol>
<li><p><code>find_package</code>中添加消息声称依赖的功能包<code>message_generation</code>(与话题相同)</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line"> geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置需要编译的srv文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_service_files(</span><br><span class="line">	FILES</span><br><span class="line">	AddTwoInts.srv</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="创建服务器Server"><a href="#创建服务器Server" class="headerlink" title="创建服务器Server"></a>创建服务器Server</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * server.cpp</span></span><br><span class="line"><span class="comment"> * AddTwoInts Server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="comment">// 使用ROS中的服务,必须包含服务数据类型的头文件,这个头文件是前文AddTwoInts.srv自动生成的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_communication/AddTwoInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(learning_communication::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         learning_communication::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 将输入参数中的请求数据相加，结果放到应答变量中,反馈到Client,回调函数返回true</span></span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;request: x=%ld, y=%ld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)req.a, (<span class="keyword">long</span> <span class="keyword">int</span>)req.b);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)res.sum);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS节点初始化</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_two_ints_server&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个名为add_two_ints的server，注册回调函数add()</span></span><br><span class="line">  ros::ServiceServer service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;add_two_ints&quot;</span>, add);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 循环等待回调函数</span></span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见,Server类似于话题中的Subscriber</p>
<h4 id="创建客户端Client"><a href="#创建客户端Client" class="headerlink" title="创建客户端Client"></a>创建客户端Client</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * client.cpp</span></span><br><span class="line"><span class="comment"> * AddTwoInts Client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;learning_communication/AddTwoInts.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ROS节点初始化</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_two_ints_client&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从终端命令行获取两个加数</span></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;usage: add_two_ints_client X Y&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建节点句柄</span></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个add_two_int的Client实例，服务类型是learning_communication::AddTwoInts</span></span><br><span class="line">  ros::ServiceClient client = n.serviceClient&lt;learning_communication::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化一个服务数据类型的变量,包含两个成员:request和response</span></span><br><span class="line">  <span class="comment">// 创建learning_communication::AddTwoInts类型的service消息</span></span><br><span class="line">  learning_communication::AddTwoInts srv;</span><br><span class="line">  srv.request.a = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  srv.request.b = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布service请求，等待加法运算的应答结果</span></span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(srv))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sum: %ld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)srv.response.sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service add_two_ints&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见,Client类似于话题中的Publisher</p>
<h4 id="编译功能包-1"><a href="#编译功能包-1" class="headerlink" title="编译功能包"></a>编译功能包</h4><p>设置编译规则<code>CmakeList.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(server src/server.cpp)</span><br><span class="line">target_link_libraries(server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line">add_dependencies(server <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br><span class="line">add_executable(client src/client.cpp)</span><br><span class="line">target_link_libraries(client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line">add_dependencies(client <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br></pre></td></tr></table></figure>
<p>catkin_make编译,刷新环境变量</p>
<h4 id="运行功能包-1"><a href="#运行功能包-1" class="headerlink" title="运行功能包"></a>运行功能包</h4><ol>
<li><p>启动<code>roscore</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>启动<code>Server</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​        <strong>(TODO:添加运行截图)</strong></p>
<ol>
<li><p>启动<code>Client</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun learning_communication client 3 5</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​        <strong>(TODO:添加运行截图)</strong></p>
<h2 id="分布式多机通信"><a href="#分布式多机通信" class="headerlink" title="分布式多机通信"></a>分布式多机通信</h2><p><strong>(TODO:待添加)</strong></p>
<h2 id="ROS常用组件"><a href="#ROS常用组件" class="headerlink" title="ROS常用组件"></a>ROS常用组件</h2><h3 id="launch启动文件"><a href="#launch启动文件" class="headerlink" title="launch启动文件"></a>launch启动文件</h3><p>每当我们需要运行一个ROS节点或工具时，都需要打开一个新的终端运行一个命令。当系统中的节点数量不断增加时，每个节点一个终端的模式会变得非常麻烦。启动文件（Launch File）便是ROS中一种同时启动多个节点的途径，还可以自动启动ROSMaster节点管理器，而且可以实现每个节点的各种配置，为多个节点的操作提供了很大便利。</p>
<p>下面是一个最简单的launch文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><ol>
<li><p><code>&lt;launch&gt;</code></p>
<p> XML文件必须要包含一个根元素，launch文件中的根元素采用<code>&lt;launch&gt;</code>标签定义，文件中的其他内容都必须包含在这个标签之中：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;node&gt;</code></p>
<p> 启动文件的核心是启动ROS节点，采用<code>&lt;node&gt;</code>标签定义，语法如下：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package-name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;executable-name&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 从上边的定义规则可以看出，在启动文件中启动一个节点需要三个属性：name、pkg和type。</p>
<ul>
<li><p><code>name</code> : 节点运行的名称，将覆盖节点中<code>ros::init()</code>定义的节点名称；</p>
</li>
<li><p><code>pkg</code> : 节点所在的功能包名称</p>
</li>
<li><p><code>type</code> : 节点的可执行文件名称</p>
<p>在某些情况下，我们还有可能用到以下属性：</p>
<p>| 属性                 | 属性作用                                                     |<br>| :—————————- | —————————————————————————————— |<br>| <code>output=&quot;screen&quot;</code>    | 终端输出转储在当前的控制台上，而不是在日志文件中             |<br>| <code>respawn=&quot;true&quot;</code>     | 当roslaunch启动完所有该启动的节点之后，会监测每一个节点，保证它们正常的运行状态。对于任意节点，当它终止时，roslaunch 会将该节点重启 |<br>| <code>required=&quot;true&quot;</code>    | 当被此属性标记的节点终止时，roslaunch会将其他的节点一并终止。注意此属性不可以与<code>respawn=&quot;true&quot;</code>一起描述同一个节点 |<br>| <code>ns = &quot;NAME_SPACE&quot;</code>  | 这个属性可以让你在自定义的命名空间里运行节点                 |<br>| <code>args = &quot;arguments&quot;</code> | 节点需要的输入参数                                           |</p>
</li>
</ul>
</li>
</ol>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><ol>
<li><p><code>&lt;param&gt;</code></p>
<p> parameter是ROS系统运行中的参数，存储在参数服务器中。在launch文件中可以通过<code>&lt;param&gt;</code>元素加载parameter。launch文件执行后，parameter就加载到ROS的参数服务器上了。</p>
<p> 每个活跃的节点都可以通过 ros::param::get()接口来获取parameter的值，用户也可以在终端中通过rosparam命令获得parameter的值。</p>
<p> <code>&lt;param&gt;</code>使用方法:</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 运行launch文件后，output_frame这个parameter的值就设置为odom，并且加载到ROS参数服务器上了。但是在很多复杂的系统中，参数的数量很多，如果这样一个一个的设置会非常麻烦，ROS也为我们提供了另外一种类似的参数加载方式:<code>&lt;rosparam&gt;</code></p>
<p> <code>&lt;rosparam&gt;</code>使用方法</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find 2dnav_pr2)/config/costmap_common_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;local_costmap&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>&lt;rosparam&gt;</code>可以帮助我们将一个yaml格式文件中的参数全部加载到ROS参数服务器中，需要设置command属性为“load”，还可以选择设置命名空间“ns”。</p>
</li>
<li><p><code>&lt;arg&gt;</code></p>
<p> argument是launch文件内部的局部变量,仅限于launch文件内部使用,便于launch文件的重构,与ROS节点内部无关</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;MyArg&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 像上面这样，就简单地声明了一个参数，名叫demo，但是声明不等于定义，我们需要给他赋值，在赋值之后参数才能够发挥作用。</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;MyArg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;MyArg2&quot;</span> <span class="attr">default</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 以上是两种简单的赋值方法，两者的区别是使用后者赋值的参数可以在命令行中像下面这样被修改，前者则不行。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch xxx xxx.launch MyArg2=1234</span><br></pre></td></tr></table></figure>
<p> launch文件中需要使用到argument时，可以使用如下方式调用：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;arg-name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg arg-name)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;type &quot;</span><span class="attr">args</span>=<span class="string">&quot;$(arg arg-name)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> 当<code>$(arg arg_name)</code>出现在launch文件任意位置时，将会自动替代为所给参数的值。</p>
</li>
</ol>
<h4 id="重映射机制"><a href="#重映射机制" class="headerlink" title="重映射机制"></a>重映射机制</h4><p>ROS的设计目标是提高代码的复用率，所以ROS社区中的很多功能包我们都可以拿来直接使用，而不需要关注功能包的内部实现。那么问题就来了，别人功能包的接口不一定和我们的系统兼容呀？</p>
<p>ROS提供一种重映射的机制，简单来说就是取别名，类似于C++中的别名机制，我们不需要修改别人功能包的接口，只需要将接口名称重映射一下，取个别名，我们的系统就认识了（接口的数据类型必须相同）。launch文件中的<code>&lt;remap&gt;</code>标签顾名思义重映射，emap标签里包含一个<code>original-name</code>和一个<code>new-name</code>，及原名称和新名称。</p>
<p>比如turtlebot的键盘控制节点，发布的速度控制指令话题可能是<code>/turtlebot/cmd_vel</code>，但是我们自己的机器人订阅的速度控制话题是<code>/cmd_vel</code>，这个时候使用<code>&lt;remap&gt;</code>就可以轻松解决问题，将<code>/turtlebot/cmd_vel</code>重映射为<code>/cmd_vel</code>，我们的机器人就可以接收到速度控制指令了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>重映射机制在ROS中的使用非常广泛，也非常重要，方法不止这一种，也可以在终端rosrun命令中实现重映射.</p>
<h4 id="嵌套复用"><a href="#嵌套复用" class="headerlink" title="嵌套复用"></a>嵌套复用</h4><p>在复杂的系统当中，launch文件往往有很多，这些launch文件之间也会存在依赖关系。如果需要直接复用一个已有launch文件中的内容，可以使用<code>&lt;include&gt;</code>标签包含其他launch文件，这和C语言中的include几乎是一样的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>launch是ROS框架中非常实用、灵活的功能，它类似于一种高级编程语言，可以帮助我们管理启动系统时的方方面面。在使用ROS的过程中，很多情况下我们并不需要编写大量代码，仅需要使用已有的功能包，编辑一下launch文件，就可以完成很多机器人功能。</p>
<ul>
<li><p>注 : 使用 <code>roslaunch</code> 命令 和 使用 <code>rosrun</code> 命令 单独运行每个节点之间的重要区别</p>
<p>默认情况下，roslaunch 命令 从启动节点开始，标准输出信息会重定向到一个日志文件中，而不会像 rosrun 命令那样，将 log 信息显示在终端(console)上。日志文件所在路径： <code>∼/.ros/log/run_id/node_name-number-stdout.log</code>.如果想将标准输出信息显示在终端(console)上,需要在 node 元素中使用 output 属性：output=”screen”.但node 元素的 output 属性只能影响这个节点自己。除了 output 属性，我们可以使用 roslaunch命令行工具的 –screen 命令行选项强制性的在终端的窗口中显示所有节点的输出信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roslaunch --screen package-name launch-file-name</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="TF坐标变换"><a href="#TF坐标变换" class="headerlink" title="TF坐标变换"></a>TF坐标变换</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ROS-ABTF%E5%8F%98%E6%8D%A2.png" alt="ROS-ABTF变换" style="zoom: 33%;"></p>
<p>如图所示A,B两个坐标系,A坐标系下的位姿可以通过平移和旋转变换成B坐标系下的位姿,这里的平移和旋转可以用一个4*4的变换矩阵来描述(详见机器人学)</p>
<h4 id="创建TF广播器"><a href="#创建TF广播器" class="headerlink" title="创建TF广播器"></a>创建TF广播器</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * turtle_tf_broadcaster.cpp</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poseCallback</span><span class="params">(<span class="keyword">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// tf广播器</span></span><br><span class="line">    <span class="keyword">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据乌龟当前的位姿，设置相对于世界坐标系的坐标变换</span></span><br><span class="line">    tf::Transform transform;</span><br><span class="line">    transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">    tf::Quaternion q;</span><br><span class="line">    q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">    transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布坐标变换</span></span><br><span class="line">    br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅乌龟的pose信息</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line">    ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建TF监听器"><a href="#创建TF监听器" class="headerlink" title="创建TF监听器"></a>创建TF监听器</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * turtle_tf_listener.cpp</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过服务调用，产生第二只乌龟turtle2</span></span><br><span class="line">    ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;spawn&quot;</span>);</span><br><span class="line">    ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(<span class="string">&quot;spawn&quot;</span>);</span><br><span class="line">    turtlesim::Spawn srv;</span><br><span class="line">    add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义turtle2的速度控制发布器</span></span><br><span class="line">    ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tf监听器</span></span><br><span class="line">    tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tf::StampedTransform transform;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查找turtle2与turtle1的坐标变换</span></span><br><span class="line">            listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">            listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">            ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据turtle1和turtle2之间的坐标变换，计算turtle2需要运动的线速度和角速度</span></span><br><span class="line">        <span class="comment">// 并发布速度控制指令，使turtle2向turtle1移动</span></span><br><span class="line">        geometry_msgs::Twist vel_msg;</span><br><span class="line">        vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">                                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">        vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">                                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">        turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译功能包-2"><a href="#编译功能包-2" class="headerlink" title="编译功能包"></a>编译功能包</h4><p>设置编译规则<code>CmakeList.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)</span><br><span class="line">target_link_libraries(turtle_tf_broadcaster <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"></span><br><span class="line">add_executable(turtle_tf_listener src/turtle_tf_listener.cpp)</span><br><span class="line">target_link_libraries(turtle_tf_listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>catkin_make编译,刷新环境变量</p>
<h4 id="launch文件启动"><a href="#launch文件启动" class="headerlink" title="launch文件启动"></a>launch文件启动</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 海龟仿真器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 键盘控制 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;teleop&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 两只海龟的tf广播 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;/turtle1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_tf_broadcaster&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster&quot;</span> <span class="attr">args</span>=<span class="string">&quot;/turtle2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;turtle2_tf_broadcaster&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 监听tf广播，并且控制turtle2移动 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_listener&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS机器人学习——机器人建模与仿真</title>
    <url>/posts/7859c9f3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS机器人学习——TF坐标变换</title>
    <url>/posts/5b37128a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS机器人学习——TF坐标变换"><a href="#ROS机器人学习——TF坐标变换" class="headerlink" title="ROS机器人学习——TF坐标变换"></a>ROS机器人学习——TF坐标变换</h1><h2 id="什么是TF"><a href="#什么是TF" class="headerlink" title="什么是TF"></a>什么是TF</h2><p><a href="http://wiki.ros.org/tf">tf-wiki</a></p>
<blockquote>
<p>tf is a package that lets the user keep track of multiple coordinate frames over time. tf maintains the relationship between coordinate frames in a tree structure buffered in time, and lets the user transform points, vectors, etc between any two coordinate frames at any desired point in time.</p>
</blockquote>
<p>将多个坐标系联系起来,使用tf树定义不同坐标系之间的平移与旋转变换关系，并且持续追踪多个坐标系内的变化情况。</p>
<h2 id="为什么需要坐标变换"><a href="#为什么需要坐标变换" class="headerlink" title="为什么需要坐标变换?"></a>为什么需要坐标变换?</h2><p>在ROS中定义了许多坐标系，有机器人坐标系(base_link)，有雷达坐标系(base_laser)，地图坐标系(map)，里程计坐标系(odom)等。以机器人中心为原点的坐标系，称为base_link坐标系，以激光雷达中心为原点的坐标系，称为base_laser坐标系。以下图机器人与激光雷达为例</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ros-tf-1.png" alt="ros-tf-1"></p>
<p>机器人在运行过程中，激光雷达可以采集到周围障碍物的数据，这些数据是以激光雷达为原点(base_laser参考系)下的测量值。如果我们想使用这些数据帮助机器人完成避障功能，由于激光雷达并不在机器人的中心(base_link)之上，会始终存在一个雷达与机器人中心的偏差值。这个时候，如果我们采用一种坐标变换，将激光数据从base_laser参考系变换到base_link参考下，问题就解决了。所以我们需要定义这两个坐标系之间的变换关系,也就是<strong>TF坐标变换</strong></p>
<h2 id="TF变换实例"><a href="#TF变换实例" class="headerlink" title="TF变换实例"></a>TF变换实例</h2><p>在 <a href="https://www.fanziqi.site/posts/b6e9d4e.html">麦克纳姆轮运动学解算</a> 一文中,我提到了ROS的坐标系统与单位制,这里不再累述,请读者自行阅读</p>
<p>以机器人四轮与地面的接触面为X-Y平面，四轮轴心连线的点做垂线，与x-y平面的交点为base_link坐标系原点，车头朝向方向为X轴，正左方向为Y轴，向上为Z轴。如图所示:</p>
<p><strong>TODO:添加图片</strong></p>
<p>以思岚激光雷达为例，我们一般在安装时都习惯将雷达不带线的一端朝车头方向，雷达USB端的朝车尾方向,如图所示:</p>
<p><strong>TODO:添加图片</strong></p>
<p>雷达正中心为坐标原点，USB端的方向为X轴正方向，正左方向为Y轴，向上为Z轴。</p>
<p>测量雷达中心相对机器人坐标原点(0,0,0)的距离，得到雷达在机器人坐标系中(x:0.1,y:0.0,z:0.2)。前面我们提到，思岚雷达的X轴正方向与机器人的X轴正方向为相反方向，雷达坐标系需要绕Z轴顺时针旋转180度才能与机器人base_link坐标系重合 ，旋转(yaw:3.14,roll:0,pitch:0)。</p>
<p>根据这些数据，当我们获取激光数据后，采用(x: 0.1m, y: 0.0m, z: 0.2m, yaw:3.14, roll:0, pitch:0)的坐标变换，就可以将数据从base_laser参考系变换到base_link参考系，这就定义出了两个参考系之间的变换关系。</p>
<p>为了定义和存储base_link和base_laser两个参考系之间的关系，我们需要将他们添加到tf树中。从树的概念上来讲，tf树中的每个节点都对应一个参考系，而节点之间的边对应于参考系之间的变换关系。tf就是使用这样的树结构，保证每两个参考系之间只有一种遍历方式，而且所有变换关系，都是母节点到子节点的变换。</p>
<p>为了定义参考系，我们需要定义两个节点，一个对应于base_link参考系，一个对应于base_laser参考系。为了创建两个节点之间的边，我们首先需要决定哪一个节点作为母节点，哪一个节点作为子节点，这一点在tf树中是非常重要的。这里我们选择base_link作为母节点，这样会方便后边为机器人添加更多的传感器作为子节点.</p>
<h2 id="发布TF变换"><a href="#发布TF变换" class="headerlink" title="发布TF变换"></a>发布TF变换</h2><p>我们最常使用的是tf包中的static_transform_publisher，它即可在命令行直接运行，也可写在launch文件中配置坐标转换关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;node pkg=<span class="string">&quot;tf&quot;</span> type=<span class="string">&quot;static_transform_publisher&quot;</span> name=<span class="string">&quot;base_link_to_laser&quot;</span> args=<span class="string">&quot;0.065 0.0 0.245 1.57 0.0 0.0 /base_link /lidar 50&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>pkg：包名，tf</li>
<li>type：类型，static_transform_publisher</li>
<li>name：名称，自定，便于理解</li>
<li>arg：tf参数， x y z yaw pitch roll frame_id child_frame_id period_in_ms<ul>
<li>x y z 分别代表着相应轴的平移，单位是 米。</li>
<li>yaw pitch roll 分别代表着绕z y x 三个轴的转动，单位是 弧度。</li>
<li>frame_id 为坐标系变换中的父坐标系， child_frame_id为坐标系变换中的子坐标系。(传感器的frame_id的名称根据厂商或有不同，一般在驱动启动launch可查看，思岚激光雷达的frame_id为/lidar)</li>
<li>period_in_ms 为发布频率，单位为 毫秒。通常取100。一毫秒为一秒的千分之一，100毫秒即为0.1秒，也就是10Hz。</li>
</ul>
</li>
</ul>
<h2 id="TF常用工具"><a href="#TF常用工具" class="headerlink" title="TF常用工具"></a>TF常用工具</h2><ul>
<li><p>tf_monitor 打印tf树中所有参考系信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf_monitor &lt;source_frame&gt; &lt;target_frame&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tf_echo 查看指定作消息之间的变换关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tf_echo &lt;source_frame&gt; &lt;target_frame&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static_transform_publisher 发布两个参考系之间的的静态坐标关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static_transform_publisher x y z yaw pitch roll frame id child frame id period</span><br></pre></td></tr></table></figure>
</li>
<li><p>view_frame 可视化的调试工具,可以生成pdf文件显示tf树信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun tf view_frames</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/autolabor/article/details/86492895">https://blog.csdn.net/autolabor/article/details/86492895</a></p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>RT-Thread配置SPI-Flash(W25Q256)</title>
    <url>/posts/358fc8e8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RT-Thread配置SPI-Flash-W25Q256"><a href="#RT-Thread配置SPI-Flash-W25Q256" class="headerlink" title="RT-Thread配置SPI-Flash(W25Q256)"></a>RT-Thread配置SPI-Flash(W25Q256)</h1><h3 id="1-开启SPI总线"><a href="#1-开启SPI总线" class="headerlink" title="1.开启SPI总线"></a>1.开启SPI总线</h3><p>新建一个空白的RT-Thread项目，本文基于STM32F103芯片。<br>首先在drivers目录下打开board.h文件，找到SPI对应部分。根据指导，一步一步做下去。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204143331118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-1打开SPI及SFUD"><a href="#1-1打开SPI及SFUD" class="headerlink" title="1.1打开SPI及SFUD"></a>1.1打开SPI及SFUD</h4><p>打开RT-Thread Settings,点击更多配置来到组件一栏，勾选如下。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204144847310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-2打开SPI宏定义"><a href="#1-2打开SPI宏定义" class="headerlink" title="1.2打开SPI宏定义"></a>1.2打开SPI宏定义</h4><p>board.h文件中，打开SPI宏定义。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204145854510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-3产生初始化函数"><a href="#1-3产生初始化函数" class="headerlink" title="1.3产生初始化函数"></a>1.3产生初始化函数</h4><p>使用stm32cubemx产生初始化函数，将其粘贴于board.c文件末尾。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204152938102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>然后选择芯片型号-&gt;填写项目名称，双击IOC文件后如图操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204153731512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>复制初始化函数到<code>board.c</code>文件。<img src="https://img-blog.csdnimg.cn/20201204154654140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-4打开SPI驱动"><a href="#1-4打开SPI驱动" class="headerlink" title="1.4打开SPI驱动"></a>1.4打开SPI驱动</h4><p>在drivers目录下的stm32f1xx_hal_conf.h文件中打开SPI驱动。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204160217954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>配置完成，编译下载,使用list_device指令查看设备，可以看到SPI总线已经存在了。</p>
<p><img src="https://img-blog.csdnimg.cn/2020120416192982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-挂载片外flash"><a href="#2-挂载片外flash" class="headerlink" title="2.挂载片外flash"></a>2.挂载片外flash</h3><p>接下来，我们将片外flash(W25Q256)挂到SPI总线上。</p>
<p>在application目录下，新增flash.c文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rt_hw_spi_flash_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处为片选引脚</span></span><br><span class="line">    rt_hw_spi_device_attach(W25Q_SPI_BUS_NAME, W25Q_SPI_DEVICE_NAME, GPIOA, GPIO_PIN_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//flash名称要正确</span></span><br><span class="line">    <span class="keyword">if</span> (RT_NULL == rt_sfud_flash_probe(<span class="string">&quot;W25Q256&quot;</span>, W25Q_SPI_DEVICE_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -RT_ERROR;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出到自动初始化 */</span></span><br><span class="line">INIT_COMPONENT_EXPORT(rt_hw_spi_flash_init);</span><br></pre></td></tr></table></figure>
<p>经过验证，flash已经挂载成功.</p>
<p><img src="https://img-blog.csdnimg.cn/20201204164850870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>下面开始搭建FAL。</p>
<h3 id="3-搭建FAL抽象层"><a href="#3-搭建FAL抽象层" class="headerlink" title="3.搭建FAL抽象层"></a>3.搭建FAL抽象层</h3><p>FAL是RT-Thread的一个软件包，主要是用于Flash 抽象层的实现，负责管理 Flash 设备和 Flash 分区。关于FAL的详细功能，大家可以参考RT-Thread软件包友情链接。文档非常详细，这里也参考了文档中的内容。</p>
<h4 id="3-1添加FAL"><a href="#3-1添加FAL" class="headerlink" title="3.1添加FAL"></a>3.1添加FAL</h4><p>打开RT-Thread Settings点击立即添加，然后搜索FAL。</p>
<p><img src="https://img-blog.csdnimg.cn/20201206161335974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201206161344745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020120616140293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201209201814662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-2配置FAL"><a href="#3-2配置FAL" class="headerlink" title="3.2配置FAL"></a>3.2配置FAL</h4><p>因为我们只用到了片外flash，所以可以将fal_cfg.h中关于片外flash的部分删除，并且定义自己的分区表。</p>
<p>将<code>samples-&gt;porting-&gt;fal_cfg.h</code>复制到<code>inc</code>中并修改为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _FAL_CFG_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _FAL_CFG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rtconfig.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;board.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOR_FLASH_DEV_NAME             <span class="meta-string">&quot;W25Q256&quot;</span>    <span class="comment">/*一定要改为自己的flash名称*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================== Flash device Configuration ========================= */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">fal_flash_dev</span> <span class="title">nor_flash0</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* flash device table(定义设备表，删掉了片上flash) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAL_FLASH_DEV_TABLE                                          \</span></span><br><span class="line"><span class="meta">&#123;                                                                    \</span></span><br><span class="line"><span class="meta">    &amp;nor_flash0,                                                     \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">/* ====================== Partition Configuration ========================== */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FAL_PART_HAS_TABLE_CFG</span></span><br><span class="line"><span class="comment">/* partition table ps：可根据需要自行分区*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAL_PART_TABLE                                                               \</span></span><br><span class="line"><span class="meta">&#123;                                                                                   \</span></span><br><span class="line"><span class="meta">    &#123;FAL_PART_MAGIC_WORD, <span class="meta-string">&quot;easyflash&quot;</span>, NOR_FLASH_DEV_NAME,         0, 1024*1024, 0&#125;, \</span></span><br><span class="line"><span class="meta">    &#123;FAL_PART_MAGIC_WORD,  <span class="meta-string">&quot;download&quot;</span>, NOR_FLASH_DEV_NAME, 1024*1024, 1024*1024, 0&#125;, \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* FAL_PART_HAS_TABLE_CFG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _FAL_CFG_H_ */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此处暂时并未做太大改动,可以根据需要自行分区、命名。</p>
<h4 id="3-3初始化FAL"><a href="#3-3初始化FAL" class="headerlink" title="3.3初始化FAL"></a>3.3初始化FAL</h4><p>在<code>main.c</code>文件中，包含<code>fal.h</code>并调用<code>fal_init()</code>初始化程序。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204174654126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-4验证"><a href="#3-4验证" class="headerlink" title="3.4验证"></a>3.4验证</h4><p><img src="https://img-blog.csdnimg.cn/20201204175752858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L28wMDAxXzAwMDA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32CubeMX重定向printf输出至串口</title>
    <url>/posts/f00798b9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STM32CubeMX重定向printf输出至串口"><a href="#STM32CubeMX重定向printf输出至串口" class="headerlink" title="STM32CubeMX重定向printf输出至串口"></a>STM32CubeMX重定向printf输出至串口</h1><p>第一步,CubeMX配置串口(GPIO配置略)</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113161902135.png" alt="image-20220113161902135"></p>
<p>第二步,包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第三步,勾选Use Microlib</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220113161451008.png" alt="image-20220113161451008"></p>
<p>第四步,重定向printf,此处需要将huart2改为上面配置的串口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart2, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;c, <span class="number">1</span>, <span class="number">1000</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时即可使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,num);</span><br></pre></td></tr></table></figure>
<p>代替</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf_len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\r\n&quot;</span>,num);</span><br><span class="line">HAL_UART_Transmit(&amp;huart2, (<span class="keyword">uint8_t</span> *)buf, buf_len, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/posts/5e339248.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><ol>
<li>最大标题：command + 1 或者：#</li>
<li>大标题：command + 2 或者：##</li>
<li>标准标题：command + 3 或者：###</li>
<li>中标题：command + 4 或者：####</li>
<li>小标题：command + 5 或者：#####</li>
<li>插入表格：command + T</li>
<li>插入代码：command + alt +c</li>
<li>行间公式 command + Alt + b</li>
<li>段落：command + 0</li>
<li>竖线 ： command + Alt +q</li>
<li>有序列表（1. 2.） ：输入数字+“.”之后输入空格 或者：command + Alt + o</li>
<li>黑点标记：command + Alt + u</li>
<li>隔离线shift + command + -</li>
<li>超链接：command + Alt + l</li>
<li>插入链接：command +k</li>
<li>下划线：command +u</li>
<li>加粗：command +b</li>
<li>搜索：command +f</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库使用串口</title>
    <url>/posts/e4966ae8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="boost库使用串口"><a href="#boost库使用串口" class="headerlink" title="boost库使用串口"></a>boost库使用串口</h1><h2 id="一、使用普通指针"><a href="#一、使用普通指针" class="headerlink" title="一、使用普通指针"></a>一、使用普通指针</h2><h3 id="1-头文件声明"><a href="#1-头文件声明" class="headerlink" title="1. 头文件声明"></a>1. 头文件声明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::system::error_code error_code_;</span><br><span class="line">boost::asio::io_service io_service_;</span><br><span class="line">boost::asio::serial_port *serial_port_;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用new分配内存"><a href="#2-使用new分配内存" class="headerlink" title="2. 使用new分配内存"></a>2. 使用new分配内存</h3><p>创建串口然后使用open开启</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">serial_port_ = <span class="keyword">new</span> boost::asio::<span class="built_in">serial_port</span>(io_service_);</span><br><span class="line">serial_port_-&gt;<span class="built_in">open</span>(port_name_, error_code_);</span><br></pre></td></tr></table></figure>
<p>或者直接开启</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">serial_port_ = <span class="keyword">new</span> boost::asio::<span class="built_in">serial_port</span>(io_service_, port_name_);</span><br></pre></td></tr></table></figure>
<h3 id="3-释放内存"><a href="#3-释放内存" class="headerlink" title="3. 释放内存"></a>3. 释放内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> serial_port_;</span><br></pre></td></tr></table></figure>
<h2 id="二、使用共享指针"><a href="#二、使用共享指针" class="headerlink" title="二、使用共享指针"></a>二、使用共享指针</h2><h3 id="1-头文件声明-1"><a href="#1-头文件声明-1" class="headerlink" title="1. 头文件声明"></a>1. 头文件声明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::system::error_code error_code_;</span><br><span class="line">boost::asio::io_service io_service_;</span><br><span class="line">std::shared_ptr&lt;boost::asio::serial_port&gt; serial_port_;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用make-shared分配内存"><a href="#2-使用make-shared分配内存" class="headerlink" title="2. 使用make_shared分配内存"></a>2. 使用make_shared分配内存</h3><p>创建串口然后使用open开启</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">serial_port_ = std::make_shared&lt;boost::asio::serial_port&gt;(io_service_);</span><br><span class="line">serial_port_-&gt;<span class="built_in">open</span>(port_name_, error_code_);</span><br></pre></td></tr></table></figure>
<p>或者直接开启</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">serial_port_ = std::make_shared&lt;boost::asio::serial_port&gt;(io_service_, port_name_);</span><br></pre></td></tr></table></figure>
<h3 id="3-释放内存-1"><a href="#3-释放内存-1" class="headerlink" title="3. 释放内存"></a>3. 释放内存</h3><p>使用智能指针不需要delete释放内存</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32库函数及缩写</title>
    <url>/posts/2ed78409.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="缩写定义"><a href="#缩写定义" class="headerlink" title="缩写定义"></a>缩写定义</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">缩写</th>
<th>外设/单元</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ADC</td>
<td>模数转换器</td>
</tr>
<tr>
<td style="text-align:left">BKP</td>
<td>备份寄存器</td>
</tr>
<tr>
<td style="text-align:left">CAN</td>
<td>控制器局域网模块</td>
</tr>
<tr>
<td style="text-align:left">DMA</td>
<td>直接内存存取控制器</td>
</tr>
<tr>
<td style="text-align:left">EXTI</td>
<td>外部中断事件控制器</td>
</tr>
<tr>
<td style="text-align:left">FLASH</td>
<td>闪存存储器</td>
</tr>
<tr>
<td style="text-align:left">GPIO</td>
<td>通用输入输出</td>
</tr>
<tr>
<td style="text-align:left">I2C</td>
<td>内部集成电路</td>
</tr>
<tr>
<td style="text-align:left">IWDG</td>
<td>独立看门狗</td>
</tr>
<tr>
<td style="text-align:left">NVIC</td>
<td>嵌套中断向量列表控制器</td>
</tr>
<tr>
<td style="text-align:left">PWR</td>
<td>电源/功耗控制</td>
</tr>
<tr>
<td style="text-align:left">RCC</td>
<td>复位与时钟控制器</td>
</tr>
<tr>
<td style="text-align:left">RTC</td>
<td>实时时钟</td>
</tr>
<tr>
<td style="text-align:left">SPI</td>
<td>串行外设接口</td>
</tr>
<tr>
<td style="text-align:left">SysTick</td>
<td>系统嘀嗒定时器</td>
</tr>
<tr>
<td style="text-align:left">TIM</td>
<td>通用定时器</td>
</tr>
<tr>
<td style="text-align:left">TIM1</td>
<td>高级控制定时器</td>
</tr>
<tr>
<td style="text-align:left">USART</td>
<td>通用同步异步接收发射端</td>
</tr>
<tr>
<td style="text-align:left">WWDG</td>
<td>窗口看门狗</td>
</tr>
</tbody>
</table>
</div>
<h2 id="固态函数库命名规则"><a href="#固态函数库命名规则" class="headerlink" title="固态函数库命名规则"></a>固态函数库命名规则</h2><p>PPP 表示任一外设缩写，例如：ADC。</p>
<p>系统、源程序文件和头文件命名都以<strong>“stm32f10x_”</strong>作为开头，例如：<strong>stm32f10x_conf.h</strong>。</p>
<p>常量仅被应用于一个文件的，定义于该文件中；被应用于多个文件的，在对应头文件中定义。所有常量都由英文字母大写书写。</p>
<p>寄存器作为常量处理。他们的命名都由英文字母大写书写。在大多数情况下，他们采用与缩写规范与本用户手册一致。</p>
<p>外设函数的命名以该外设的缩写加下划线为开头。每个单词的第一个字母都由英文字母大写书写，例如：<strong>SPI_SendData**</strong>。** 在函数名中，只允许存在一个下划线，用以分隔外设缩写和函数名的其它部分。</p>
<p>名为 <strong>PPP_Init</strong> 的函数，其功能是根据 <strong>PPP_InitTypeDef</strong> 中指定的参数，初始化外设 PPP，例如 <strong>TIM_Init</strong>. 文档和库规范</p>
<p>名为 <strong>PPP_DeInit</strong> 的函数，其功能为复位外设 PPP 的所有寄存器至缺省值，例如 <strong>TIM_DeInit</strong>. </p>
<p>名为 <strong>PPP_StructInit</strong> 的函数，其功能为通过设置 <strong>PPP_InitTypeDef</strong> 结构中的各种参数来定义外设的功能，例如：<strong>USART_StructInit</strong></p>
<p>名为 <strong>PPP_Cmd</strong> 的函数，其功能为使能或者失能外设 PPP，例如： <strong>SPI_Cmd</strong>. </p>
<p>名为 <strong>PPP_ITConfig</strong> 的函数，其功能为使能或者失能来自外设 PPP 某中断源，例如： <strong>RCC_ITConfig</strong>. </p>
<p>名为 <strong>PPP_DMAConfig</strong> 的函数，其功能为使能或者失能外设 PPP 的 DMA 接口，例如：<strong>TIM1_DMAConfig</strong>. </p>
<p>用以配置外设功能的函数，总是以字符串“Config”结尾，例如 <strong>GPIO_PinRemapConfig</strong>. </p>
<p>名为 <strong>PPP_GetFlagStatus</strong> 的函数，其功能为检查外设 PPP 某标志位被设置与否，例如：<strong>I2C_GetFlagStatus</strong>. </p>
<p>名为 <strong>PPP_ClearFlag</strong> 的函数，其功能为清除外设 PPP 标志位，例如：<strong>I2C_ClearFlag</strong>. </p>
<p>名为 <strong>PPP_GetITStatus</strong> 的函数，其功能为判断来自外设 PPP 的中断发生与否，例如：<strong>I2C_GetITStatus</strong>. </p>
<p>名 为 <strong>PPP_ClearITPendingBit</strong> 的函数，其功能为清除外设 PPP 中断待处理标志位，例如：<strong>I2C_ClearITPendingBit</strong>. </p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32学习笔记</title>
    <url>/posts/8cc52eb9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>STM32 命名规则</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/stm32-learn-1.png" alt="1"></p>
<hr>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>头文件：stm32f10x_gpio.h</p>
<p>源文件：stm32f10x_gpio.c</p>
<h3 id="重要函数："><a href="#重要函数：" class="headerlink" title="重要函数："></a>重要函数：</h3><ul>
<li><p>初始化函数：<br><code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</code></p>
<p>初始化一个或者多个IO口（同一组）的工作方式和速度。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">  	<span class="keyword">uint16_t</span> GPIO_Pin;                           <span class="comment">//指定要初始化的IO口         </span></span><br><span class="line">    GPIOSpeed_TypeDef GPIO_Speed; <span class="comment">//设置IO口输出速度</span></span><br><span class="line">    GPIOMode_TypeDef GPIO_Mode;    <span class="comment">//设置工作模式：8种中的一个</span></span><br><span class="line">	&#125;GPIO_InitTypeDef;</span><br><span class="line"></span><br><span class="line">GPIOx: GPIOA~GPIOG</span><br></pre></td></tr></table></figure>
<p>​    GPIO_Init函数初始化样例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">//LED0--&gt;PB.5 端口配置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//IO口速度为50MHz</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);	 <span class="comment">//根据设定参数初始化GPIOB.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>2个读取输入电平函数：</p>
<ul>
<li><p><code>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：读取某个GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);<span class="comment">//读取GPIOA.5的输入电平</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);</code><br>作用：读取某组GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。<br>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadInputData(GPIOA);<span class="comment">//读取GPIOA组中所有io口输入电平</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2个读取输出电平函数：</p>
<ul>
<li><p><code>uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5);<span class="comment">//读取GPIOA.5的输出电平</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);</code><br>作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_ReadOutputData(GPIOA);<span class="comment">//读取GPIOA组中所有io口输出电平</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>4个设置输出电平函数：</p>
<ul>
<li><code>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：设置某个IO口输出为高电平（1）。实际操作BSRR寄存器</li>
<li><code>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</code><br>作用：设置某个IO口输出为低电平（0）。实际操作的BRR寄存器。</li>
<li><code>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);</code></li>
<li><code>void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);</code><br> 这两个函数不常用，也是用来设置IO口输出电平。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按键输入：</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> u8 key_up=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span>(mode==<span class="number">1</span>) key_up=<span class="number">1</span>;<span class="comment">//支持连续按</span></span><br><span class="line">      <span class="keyword">if</span>（key_up &amp;&amp;  KEY按下）</span><br><span class="line">      &#123;</span><br><span class="line">        delay_ms(<span class="number">10</span>);<span class="comment">//延时，防抖</span></span><br><span class="line">        key_up=<span class="number">0</span>;<span class="comment">//标记这次key已经按下</span></span><br><span class="line">        <span class="keyword">if</span>(KEY确实按下)</span><br><span class="line">          &#123;</span><br><span class="line">           <span class="keyword">return</span> KEY_VALUE;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY没有按下)  key_up=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> 没有按下</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h2><p>头文件: stm32f10x_rcc.h</p>
<p>源文件:stm32f10x_rcc.c</p>
<ol>
<li><p>时钟使能配置:</p>
<p>  <code>RCC_LSEConfig()</code> 、<code>RCC_HSEConfig()</code>、<code>RCC_HSICmd()</code> 、 <code>RCC_LSICmd()</code> 、 <code>RCC_PLLCmd()</code> ……</p>
</li>
<li><p>时钟源相关配置：<br>   <code>RCC_PLLConfig ()</code>、 <code>RCC_SYSCLKConfig()</code> 、<code>RCC_RTCCLKConfig()</code> …</p>
</li>
<li><p>分频系数选择配置：<br>  <code>RCC_HCLKConfig()</code> 、 <code>RCC_PCLK1Config()</code> 、 <code>RCC_PCLK2Config()</code>…</p>
</li>
<li><p>外设时钟使能：<br>  <code>RCC_APB1PeriphClockCmd():</code>  //APB1线上外设时钟使能<br>  <code>RCC_APB2PeriphClockCmd();</code>  //APB2线上外设时钟使能<br>  <code>RCC_AHBPeriphClockCmd();</code>   //AHB线上外设时钟使能</p>
</li>
<li><p>其他外设时钟配置：</p>
<p> <code>RCC_ADCCLKConfig ();</code>  <code>RCC_RTCCLKConfig();</code></p>
</li>
<li><p>状态参数获取参数：<br> <code>RCC_GetClocksFreq();</code><br> <code>RCC_GetSYSCLKSource();</code><br> <code>RCC_GetFlagStatus()</code></p>
</li>
<li><p>RCC中断相关函数 :<br> <code>RCC_ITConfig()</code> 、<code>RCC_GetITStatus()</code> 、 <code>RCC_ClearITPendingBit()</code>…</p>
</li>
</ol>
<hr>
<h2 id="NVIC中断优先级分组"><a href="#NVIC中断优先级分组" class="headerlink" title="NVIC中断优先级分组"></a>NVIC中断优先级分组</h2><ul>
<li><p>中断管理方法：</p>
<p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。</p>
</li>
<li><p>抢占优先级 &amp; 响应优先级区别：</p>
<p>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。</p>
<p>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。</p>
<p>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。</p>
<p>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行；</p>
</li>
<li><p>一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。</p>
</li>
<li><p>中断优先级分组函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));</span><br><span class="line">  SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>中断参数初始化函数：</p>
<p><code>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannel; <span class="comment">//设置中断通道</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelPreemptionPriority;<span class="comment">//设置响应优先级</span></span><br><span class="line">  <span class="keyword">uint8_t</span> NVIC_IRQChannelSubPriority; <span class="comment">//设置抢占优先级</span></span><br><span class="line">  FunctionalState NVIC_IRQChannelCmd; <span class="comment">//使能/使能</span></span><br><span class="line">&#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NVIC_InitTypeDef   NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;<span class="comment">//串口1中断</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span> ;<span class="comment">// 抢占优先级为1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;<span class="comment">// 子优先级位2</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);	<span class="comment">//根据上面指定的参数初始化NVIC寄存器</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>中断优先级设置步骤：</p>
<ol>
<li>系统运行后先设置中断优先级分组。调用函数：<br>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);<br> （整个系统执行过程中，只设置一次中断分组。）</li>
<li>针对每个中断，设置对应的抢占优先级和响应优先级：<br>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);</li>
<li>如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">()</span></span>; <span class="comment">//串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Cmd</span><span class="params">()</span></span>;<span class="comment">//使能串口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">()</span></span>;<span class="comment">//使能相关中断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendData</span><span class="params">()</span></span>;<span class="comment">//发送数据到串口，DR</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">USART_ReceiveData</span><span class="params">()</span></span>;<span class="comment">//接受数据，从DR读取接受到的数据</span></span><br><span class="line"></span><br><span class="line"><span class="function">FlagStatus <span class="title">USART_GetFlagStatus</span><span class="params">()</span></span>;<span class="comment">//获取状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearFlag</span><span class="params">()</span></span>;<span class="comment">//清除状态标志位</span></span><br><span class="line"><span class="function">ITStatus <span class="title">USART_GetITStatus</span><span class="params">()</span></span>;<span class="comment">//获取中断状态标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">()</span></span>;<span class="comment">//清除中断状态标志位</span></span><br></pre></td></tr></table></figure>
<p>波特率计算方法</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/stm32-learn-2.png" alt="2"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/stm32-learn-3.png" alt="3"></p>
<p>串口配置的一般步骤</p>
<ol>
<li>串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd();</li>
<li>串口复位:USART_DeInit(); 这一步不是必须的</li>
<li>GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP</li>
<li>串口参数初始化：USART_Init();</li>
<li>开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）<pre><code>  NVIC_Init();
  USART_ITConfig();
</code></pre></li>
<li>使能串口:USART_Cmd();</li>
<li>编写中断处理函数：USARTx_IRQHandler();</li>
<li>串口数据收发：<br>void USART_SendData();//发送数据到串口，DR<br>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据</li>
<li>串口传输状态获取：<br>FlagStatus USART_GetFlagStatus(USART_TypeDef<em> USARTx, uint16_t USART_FLAG);<br>void USART_ClearITPendingBit(USART_TypeDef</em> USARTx, uint16_t USART_IT);</li>
</ol>
<hr>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><ul>
<li><p><code>void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);</code><br>   //设置IO口与中断线的映射关系</p>
<p>   例:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);</code><br> //初始化中断线：触发方式等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line;   <span class="comment">//指定要配置的中断线           </span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;   <span class="comment">//模式：事件 OR中断</span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;<span class="comment">//触发方式：上升沿/下降沿/双沿触发</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;  <span class="comment">//使能 OR失能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line2;	 </span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);	 	</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);</code><br>//判断中断线中断状态，是否发生</p>
</li>
<li><p><code>void EXTI_ClearITPendingBit(uint32_t EXTI_Line);</code><br>//清除中断线上的中断标志位</p>
</li>
<li><p>外部中断的一般配置步骤：</p>
<ol>
<li>初始化IO口为输入。<pre><code>GPIO_Init();
</code></pre></li>
<li>开启IO口复用时钟。<pre><code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
</code></pre></li>
<li>设置IO口与中断线的映射关系。<pre><code>void GPIO_EXTILineConfig();
</code></pre></li>
<li>初始化线上中断，设置触发条件等。<pre><code>   EXTI_Init();
</code></pre></li>
<li>配置中断分组（NVIC），并使能中断。<pre><code>   NVIC_Init();
</code></pre></li>
<li>编写中断服务函数。<pre><code>  EXTIx_IRQHandler();
</code></pre></li>
<li>清除中断标志位<pre><code>  EXTI_ClearITPendingBit();
</code></pre></li>
</ol>
</li>
</ul>
<hr>
<h2 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h2><ul>
<li><p>定时器参数初始化：         </p>
<p><code>void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Prescaler;        </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_CounterMode;     </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Period;        </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ClockDivision;  </span><br><span class="line">  <span class="keyword">uint8_t</span> TIM_RepetitionCounter;</span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef; </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_Period = <span class="number">4999</span>; TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">7199</span>; TIM_TimeBaseStructure.TIM_ClockDivision =   TIM_CKD_DIV1; TIM_TimeBaseStructure.TIM_CounterMode =   TIM_CounterMode_Up; </span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); </span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器使能函数：</p>
<p><code>void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)</code></p>
</li>
<li><p>定时器中断使能函数：</p>
<p><code>void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);</code></p>
</li>
<li><p>状态标志位获取和清除：</p>
<p><code>FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);</code><br><code>void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);</code><br><code>ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);</code><br><code>void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);</code></p>
</li>
<li><p>定时器中断实现步骤</p>
<ol>
<li>能定时器时钟。<pre><code>  RCC_APB1PeriphClockCmd();
</code></pre></li>
<li>初始化定时器，配置ARR,PSC。<pre><code>TIM_TimeBaseInit();
</code></pre></li>
<li>开启定时器中断，配置NVIC。<pre><code>void TIM_ITConfig();
NVIC_Init();
</code></pre></li>
<li>使能定时器。<pre><code>TIM_Cmd();
</code></pre></li>
<li>编写中断服务函数。<pre><code>TIMx_IRQHandler();
</code></pre></li>
</ol>
</li>
</ul>
<hr>
<h2 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h2><ul>
<li><p>初始化：</p>
<p><code>void TIM_OCxInit(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCMode;  <span class="comment">//PWM模式1或者模式2</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OutputState; <span class="comment">//输出使能 OR失能</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OutputNState;</span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Pulse; <span class="comment">//比较值，写CCRx</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCPolarity; <span class="comment">//比较输出极性</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCNPolarity; </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCIdleState;  </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCNIdleState; </span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//PWM模式2</span></span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">TIM_OCInitStructure. TIM_Pulse=<span class="number">100</span>;</span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性:TIM输出比较极性高</span></span><br><span class="line">TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  <span class="comment">//根据T指定的参数初始化外设TIM3 OC2</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>设置比较值函数：</p>
<p><code>void TIM_SetCompareX(TIM_TypeDef* TIMx, uint16_t Compare2);</code></p>
</li>
<li><p>使能输出比较预装载：</p>
<p><code>void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);</code></p>
</li>
<li><p>使能自动重装载的预装载寄存器允许位：</p>
<p><code>void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);</code></p>
</li>
<li><p>PWM输出配置步骤：</p>
<ol>
<li>使能定时器3和相关IO口时钟。<pre><code>使能定时器3时钟：RCC_APB1PeriphClockCmd();
使能GPIOB时钟：RCC_APB2PeriphClockCmd();
</code></pre></li>
<li>初始化IO口为复用功能输出。函数：GPIO_Init();<pre><code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;      
</code></pre></li>
<li>这里我们是要把PB5用作定时器的PWM输出引脚，所以要重映射配置，<pre><code>所以需要开启AFIO时钟。同时设置重映射。
 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);
 GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); 
</code></pre></li>
<li>初始化定时器：ARR,PSC等：TIM_TimeBaseInit();</li>
<li>初始化输出比较参数:TIM_OC2Init()</li>
<li>使能预装载寄存器： TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); </li>
<li>使能定时器。TIM_Cmd();</li>
<li>不断改变比较值CCRx，达到不同的占空比效果:TIM_SetCompare2();</li>
</ol>
</li>
</ul>
<hr>
<h2 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h2><ul>
<li><p>初始化函数：</p>
<p><code>void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Channel; <span class="comment">//捕获通道1-4   </span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICPolarity; <span class="comment">//捕获极性</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICSelection; <span class="comment">//映射关系</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICPrescaler; <span class="comment">//分频系数</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICFilter;  <span class="comment">//滤波器</span></span><br><span class="line">&#125; TIM_ICInitTypeDef;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; </span><br><span class="line">TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM5_ICInitStructure.TIM_ICFilter = <span class="number">0x00</span>;</span><br><span class="line">TIM_ICInit(TIM5, &amp;TIM5_ICInitStructure);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通道极性设置独立函数：</p>
<p><code>void TIM_OCxPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)；</code></p>
</li>
<li><p>获取通道捕获值</p>
<p><code>uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)；</code></p>
</li>
</ul>
<ul>
<li><p>输入捕获的一般配置步骤：</p>
<ol>
<li>初始化定时器和通道对应IO的时钟。</li>
<li>初始化IO口，模式为输入：GPIO_Init();<pre><code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0 输入
</code></pre></li>
<li>初始化定时器ARR，PSC<br>TIM_TimeBaseInit();</li>
<li>初始化输入捕获通道<br>TIM_ICInit();</li>
<li>如果要开启捕获中断，<pre><code>TIM_ITConfig();
NVIC_Init();
</code></pre></li>
<li>使能定时器：TIM_Cmd();</li>
<li>编写中断服务函数：TIMx_IRQHandler();</li>
</ol>
</li>
</ul>
<hr>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA，全称Direct Memory Access，即直接存储器访问。</p>
<p>DMA的出现就是为了解决批量数据的输入/输出问题。DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。这样数据的传送速度就取决于存储器和外设的工作速度。</p>
<ul>
<li><p>初始化函数：</p>
<p><code>void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);</code></p>
</li>
<li><p>2个使能函数:</p>
<ul>
<li><code>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);</code>//使能DMA通道</li>
<li><code>void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);</code>//使能DMA通道中断</li>
</ul>
</li>
<li><p>2个传输数据量函数</p>
<ul>
<li><code>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);</code>//设置DMA通道的传输数据量（DMA处于关闭状态）</li>
<li><code>uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);</code>//获取当前DMA通道传输剩余数据量（DMA处于开启状态）</li>
</ul>
</li>
<li><p>DMA的一般步骤</p>
<ul>
<li>使能DMA时钟。调用函数：<code>RCC_AHBPeriphClockCmd()</code>；</li>
<li>初始化DMA通道参数。调用函数：<code>DMA_Init()</code>；</li>
<li>使能串口DMA发送，串口DMA使能函数。调用函数：<code>USART_DMACmd()</code>；</li>
<li>使能DMA1通道，启动传输。调用函数：<code>DMA_Cmd()</code>；</li>
<li>查询DMA传输状态。调用函数：<code>DMA_GetFlagStatus()</code>；</li>
<li>获取/设置通道当前剩余数据量。调用函数：<code>DMA_GetCurrDataCounter()</code>；<code>DMA_SetCurrDataCounter()</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>32单片机缩写</title>
    <url>/posts/f382e178.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>IRQ: Interrupt Request 中断请求</p>
<p>RCC: Rest and Clock Control 复位与时钟控制</p>
<p>HAL: Hardware Abstraction Layer硬件抽象层,代表HAL库</p>
<p>DMA: Direct Memory Access 直接内存存取</p>
<p>EX: extended 延伸，扩展</p>
<p>PWR: Power Controller 电源控制</p>
<p>Conf: configuration</p>
<p>It: interrupt</p>
<p>MSP: Mixed Signal Processor混合信号处理器</p>
<p>RSSI: Received Signal Strength Indication接收的信号强度指示</p>
<p>SNR: 信噪比SIGNAL-NOISE RATIO</p>
<p>上下行同信：上行（终端-&gt;网关；上传），下行（网关-&gt;终端；接收</p>
<p>EXTI: （External interrupt/event controller）—外部中断/事件控制器</p>
<p>idel: 空闲</p>
<p>RF_CAD:The radio is doing channel activity detection</p>
<p>FSK:Frequency-shift keying频移键控，是信息传输中使用得较早的一种调制方式,它的主要优点是: 实现起来较容易,抗噪声与抗衰减的性能较好。在中低速数据传输中得到了广泛的应用。</p>
<p>PHY: Port Physical Layer，中文可称之为端口物理层，是一个对OSI模型物理层的共同简称。</p>
<p>MAC：Media Access Control 介质访问控制</p>
<p>PLL: PhaseLockedLoop锁相环</p>
<p>APB: Advanced Peripheral BUS 外围总线</p>
<p>AHB，是Advanced High performance Bus的缩写，译作高级高性能总线，这是一种“系统总线”。</p>
<p>MSP: MCU Specific Package</p>
<p>Int 初始化 deint反初始化</p>
<p>Transmit：传输；传播；发射；传达；遗传，发送</p>
<p>Init：初始化（initialization）</p>
<p>clock：时钟；计时器</p>
<p>system：制度，体制；系统；方法</p>
<p>Config：配置，布局；显示配置信息命令</p>
<p>USART：代表串口(Universal Synchronous/Asynchronous Receiver/Transmitter)通用同步/异步串行接收/发送器</p>
<p>GPIO：general purpose input/output 代表引脚， （通用输入/输出）简称为GPIO</p>
<p>SPI：SPI是串行外设接口（Serial Peripheral Interface）的缩写</p>
<p>RTC：实时时钟（Real-Time Clock）</p>
<p>ADC：ADC,Analog-to-Digital Converter的缩写,指模/数转换器或者模数转换器</p>
<p>Channel： 通道；频道；海峡</p>
<p>ARM：Advanced RISC Machine</p>
<p>AAPCS：ARM Architecture Process call standard</p>
<p>ARM 体系结构过程调用标准</p>
<p>RISC： Reduced Instruction Set Computer 精简指令集计算机</p>
<p>RTOS：Real Time Operating System 实时操作系统</p>
<p>DMA：Direct Memory Access 存储器直接访问</p>
<p>EXTI: External Interrupts 外部中断</p>
<p>FSMC: Flexible static memory controller 可变静态存储控制器</p>
<p>FPB：flash patch and breakpoint FLASH 转换及断电单元</p>
<p>HSE：Hign speed external</p>
<p>HSI: High speed internal</p>
<p>LSE: Low Speed external</p>
<p>LSI: Low Speed Internal</p>
<p>LSU: load store unit 存取单元</p>
<p>PFU: prefetch unit 预取单元</p>
<p>ISR：Interrupt Service Routines 中断服务程序</p>
<p>NMI: Nonmaskable Interrupt 不可屏蔽中断</p>
<p>NVIC: Nested Vectored Interrupt Controller 嵌套向量中断控制器</p>
<p>MPU: Memory Protection Unit 内存保护单元</p>
<p>MIPS:million instructions per second 每秒能执行的百万条指令的条数</p>
<p>RCC：Reset and clock control 复位和时钟控制</p>
<p>RTC: Real-Time Clock 实时时钟</p>
<p>IWDG: independent watchdog 独立看门狗</p>
<p>WWDG：Window watchdog 窗口看门狗</p>
<p>TIM：timer 定时器</p>
<p>GAL:generic array logic 通用阵列逻辑</p>
<p>PAL:programmable array logic 可编程阵列逻辑</p>
<p>ASIC:Application Specific Integrated Circuit 专用集成电路</p>
<p>FPGA:Field－Programmable Gate Array 现场可编程门阵列</p>
<p>CPLD:Complex Programmable Logic Device 可编程逻辑器件</p>
<p>端口</p>
<p>AFIO：alternate function IO 复用 IO 端口</p>
<p>GPIO：general purpose input/output 通用 IO 端口</p>
<p>IOP（A-G）:IO port A - IO port G (例如：IOPA:IO port A)</p>
<p>CAN：Controller area network 控制器局域网</p>
<p>FLITF：The Flash memory interface 闪存存储器接口</p>
<p>I2C： Inter-integrated circuit 微集成电路</p>
<p>IIS： integrate interface of sound 集成音频接口</p>
<p>JTAG：joint test action group 联合测试行动小组</p>
<p>SPI：Serial Peripheral Interface 串行外围设备接口 SDIO: SD I/O</p>
<p>UART: Universal Synchr./Asynch. Receiver Transmitter 通用异步接收/发送装置</p>
<p>USB: Universal Serial Bus 通用串行总线</p>
<p>寄存器相关</p>
<p>CPSP： Current Program Status Register 当前程序状态寄存器</p>
<p>SPSP： saved program status register 程序状态备份寄存器</p>
<p>CSR：clock control/status register 时钟控制状态寄存器</p>
<p>LR： link register 链接寄存器</p>
<p>SP： stack pointer 堆栈指针</p>
<p>MSP: main stack pointer 主堆栈指针</p>
<p>PSP：process stack pointer</p>
]]></content>
      <categories>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo个人博客搭建教程</title>
    <url>/posts/296a4234.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo个人博客搭建教程"><a href="#Hexo个人博客搭建教程" class="headerlink" title="Hexo个人博客搭建教程"></a>Hexo个人博客搭建教程</h1><h2 id="1-搭建前准备"><a href="#1-搭建前准备" class="headerlink" title="1 搭建前准备"></a>1 搭建前准备</h2><h3 id="1-1-环境配置"><a href="#1-1-环境配置" class="headerlink" title="1.1 环境配置"></a>1.1 环境配置</h3><p>需要安装git、node，最后安装hexo</p>
<h4 id="1-1-1-安装Git："><a href="#1-1-1-安装Git：" class="headerlink" title="1.1.1 安装Git："></a>1.1.1 安装Git：</h4><p>首先看电脑是否已经安装了git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git</span><br></pre></td></tr></table></figure>
<p>若提示not founded则进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#未安装homebrew则先安装homebrew</span></span><br><span class="line">$ /bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装git</span></span><br><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<p>查看git版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure>
<p>显示如下则安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fanziqi@macbook-pro blog % git --version</span><br><span class="line">git version 2.21.0 (Apple Git-122)</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-安装node"><a href="#1-1-2-安装node" class="headerlink" title="1.1.2 安装node"></a>1.1.2 安装node</h4><p>点击访问 <a href="http://nodejs.cn/download/">node官网</a> 下载安装</p>
<p>查看node版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure>
<h4 id="1-1-3-安装并配置Hexo"><a href="#1-1-3-安装并配置Hexo" class="headerlink" title="1.1.3 安装并配置Hexo"></a>1.1.3 安装并配置Hexo</h4><p>安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>创建blog文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此目录可以任意更改</span></span><br><span class="line">$ mkdir blog</span><br><span class="line"><span class="comment"># 进入blog文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># init初始化hexo</span></span><br><span class="line">$ hexo init</span><br><span class="line">开启本地服务</span><br><span class="line"><span class="comment"># hexo s</span></span><br></pre></td></tr></table></figure>
<p>若出现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>则在浏览器输入 <a href="http://localhost:4000">http://localhost:4000</a> 即可看到本地运行的博客首页</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-2.png" alt></p>
<h3 id="1-2-注册并创建仓库"><a href="#1-2-注册并创建仓库" class="headerlink" title="1.2 注册并创建仓库"></a>1.2 注册并创建仓库</h3><p>这里讲解两个仓库</p>
<h4 id="1-2-1-GitHub仓库"><a href="#1-2-1-GitHub仓库" class="headerlink" title="1.2.1 GitHub仓库"></a>1.2.1 GitHub仓库</h4><p>进入<a href="https://github.com/">GitHub</a>官网注册一个账号，并记住用户名，下一步要用到</p>
<p>新建一个仓库，点击new repository</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-3.png" alt></p>
<p>进入这一步，仓库名字必须是<strong>用户名.github.io</strong>，然后点击创建</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-4.png" alt></p>
<p>配置ssh key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> .ssh</span><br></pre></td></tr></table></figure>
<p>新建ssh key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;你的邮件地址&quot;</span></span><br></pre></td></tr></table></figure>
<p>出现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/fanziqi/.ssh/id_rsa): </span><br></pre></td></tr></table></figure>
<p>则输入ssh的名字，比如GitHub，然后回车</p>
<p>再连续按两次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\刚刚起的名字.pub</code>文件，打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-6.png" alt></p>
<p>粘贴到key里面，title任意，点击保存。</p>
<p>测试是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>提示 <code>Are you sure you want to continue connecting (yes/no)?</code>输入yes，提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">You’ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>则配置成功</p>
<h4 id="1-2-2-Coding仓库"><a href="#1-2-2-Coding仓库" class="headerlink" title="1.2.2 Coding仓库"></a>1.2.2 Coding仓库</h4><p>由于GitHub服务器在国外，访问速度非常慢。所以建议使用国内的Coding</p>
<p>进入<a href="https://coding.net/">coding官网</a>，点击免费注册</p>
<p>注册成功后新建一个代码托管项目，名称是用户名，并勾选readme<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-5.png" alt></p>
<p>进入代码仓库，点击左下角项目设置—项目与成员—功能开关—打开持续部署</p>
<p>进入项目—持续部署—静态网站</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-7.png" alt></p>
<p>填好名称后并保存</p>
<p>经测试，coding使用ssh公钥无法上传代码，则通过普通的输入用户名密码的方法上传。</p>
<h3 id="1-3-关联到仓库"><a href="#1-3-关联到仓库" class="headerlink" title="1.3 关联到仓库"></a>1.3 关联到仓库</h3><p>在创建的blog文件夹里找到_config.yml文件并打开，在文档最后找到</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br></pre></td></tr></table></figure>
<p>将其修改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">github:</span></span><br><span class="line">      <span class="string">git@github.com:你的GitHub账号/你的GitHub账号.github.io.git</span></span><br><span class="line">    <span class="attr">coding:</span></span><br><span class="line">      <span class="string">https://e.coding.net/你的coding账号/你的coding账号/你的coding账号.git</span></span><br><span class="line">      <span class="comment">#git@e.coding.net:fanis/fanis/fanis.git 此方法暂时不好用</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#产生静态网页</span></span><br><span class="line">$ hexo g</span><br><span class="line"><span class="comment"># 部署到GitHub/coding上</span></span><br><span class="line">$ hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可使用hexo g &amp;&amp; hexo d</span></span><br></pre></td></tr></table></figure>
<p>进入<code>http://你的名字.github.io/</code>或<code>http://coding静态网站中的一串代码.coding-pages.com/</code>即可看到hexo博客</p>
<h3 id="1-4-绑定个人域名"><a href="#1-4-绑定个人域名" class="headerlink" title="1.4 绑定个人域名"></a>1.4 绑定个人域名</h3><p>如果想使用自己购买的域名进行访问，则需要将个人域名cname解析到<code>你的名字.github.io/</code>或<code>coding静态网站中的一串代码.coding-pages.com/</code>上</p>
<h4 id="1-4-1-域名配置"><a href="#1-4-1-域名配置" class="headerlink" title="1.4.1 域名配置"></a>1.4.1 域名配置</h4><p>我的域名购买于阿里云，别的域名注册商大同小异。</p>
<p>打开域名解析页面</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-8.png" alt></p>
<p>天价一个CNAME类型的解析，解析到coding或GitHub上</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-9.png" alt></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-10.png" alt></p>
<p>然后在blog/source/文件夹下创建一个名为CNAME文件，不要后缀。写上你的域名。</p>
<p>注意⚠️国内访问GitHub很慢，如果想达到分流的效果在解析的时候GitHub解析线路选择境外，coding选择境内，即可实现国外用户访问GitHub而国内用户访问coding。</p>
<h4 id="1-4-2-GitHub设置"><a href="#1-4-2-GitHub设置" class="headerlink" title="1.4.2 GitHub设置"></a>1.4.2 GitHub设置</h4><p>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-11.png" alt></p>
<h4 id="1-4-3-coding设置"><a href="#1-4-3-coding设置" class="headerlink" title="1.4.3 coding设置"></a>1.4.3 coding设置</h4><p>进入项目，点击持续部署下的静态网站，设置之前创建的静态网站，下拉找到自定义域名，绑定自己的域名，并获取证书</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-12.png" alt></p>
<h4 id="1-4-4-配置CNAME文件"><a href="#1-4-4-配置CNAME文件" class="headerlink" title="1.4.4 配置CNAME文件"></a>1.4.4 配置CNAME文件</h4><p>在blog/source/中创建一个名为CNAME文件，不要后缀。写上你的域名。</p>
<p>最后重新生成静态网站并上传，就可以通过访问自己的域名来访问GitHub/coding上的blog了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h2 id="2-使用博客"><a href="#2-使用博客" class="headerlink" title="2 使用博客"></a>2 使用博客</h2><h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p>hexo最主要的配置是_config.yml这个文件，详细可参考<a href="https://hexo.io/zh-cn/docs/configuration">官方的配置</a>描述。这里举几个常用的例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span>  <span class="comment">#网页标题</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment">#作者名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#修改网页语言为英文</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://你的网站</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-更换主题"><a href="#2-2-更换主题" class="headerlink" title="2.2 更换主题"></a>2.2 更换主题</h3><p>默认的主题很丑，<a href="https://hexo.io/themes/">hexo官方主题页</a>这里的主题都可以更换。我选的是butterfly主题，界面美观功能强大。</p>
<h4 id="2-2-1-安装主题"><a href="#2-2-1-安装主题" class="headerlink" title="2.2.1 安装主题"></a>2.2.1 安装主题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>应用主题</p>
<p>修改站點配置文件_config.yml，把主題改為butterfly</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>
<p>安装pub渲染器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-配置主题"><a href="#2-2-2-配置主题" class="headerlink" title="2.2.2 配置主题"></a>2.2.2 配置主题</h4><p>为了主題的平滑升級, Butterfly 使用了 data files 特性。</p>
<p>推薦把主題默認的配置文件_config.yml複製到 Hexo 工作目錄下的source/_data/butterfly.yml，如果source/_data的目錄不存在那就創建一個。</p>
<p>打开source/_data/butterfly.yml</p>
<p>首先汉化导航栏，更改将第一段代码更改为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">菜单||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">音乐</span> <span class="string">||</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">电影</span> <span class="string">||</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/messageboard/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-paper-plane</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure>
<p>创建标签页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>找到source/tags/index.md这个文件，修改为</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>创建分类页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>找到source/categories/index.md这个文件，修改为</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>创建友情链接页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page link</span><br></pre></td></tr></table></figure>
<p>找到source/link/index.md这个文件，修改为</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &quot;link&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p>添加友情链接</p>
<p>在Hexo博客目錄中的source/_data，創建一個文件link.yml</p>
<p>内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">class:</span></span><br><span class="line">  <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="attr">1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ZSTU</span> <span class="comment">#这里举一个例子</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">http://www.zstu.edu.cn/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">http://www.zstu.edu.cn//avatar.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">浙江理工大学官网</span></span><br><span class="line"><span class="comment">#    2:</span></span><br><span class="line"><span class="comment">#      name: xxxxxx</span></span><br><span class="line"><span class="comment">#      link: https://www.xxxxxxcn/</span></span><br><span class="line"><span class="comment">#      avatar: https://xxxxx/avatar.png</span></span><br><span class="line"><span class="comment">#      descr: xxxxxxx</span></span><br></pre></td></tr></table></figure>
<p>注：class_name和class_desc支持html格式書寫，如不需要，也可以留空。</p>
<p>音乐页使用插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a>，电影页使用插件<a href="https://github.com/mythsman/hexo-douban">hexo-douban</a>，请自行查看网页上的使用说明，这里不再赘述。</p>
<p>404页面</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&quot;頁面沒有找到&quot;</span></span><br><span class="line">  <span class="attr">background:</span></span><br></pre></td></tr></table></figure>
<p>代码</p>
<p>代码高亮主题</p>
<p>Butterfly 支持6種代碼高亮樣式：</p>
<ul>
<li>default</li>
<li>darker</li>
<li>pale night</li>
<li>light</li>
<li>ocean</li>
<li>mac</li>
</ul>
<p>修改<code>highlight_theme: light</code>即可</p>
<p>default：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-13.png" alt="default"></p>
<p>darker：<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-14.png" alt="darker"></p>
<p>pale night：<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-15.png" alt="pale night"></p>
<p>light：<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-16.png" alt="light"></p>
<p>ocean：<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-17.png" alt="ocean"></p>
<p>mac：<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-18.png" alt="mac"></p>
<p>代码复制功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>代碼框展開/關閉</p>
<p>在默認情況下，代碼框自動展開，可設置是否所有代碼框都關閉狀態，點擊&gt;可展開代碼</p>
<ul>
<li>true 全部代碼框不展開，需點擊&gt;打開</li>
<li>false 代碼狂展開，有&gt;點擊按鈕</li>
<li>none 不顯示&gt;按鈕</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">true</span> <span class="comment">#代碼框不展開，需點擊 &#x27;&gt;&#x27; 打開</span></span><br></pre></td></tr></table></figure>
<p>社交图标</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># social settings (社交圖標設置)</span></span><br><span class="line"><span class="comment"># formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/fanziqi614</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:fzq614@qq.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure>
<p>这会展示在主页头像下面</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-19.png" alt></p>
<p>顶部图</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the banner image of home page 将路径填到这里</span></span><br><span class="line"><span class="attr">index_img:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if the banner of page not setting,it will show the top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">https://i.loli.net/2020/05/01/IuWi8QbHvzjlOPw.jpg</span></span><br></pre></td></tr></table></figure>
<p>文档封面</p>
<p>修改position即可改变封面位置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># the position of cover in home page (封面顯示的位置)</span></span><br><span class="line">  <span class="comment"># left/right/both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment"># When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)</span></span><br><span class="line">  <span class="attr">default_cover:</span> </span><br><span class="line"><span class="comment">#    - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg</span></span><br></pre></td></tr></table></figure>
<p>文章版权</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure>
<p>打赏功能</p>
<p>在文末显示</p>
<p>在/blog/themes/butterfly/source/下创建wechat.jpg和alipay.jpg收款码图片</p>
<p>然后更改butterfly代码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sponsor/reward</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/wechat.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">wechat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">alipay</span></span><br></pre></td></tr></table></figure>
<p>头像</p>
<p>在/blog/themes/butterfly/source/下创建avatar.png作为头像</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.png</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span> <span class="comment"># 頭像會一直轉圈</span></span><br></pre></td></tr></table></figure>
<p>评论系统</p>
<p>我选择的是valine评论系统，更加美观大方，易于管理。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-20.png" alt></p>
<p>进入<a href="https://leancloud.cn/，注册账号实名认证验证邮箱，创建应用">https://leancloud.cn/，注册账号实名认证验证邮箱，创建应用</a></p>
<p>在设置中记下应用keys</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-21.png" alt></p>
<p>填到下面的对应位置，并修改enable为true</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># valine</span></span><br><span class="line"><span class="comment"># https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appId:</span>  <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span>  <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span> <span class="comment"># i18n: zh-CN/zh-TW/en/ja</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Please</span> <span class="string">leave</span> <span class="string">your</span> <span class="string">footprints</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick</span> <span class="comment">#valine comment header info (nick/mail/link)</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">true</span> <span class="comment"># Record reviewer IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">emojiCDN:</span> <span class="comment"># emoji CDN</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">false</span> <span class="comment"># enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span></span><br><span class="line">  <span class="attr">requiredFields:</span> <span class="string">nick</span> <span class="comment"># required fields (nick/mail)</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># dispaly comment count in top_img</span></span><br></pre></td></tr></table></figure>
<p>注意⚠️guest_info:和requiredFields:一定要对应，否则无法发送评论。</p>
<p>侧边栏设置</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-22.png" alt></p>
<p>可自行设置应用的开关</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># 手機頁面（ 顯示寬度 &lt; 768px ）是否顯示aside內容</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">  <span class="attr">card_webinfo:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>动画效果</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Background effects (背景特效)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_ribbon (靜止彩帶背景)</span></span><br><span class="line"><span class="comment"># See: https://github.com/hustcc/ribbon.js</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">150</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">click_to_change:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dynamic ribbon (動態彩帶)</span></span><br><span class="line"><span class="attr">canvas_ribbon_piao:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_nest</span></span><br><span class="line"><span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(<span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5.</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines, default: 99.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建新博客"><a href="#2-3-创建新博客" class="headerlink" title="2.3 创建新博客"></a>2.3 创建新博客</h3><p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new post <span class="string">&quot;文件名&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个时候source下会出现一个.md文件和 同名文件夹</p>
<p>用typora等md编辑器即可编辑，图片放在同名文件夹中。</p>
<p>打开md文件，Front-matter 是檔案最上方以 —- 分隔的區域，用於指定個別檔案的變數。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments：</span></span><br><span class="line"><span class="emphasis">cover:  </span></span><br><span class="line"><span class="emphasis">toc:  </span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer：</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>参数用法：<img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/website-building-tutorial-23.png" alt></p>
<p>文章写在Front-matter下方</p>
<p>写好后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g %% hexo d</span><br></pre></td></tr></table></figure>
<p>即可在网站上看到</p>
<h2 id="3-hexo常用命令"><a href="#3-hexo常用命令" class="headerlink" title="3 hexo常用命令"></a>3 hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;我的博客&quot;</span> == hexo new <span class="string">&quot;我的博客&quot;</span> <span class="comment">#新建⽂章</span></span><br><span class="line">hexo p == hexo publish</span><br><span class="line">hexo g == hexo generate<span class="comment">#⽣成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy<span class="comment">#部署</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment">#Hexo 会监视⽂件变动并⾃动更新，您⽆须重启服务器。</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端⼝</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#⾃定义 IP</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存 ⽹⻚正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#⽣成静态⽹⻚</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br><span class="line"></span><br><span class="line">hexo generate <span class="comment">#使⽤ Hexo ⽣成静态⽂件快速⽽且简单</span></span><br><span class="line">hexo generate --watch <span class="comment">#监视⽂件变动</span></span><br><span class="line"></span><br><span class="line">两个命令的作⽤是相同的</span><br><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br><span class="line"></span><br><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建⽂章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建⻚⾯</span></span><br><span class="line">hexo generate <span class="comment">#⽣成静态⻚⾯⾄public⽬录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端⼝（默认端⼝4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy⽬录部署到GitHub</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo <span class="string">&quot;My Gallery&quot;</span></span><br><span class="line">hexo new <span class="string">&quot;Hello World&quot;</span> --lang tw</span><br></pre></td></tr></table></figure>
<p>祝建站成功～</p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你配置哔哔点啥</title>
    <url>/posts/af935eab.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手把手教你配置哔哔点啥"><a href="#手把手教你配置哔哔点啥" class="headerlink" title="手把手教你配置哔哔点啥"></a>手把手教你配置哔哔点啥</h1><p>有一些闲言碎语不知道去哪说，所以搭建了一个哔哔点啥页面</p>
<h1 id="一、服务部署"><a href="#一、服务部署" class="headerlink" title="一、服务部署"></a>一、服务部署</h1><h3 id="1-首先保证成功激活腾讯云开发"><a href="#1-首先保证成功激活腾讯云开发" class="headerlink" title="1. 首先保证成功激活腾讯云开发"></a>1. 首先保证成功激活腾讯云开发</h3><h3 id="2-点击一键部署至云开发"><a href="#2-点击一键部署至云开发" class="headerlink" title="2. 点击一键部署至云开发"></a>2. <a href="https://console.cloud.tencent.com/tcb/env/index?action=CreateAndDeployCloudBaseProject&amp;appUrl=https%3A%2F%2Fgithub.com%2Flmm214%2Fbber&amp;branch=main">点击一键部署至云开发</a></h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-1.png" alt="image-20210807160349972"></p>
<h3 id="3-进入环境-登录授权，启用“匿名登录”"><a href="#3-进入环境-登录授权，启用“匿名登录”" class="headerlink" title="3. 进入环境-登录授权，启用“匿名登录”"></a>3. 进入<a href="https://console.cloud.tencent.com/tcb/env/login">环境-登录授权</a>，启用“匿名登录”</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-2.png" alt="image-20210807160443690"></p>
<h3 id="4-进入环境-安全配置，将博客网址添加到“WEB安全域名”"><a href="#4-进入环境-安全配置，将博客网址添加到“WEB安全域名”" class="headerlink" title="4. 进入环境-安全配置，将博客网址添加到“WEB安全域名”"></a>4. 进入<a href="https://console.cloud.tencent.com/tcb/env/safety">环境-安全配置</a>，将博客网址添加到“WEB安全域名”</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-3.png" alt="image-20210807160514198"></p>
<h3 id="5-进入环境-HTTP访问服务，复制链接备用。"><a href="#5-进入环境-HTTP访问服务，复制链接备用。" class="headerlink" title="5. 进入环境-HTTP访问服务，复制链接备用。"></a>5. 进入<a href="https://console.cloud.tencent.com/tcb/env/access">环境-HTTP访问服务</a>，复制链接备用。</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-4.png" alt="image-20210807160549968"></p>
<h3 id="6-进入云函数，修改自定义serverkey-bber-并保存备用。"><a href="#6-进入云函数，修改自定义serverkey-bber-并保存备用。" class="headerlink" title="6. 进入云函数，修改自定义serverkey bber 并保存备用。"></a>6. 进入<a href="https://console.cloud.tencent.com/tcb/scf/index">云函数</a>，修改自定义serverkey <code>bber</code> 并保存备用。</h3><p>记录下这个key，后面需要用</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-5.png" alt="image-20210807160730497"></p>
<h3 id="7-扫码进入公众号，输入命名绑定"><a href="#7-扫码进入公众号，输入命名绑定" class="headerlink" title="7. 扫码进入公众号，输入命名绑定"></a>7. 扫码进入公众号，输入命名绑定</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-0.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bber 你刚刚设置的key,https://你的云函数HTTP访问地址/bber</span><br><span class="line"></span><br><span class="line">比如: /bber mykey,https://balabala.ap-shanghai.app.tcloudbase.com/bber</span><br></pre></td></tr></table></figure>
<h3 id="8-手动添加一条哔哔-必须要有"><a href="#8-手动添加一条哔哔-必须要有" class="headerlink" title="8. 手动添加一条哔哔  必须要有"></a>8. 手动添加一条哔哔  <em>必须要有</em></h3><p>进入腾讯云数据库-&gt;talks-&gt;文档列表-&gt;添加文档</p>
<p>字段: content</p>
<p>类型: string</p>
<p>值: 随便</p>
<p>点击确定</p>
<h3 id="9-验证微信发送"><a href="#9-验证微信发送" class="headerlink" title="9. 验证微信发送"></a>9. 验证微信发送</h3><p>微信发送一条文字，返回哔哔成功，talks文档列表里多出来一条，即为服务部署成功</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-6.png" alt="image-20210807161419278"></p>
<h2 id="二、前端部署"><a href="#二、前端部署" class="headerlink" title="二、前端部署"></a>二、前端部署</h2><h3 id="1-新建一个markdown文件"><a href="#1-新建一个markdown文件" class="headerlink" title="1. 新建一个markdown文件"></a>1. 新建一个<em>markdown</em>文件</h3><p>以源代码模式编辑，复制以下内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;speak-bber&#x27;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">speak</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/ispeak-bber@1.1.1-beta/ispeak-bber.min.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> &gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line">ispeakBber</span><br><span class="line"><span class="code">    .init(&#123;</span></span><br><span class="line"><span class="code">      el: &#x27;#speak-bber&#x27;,</span></span><br><span class="line"><span class="code">      name: &#x27;DreamyTZK 🦄&#x27;, // 显示的昵称</span></span><br><span class="line"><span class="code">      envId: &#x27;腾讯云开发环境id&#x27;, // 环境id</span></span><br><span class="line"><span class="code">      region: &#x27;ap-shanghai&#x27;, // 腾讯云地址，默认为上海</span></span><br><span class="line"><span class="code">      limit: 10, // 每次加载的条数，默认为5</span></span><br><span class="line"><span class="code">      avatar: &#x27;https://cdn.jsdelivr.net/npm/kang-static@latest/avatar.jpg&#x27;,</span></span><br><span class="line"><span class="code">      fromcolor:&#x27;rgb(245, 150, 170)&#x27;</span></span><br><span class="line"><span class="code">    &#125;)</span></span><br><span class="line"><span class="code">    .then(function() &#123;</span></span><br><span class="line"><span class="code">      console.log(&#x27;ispeak 加载完成&#x27;)</span></span><br><span class="line"><span class="code">    &#125;)</span></span><br><span class="line"><span class="code">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>退出源代码模式后应该看不见上面的代码</p>
<h3 id="2-重新生成hexo静态网站"><a href="#2-重新生成hexo静态网站" class="headerlink" title="2. 重新生成hexo静态网站"></a>2. 重新生成hexo静态网站</h3><p>此处不再赘述</p>
<h3 id="3-查看哔哔页面"><a href="#3-查看哔哔页面" class="headerlink" title="3.查看哔哔页面"></a>3.查看哔哔页面</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/bibi-7.png" alt="image-20210807161821445"></p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>固定Ubuntu下的端口号</title>
    <url>/posts/408ef5ae.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="固定Ubuntu下的端口号"><a href="#固定Ubuntu下的端口号" class="headerlink" title="固定Ubuntu下的端口号"></a>固定Ubuntu下的端口号</h1><p>Ubuntu下ttyUSB0和ttyUSB1经常不固定,序号取决于插入顺序,先插上的序号小</p>
<p>固定步骤如下:</p>
<ol>
<li><p>查看已插入的USB设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>
<p>找到对应的USB设备,记下该设备的设备ID,如<code>10c4:ea60</code>,如果不确定是哪个的话,就拔下usb设备运行一次<code>lsusb</code>,再插上,多出来的就是需要设置的设备.</p>
</li>
<li><p>修改<code>rules.d</code>下的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入目录</span></span><br><span class="line"><span class="built_in">cd</span> /etc/udev/rules.d</span><br><span class="line"><span class="comment">#新建.rules文件,名称任意</span></span><br><span class="line">touch usb.rules</span><br><span class="line"><span class="comment">#或直接编辑后保存</span></span><br><span class="line">sudo vi usb.rules</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开刚刚新建的文件,添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KERNEL==<span class="string">&quot;ttyUSB*&quot;</span>, ATTRS&#123;idVendor&#125;==<span class="string">&quot;10c4&quot;</span>, ATTRS&#123;idProduct&#125;==<span class="string">&quot;ea60&quot;</span>, MODE:=<span class="string">&quot;0777&quot;</span>, SYMLINK+=<span class="string">&quot;YOUR_NAME&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中,SYMLINK任意起名</p>
<p>退出vi编辑器,<code>wq</code>保存退出</p>
</li>
<li><p>重启udev</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service udev reload</span><br><span class="line">service udev restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新插拔USB设备,查看端口号绑定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l /dev |grep ttyUSB</span><br></pre></td></tr></table></figure>
<p>显示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx  1 root   root           7 Nov 29 14:03 YOUR_NAME -&gt; ttyUSB0</span><br></pre></td></tr></table></figure>
<p>打开设备时，用（/dev/YOUR_NAME）即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派4b安装Ubuntu20.04桌面版并安装ROS1-Noetic和ROS2-Foxy</title>
    <url>/posts/e9a394b1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派4b安装Ubuntu20-04桌面版并安装ROS1-Noetic和ROS2-Foxy"><a href="#树莓派4b安装Ubuntu20-04桌面版并安装ROS1-Noetic和ROS2-Foxy" class="headerlink" title="树莓派4b安装Ubuntu20.04桌面版并安装ROS1-Noetic和ROS2-Foxy"></a>树莓派4b安装Ubuntu20.04桌面版并安装ROS1-Noetic和ROS2-Foxy</h1><h2 id="1-树莓派4b安装Ubuntu20-04"><a href="#1-树莓派4b安装Ubuntu20-04" class="headerlink" title="1 树莓派4b安装Ubuntu20.04"></a>1 树莓派4b安装Ubuntu20.04</h2><h3 id="1-0-引言"><a href="#1-0-引言" class="headerlink" title="1.0 引言"></a>1.0 引言</h3><p>树莓派4b并未适配1804及2004的桌面版Ubuntu（<a href="https://ubuntu.com/download/raspberry-pi">官方镜像连接</a>），而ROS未免会需要图形界面，故有以下几种方法安装Ubuntu20.04桌面版：</p>
<ol>
<li>安装Server版本，这种方法实测无法安装GPU驱动导致界面卡顿，图形显示不正常。</li>
<li>参照国外大神给出的教程，详见：<a href="https://jamesachambers.com/raspberry-pi-4-ubuntu-20-04-usb-mass-storage-boot-guide/">Raspberry Pi 4 / 400 Ubuntu USB Mass Storage Boot Guide</a>，在他的博客里也可以找到Ubuntu1804的桌面版镜像</li>
<li>安装官方支持的<strong>Ubuntu Mate</strong>（<a href="https://ubuntu-mate.org/download/arm64/focal/">链接</a>），下文只讲这种方法。</li>
</ol>
<h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>这里需要下载几个工具：<a href="https://www.balena.io/etcher/">balenaEtcher</a>、</p>
<p>还需要准备一个SD卡，推荐使用32GB</p>
<h3 id="1-2-镜像烧录"><a href="#1-2-镜像烧录" class="headerlink" title="1.2 镜像烧录"></a>1.2 镜像烧录</h3><p>打开balenaEtcher，选择镜像，选择SD卡，点击flash即可</p>
<h3 id="1-3-开启树莓派"><a href="#1-3-开启树莓派" class="headerlink" title="1.3 开启树莓派"></a>1.3 开启树莓派</h3><p>将SD卡插到树莓派上，接上显示器，上电开机</p>
<p>按照提示一步一步操作</p>
<h3 id="1-4-换清华源"><a href="#1-4-换清华源" class="headerlink" title="1.4 换清华源"></a>1.4 换清华源</h3><p>树莓派安装的是ARM版本的Ubuntu，所以要使用 <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">ubuntu-ports 镜像</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>然后更新+升级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<p>下文讲解ROS的安装。本文只讨论二进制安装，源码安装之后单独出一篇文章讲述。</p>
<h2 id="2-安装ROS1-Noetic"><a href="#2-安装ROS1-Noetic" class="headerlink" title="2 安装ROS1-Noetic"></a>2 安装ROS1-Noetic</h2><p>Ubuntu20.04推荐版本为<a href="https://wiki.ros.org/noetic">Noetic</a>，此版本也为LTS，所以本文安装Noetic版本ROS1。</p>
<h3 id="2-1-设置sources-list"><a href="#2-1-设置sources-list" class="headerlink" title="2.1 设置sources.list"></a>2.1 设置sources.list</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-设置秘钥"><a href="#2-2-设置秘钥" class="headerlink" title="2.2 设置秘钥"></a>2.2 设置秘钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>
<p>这里会出现无法连接至密钥服务器，请科学上网。</p>
<h3 id="2-3-安装完整桌面版"><a href="#2-3-安装完整桌面版" class="headerlink" title="2.3 安装完整桌面版"></a>2.3 安装完整桌面版</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure>
<h3 id="2-4-设置环境"><a href="#2-4-设置环境" class="headerlink" title="2.4 设置环境"></a>2.4 设置环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
<p>如果成功安装则可以看到ROS版本为Noetic。</p>
<h3 id="2-6-卸载"><a href="#2-6-卸载" class="headerlink" title="2.6 卸载"></a>2.6 卸载</h3><p><strong>未测试过！！！</strong></p>
<p>如需卸载，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge ros-* &amp;&amp; sudo apt-get autoremove</span><br></pre></td></tr></table></figure>
<p>然后自行删除相关的环境变量</p>
<h2 id="3-安装ROS2-Galactic"><a href="#3-安装ROS2-Galactic" class="headerlink" title="3 安装ROS2-Galactic"></a>3 安装ROS2-Galactic</h2><p><del>ROS2目前官网推荐版本为<a href="https://docs.ros.org/en/galactic/">Galactic</a>，虽然Galactic修复了Foxy的许多bug，但是Foxy的资料比Galactic多一些，所以本文安装<a href="https://docs.ros.org/en/foxy/">Foxy</a>。</del></p>
<p><a href="https://docs.ros.org/en/foxy/">Foxy</a>正在向Galactic迁移，本文安装最新版本的<a href="https://docs.ros.org/en/galactic/">Galactic</a></p>
<h3 id="3-1-添加ROS2-apt仓库"><a href="#3-1-添加ROS2-apt仓库" class="headerlink" title="3.1 添加ROS2 apt仓库"></a>3.1 添加ROS2 apt仓库</h3><p>添加仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install curl gnupg lsb-release</span><br></pre></td></tr></table></figure>
<p>验证GPG key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg</span><br></pre></td></tr></table></figure>
<p>将仓库加入软件源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu <span class="subst">$(source /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME)</span> main&quot;</span> | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<h3 id="3-2-安装ROS2包"><a href="#3-2-安装ROS2包" class="headerlink" title="3.2 安装ROS2包"></a>3.2 安装ROS2包</h3><p>上文设置了仓库，需要更新apt缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>桌面版安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-galactic-desktop</span><br></pre></td></tr></table></figure>
<h3 id="3-3-设置环境"><a href="#3-3-设置环境" class="headerlink" title="3.3 设置环境"></a>3.3 设置环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/galactic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>此时应该报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROS_DISTRO was <span class="built_in">set</span> to ‘noetic’ before. Please make sure that the environment does not mix paths from different distributions. </span><br></pre></td></tr></table></figure>
<p>出现该警告的原因在于环境变量中同时存在ROS1、ROS2。如果要切换使用ROS1和ROS2，则应该修改环境变量。</p>
<h4 id="3-3-1-更新vim"><a href="#3-3-1-更新vim" class="headerlink" title="3.3.1 更新vim"></a>3.3.1 更新vim</h4><p>预装的vim版本过旧，先更新一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>使用vi打开环境变量文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>滚动到最后，在以下两句前加#注释掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/noetic/setup.bash</span><br><span class="line"><span class="built_in">source</span> /opt/ros/galactic/setup.bash</span><br></pre></td></tr></table></figure>
<p>在后面加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ros noetic(1) or ros2 galactic(2)?&quot;</span></span><br><span class="line"><span class="built_in">read</span> edition</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$edition</span>&quot;</span> -eq <span class="string">&quot;1&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> /opt/ros/noetic/setup.bash</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">source</span> /opt/ros/galactic/setup.bash</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>刷新终端<code>source ~/.bashrc</code>，然后输入1或2即可在当前终端内应用对应的环境变量</p>
<h3 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h3><p>输入<code>ros2</code>，出现相关command的提示即为安装成功</p>
<h3 id="3-5-卸载"><a href="#3-5-卸载" class="headerlink" title="3.5 卸载"></a>3.5 卸载</h3><p>如需卸载，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove ~nros-galactic-* &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure>
<p>然后自行删除相关的环境变量</p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——16指针</title>
    <url>/posts/49c7378a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——16指针"><a href="#深入学习C-——16指针" class="headerlink" title="深入学习C++——16指针"></a>深入学习C++——16指针</h1><p>什么是指针？<strong>指针是一个整数，一种存储内存地址的数字。</strong>指针只是一个数字而已，不要想太多。指针的类型对指针来说是毫无意义的，只能说是这个地址的数据被假设为我们给的类型。指针类型并不会改变指针的实质，指针只是一个内存地址，一个数字而已。 </p>
<p>首先我们创建一个最纯粹的空指针，我并不关心这个指针的类型，因为我只想保存一个内存地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>nullptr</code>代表空指针的意思，也可写成NULL。但不可写成0，因为当内存地址为0的时候程序会崩溃。</p>
<p>每个变量都有一个内存地址，使用引用<code>&amp;</code>运算符（reference）得到这个变量的内存地址。创建一个变量名为var，使用ptr存放var的内存地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">void</span>* ptr = &amp;var;</span><br></pre></td></tr></table></figure>
<p>如果此时加断点调试，可以看到<code>var</code>的值为<code>8</code>，<code>ptr</code>的值为<code>0xef045ff954</code>，这是一个十六进制的数字，即为var变量的内存地址。我们在内存中转到这个地址，可以看到<code>08 00 00 00</code>，就是<code>var</code>的值<code>8</code>（int占用4个字节）。</p>
<p>指针的类型对指针无关紧要，将<code>void</code>改为<code>int</code>，再次在内存中转到此地址，效果是完全一样的。指针的类型只在读写时有作用，跟指针本身是完全无关的。<strong>指针只是一个整数</strong>而已。</p>
<p>如果我们想读写指针指向的数据，需要使用逆向引用<code>*</code>运算符（dereference）。在指针前加上<code>*</code>即可读取这个指针指向的数据。如前例，ptr为var的指针，使用<code>*ptr = 10</code>即可将var的值改为10。但是此时会报错，因为此时指针为void空指针，计算机并不知道这个“10”需要多少字节的数据，自然而然无法将其写入。所以此时需要指定字节数，即将前文改为<code>int* ptr = &amp;var;</code>。记住，类型跟指针毫无关系，类型的目的只是告诉编译器在读写时应该寻找几个字节。此时重新运行程序可以看到var的值被成功修改为10。</p>
<p>如果需要分配一些空间，可以这么操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new char[8]分配了8个字节的内存，并返回一个指向那块内存开始的指针。</span></span><br><span class="line"><span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//使用memset函数用指定的数据填充一个内存块：第一个参数为内存块开始的指针，第二个值为要填充的值，第三个参数为大小。</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>调试程序，转到buffer地址，可以看到<code>00 00 00 00   00 00 00 00</code>。之后需要释放这个内存，使用<code>delete[] buffer;</code></p>
<p>指针也是一个变量，因此指针也可以指向指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>** ptr = &amp;buffer;</span><br></pre></td></tr></table></figure>
<p>查看内存：buffer的值为<code>0x193a7d41b60</code>。ptr的值为<code>0x843b7ffb30</code>，即为buffer指针存放的地址。跳转进去可以看到<code>60 1b d4 a7   93 01 00 00</code>，这也就是buffer的值。（计算机中存储顺序为倒序）</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派压缩备份</title>
    <url>/posts/f438cf8d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派压缩备份"><a href="#树莓派压缩备份" class="headerlink" title="树莓派压缩备份"></a>树莓派压缩备份</h1><p>配置环境真的太折磨人了，如果使用简单的全盘备份，备份出来的文件和SD卡大小相同，且无法存入相同大小的的卡内。所以本文将介绍一种一键压缩备份的方法</p>
<h2 id="1-首先-clone-该脚本："><a href="#1-首先-clone-该脚本：" class="headerlink" title="1.首先 clone 该脚本："></a>1.首先 clone 该脚本：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/nanhantianyi/rpi-backup.git &amp;&amp; <span class="built_in">cd</span> rpi-backup</span><br></pre></td></tr></table></figure>
<h2 id="2-备份"><a href="#2-备份" class="headerlink" title="2.备份"></a>2.备份</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash back.sh 这里换成名字.img</span><br></pre></td></tr></table></figure>
<h2 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3.恢复"></a>3.恢复</h2><p>使用任意一种镜像烧写工具烧录到另外一张空SD卡中，然后执行扩容脚本扩容root分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash resize.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——17引用</title>
    <url>/posts/55bfc346.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——17引用"><a href="#深入学习C-——17引用" class="headerlink" title="深入学习C++——17引用"></a>深入学习C++——17引用</h1><p><strong>引用</strong>是一种引用现有变量的方式。与指针不同，指针可以创建空指针，而引用不行。引用必须引用已存在的变量。引用本身不是一个新变量，它不占用内存，没有自己的存储空间。</p>
<p>我们创建一个变量，并给这个变量创建一个引用。声明引用时需要指定变量类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br></pre></td></tr></table></figure>
<p>这里的ref就是a的别名，它本身不是一个真正的变量，ref变量实际并不存在，它只存在于代码中。</p>
<p>此时我们可以给ref赋值，然后输出a的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ref = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>运行程序，可以看到a的值变成了2。</p>
<p>下面来看一个更复杂的例子。我们创建一个变量递增函数，并在main中调用，把a作为参数传递进去，只是通过值传递给它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">Increment</span>(a);</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，可以看到a的值仍为5，并没有递增。实际上a传入Increment函数后创建了一个全新的变量value且等于a的值，其作用大致等效于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line">	value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们讲了指针，自然而然可以想到：我们并不直接把a的值传进函数，而是将a的内存地址传进去，然后在函数内寻找这个内存地址上的数据并对其进行操作即可。所以程序修改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>* value)</span><span class="comment">//传入一个指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//value++;//错误。这样只会递增value指针的地址，只是把一个指针递增了而已</span></span><br><span class="line">	<span class="comment">//*value++;//错误。这样写操作顺序为先递增内存地址再逆向引用</span></span><br><span class="line">	(*value)++;<span class="comment">//先逆向引用，再将值自增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">Increment</span>(&amp;a);<span class="comment">//传入变量的内存地址</span></span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行程序可以看到a的值被成功修改成了6。</p>
<p>有没有觉得使用指针的时候<code>*</code>和<code>&amp;</code>满天乱飞，本文讲了引用，那我们就通过另一种更为简洁的方法实现以上功能：我们可以用引用代替指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>&amp; value)</span><span class="comment">//传入一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value++;<span class="comment">//这里也不需要逆向引用*了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">Increment</span>(a);<span class="comment">//只需传递a即可</span></span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，a成功地被修改成了6。</p>
<p>综上，指针比引用更强大，能用引用的地方也一定能用指针，但是能用引用就用引用，这样会使程序更为简洁和干净。</p>
<p>不过要注意，声明引用的时候也必须给引用赋值，因为它并不是一个真正的变量，不能为空。并且一旦声明了一个引用，不能改变它引用的东西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line"><span class="comment">// now a = 8, b = 8</span></span><br></pre></td></tr></table></figure>
<p>这段程序只是将b的值赋给了a，并没有改变ref引用的东西。如果想要实现这个功能只能使用指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// now a = 2, b = 1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——18~20类</title>
    <url>/posts/cc7823d2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——18-19类"><a href="#深入学习C-——18-19类" class="headerlink" title="深入学习C++——18~19类"></a>深入学习C++——18~19类</h1><h2 id="18-类的基础认识"><a href="#18-类的基础认识" class="headerlink" title="18.类的基础认识"></a>18.类的基础认识</h2><p>与C语言不同，C++支持面向对象编程，因为C语言没有类、对象这些概念。</p>
<p>类是对数据和功能组合在一起的一种方法。如果在游戏中需要一些代表角色的东西，就需要一堆变量。如果这时有两个人物，就要把同样的代码复制两份。这样一来代码会非常混乱且重复，难以维护。使用类可以简化，创建一个叫做player的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的本质是一个类型，可以把他当成其他变量来创建。我们使用<code>Player player;</code>创建一个新变量叫做player，类型为Player。由类这种类型构成的变量称为对象，新的对象变量称为实例。这一句所做的是实例化了一个Player对象。若需给变量赋值，使用<code>player.</code>加变量名即可访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Player player;</span><br><span class="line">	player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时会报错<code>error: &#39;int Player::x&#39; is private within this context</code>，这是因为x实际上是私有成员。类中的内容有可见性这一说，默认情况下一个类中所有的东西都是私有的（private），意味着只有类中的函数才能访问这些变量。如果需要在类外访问这些变量，我们需要将其设为公有的（public）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时如果需要写一个函数来操作x和y，需要使用引用传递，因为需要修改Player对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(Player&amp; player, <span class="keyword">int</span> xa, <span class="keyword">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	player.x += xa * player.speed;</span><br><span class="line">	player.y += ya * player.speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Player player;</span><br><span class="line">	<span class="built_in">Move</span>(player, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类实际上也可以包含函数，类内的函数称为方法。将move函数移动到类中，此时不需要传入player对象，因为已经在Player对象中了。所有的<code>player.</code>也都不需要了，他们指的就是当前对象的变量。main函数中使用<code>player.Move(1, -1);</code>来调用方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> xa,<span class="keyword">int</span> ya)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Player player;</span><br><span class="line">	player.<span class="built_in">Move</span>(player, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，类允许我们将变量分组到一个类型中，并为这些变量添加功能。类并没有为变量提供什么新功能，不能用一般代码完成的工作用类同样无法完成。类只是提高了我们维护代码的效率。</p>
<h2 id="19-类与结构体的对比"><a href="#19-类与结构体的对比" class="headerlink" title="19.类与结构体的对比"></a>19.类与结构体的对比</h2><p>结构体（struct）和类（class）基本上没有什么区别，只有一个关于可见度的小区别，class中默认为private，而struct中默认为public。除此之外没有任何区别，C++中存在结构体的原因是为了与C保持向后兼容性。</p>
<p>什么时候该用结构体？什么时候该用类？从定义上来看，如果你需要类内变量都是private的那就用class，反之用struct。不过从经验上来谈，如果只是想表示一堆数据，那就用结构体。如果需要大量功能且需要继承，那就用类。这只是个人见解，这两者只是在语义上有可见性的区别，没有严格的规定，如何使用全看个人编程风格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h2 id="类与结构体的初始化和赋值"><a href="#类与结构体的初始化和赋值" class="headerlink" title="类与结构体的初始化和赋值"></a>类与结构体的初始化和赋值</h2><p>变量的赋值和初始化是不一样的，初始化是在变量定义的时候完成的，是属于变量定义的一部分，赋值是在变量定义完成之后想改变变量值的时候所采取的操作。</p>
<p>下面拿结构体举例子：</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>如果结构体没有构造函数，可以用<code>指定初始化</code>与<code>顺序初始化</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有构造函数的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化 注意在c++中，顺序不能变。</span></span><br><span class="line">MyStruct ms = &#123;.x = <span class="number">2</span>, .y = <span class="number">3</span>&#125;;</span><br><span class="line">MyStruct ms = &#123;x:<span class="number">2</span>, y:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序初始化</span></span><br><span class="line">MyStruct ms = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>C++的结构体也可以有构造函数，如果有构造函数则可以用构造函数初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有构造函数的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;x=x;</span><br><span class="line">		<span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数初始化</span></span><br><span class="line"><span class="function">MyStruct <span class="title">ms</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依次给每一个结构体成员变量进行赋值</span></span><br><span class="line">MyStruct ms;</span><br><span class="line">ms.x = <span class="number">2</span>;</span><br><span class="line">ms.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误！结构体变量的赋值不能采用大括号方式</span></span><br><span class="line">MyStruct ms;</span><br><span class="line">ms = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用现有结构体变量给另一个结构体变量赋值</span></span><br><span class="line">MyStruct ms = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">MyStruct ms1;</span><br><span class="line">ms1 = ms;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体初始化后默认为随机值，初始化后置空用memset</span></span><br><span class="line">MyStruct ms;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ms, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ms));</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p><strong>类的内容又多又杂，将会持续更新</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——21~23静态</title>
    <url>/posts/fd77a296.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——21-23静态"><a href="#深入学习C-——21-23静态" class="headerlink" title="深入学习C++——21~23静态"></a>深入学习C++——21~23静态</h1><p>static在C++中有两种含义，分为<strong>类和结构体外的静态</strong>和<strong>类和结构体内的静态</strong></p>
<h2 id="21-类和结构体外的静态"><a href="#21-类和结构体外的静态" class="headerlink" title="21.类和结构体外的静态"></a>21.类和结构体外的静态</h2><p>类和结构体外部的static，意味着你声明为static的符号只在当前文件内部链接，它只对它所在的翻译单元可见。有关翻译单元请看<strong>深入学习C++——6~7编译器和链接器</strong></p>
<p>新建一个源文件命名为<code>CStatic.cpp</code>，在<code>main.cpp</code>和<code>Cstatic.cpp</code>中同时定义一个变量和一个函数，编译器在链接阶段会报错<code>multiple definition of XXX</code>，这是因为这个变量/函数已经在另一个编译单元中定义了。所以我们不能有两个同名的全局变量/函数。其中一种修改方式是使用<code>extern</code>关键字，extern意味着它会在外部翻译单元中寻找这个变量/函数。我们把<code>main.cpp</code>中的定义加上static，再次编译无报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*CStatic.cpp*/</span></span><br><span class="line"><span class="keyword">int</span> Variable = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Function in CStatic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="comment">//int Variable = 5; //multiple definition of Variable</span></span><br><span class="line"><span class="comment">//void Function() //multiple definition of `Function()&#x27;</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	std::cout &lt;&lt; &quot;Variable&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> Variable;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>; <span class="comment">//函数默认都是extern，这里删掉extern也可以编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	std::cout &lt;&lt; Variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种解决方法是使用<code>static</code>关键字。static的意思是这个变量/函数只会在这个翻译单元内部链接。这有点像在类中定义私有变量/函数，其他所有的翻译单元都不能看到这个变量/函数。链接器在全局作用域下将不会看到这个变量/函数。把<code>CStatic.cpp</code>中的变量与函数均改成静态的，编译会报错，因为他们在main中不可见，跨翻译单元是找不到他的。将main.cpp中的变量和函数修改为全局的，此时编译通过，且输出的是main中定义的变量值和函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*CStatic.cpp*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Variable = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Function in CStatic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="comment">//extern int Variable; //undefined reference to `Function()&#x27;</span></span><br><span class="line"><span class="comment">//extern void Function(); //undefined reference to `Variable&#x27;</span></span><br><span class="line"><span class="keyword">int</span> Variable = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Function in main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	std::cout &lt;&lt; Variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类和结构体外使用静态，意味着当你声明静态函数和静态变量时，它只会在它被声明的C++文件中被“看到”。如果在一个头文件中声明静态变量并将该头文件包含在两个不同的C++文件中，就相当于在两个翻译单元中都声明了那个变量为静态变量。（包含头文件时，编译器会复制所有头文件中的内容到C++文件中）</p>
<p>为什么要用static？可以类比为什么要在类中用private。当不需要变量是全局变量时，尽可能地用静态变量。因为一旦在全局作用域下声明东西的时候，编译器会跨编译单元进行链接，这个变量在任何地方都可以被使用，可能会导致一些很严重的bug。</p>
<p>综上，尽可能地标记函数或变量为静态的，除非你真的需要他们跨翻译单元链接。</p>
<h2 id="22-类和结构体内的静态"><a href="#22-类和结构体内的静态" class="headerlink" title="22.类和结构体内的静态"></a>22.类和结构体内的静态</h2><p>在类和结构体内部定义的静态变量，在类的所有实例中这个变量只有一个实例，这意味着该变量实际上将与类的所有实例共享内存。对于静态函数来说，没有实例会传递给一个静态函数。</p>
<p>下面用结构体举例子（类也一样，只是因为结构体默认是public的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e1;</span><br><span class="line">	e1.num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	Entity e2;</span><br><span class="line">	e2.num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	e1.<span class="built_in">Print</span>();</span><br><span class="line">	e2.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，这样会输出2和5。如果将结构体内的x和y变成静态的，会报错<code>undefined reference to ‘Entity::num’</code>，因为x和y要在某个地方被定义，加上<code>int Entity::num;</code>，程序修改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Entity::num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e1;</span><br><span class="line">	e1.num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	Entity e2;</span><br><span class="line">	e2.num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	e1.<span class="built_in">Print</span>();</span><br><span class="line">	e2.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时运行会输出5和5.这是因为num变量在Entity类的所有实例中只有一个实例，这意味着e1.num和e2.num指向的是相同的内存，所以<code>e1.num</code>和<code>e2.num</code>这样写是没有意义的。可以直接写成<code>Entity::num = 5</code>。这就像是在一个名为Entity的命名空间中创建了一个变量，他们实际上并不属于类，但是他们可以是private的也可以是public的，所以他们仍是类的一部分。但是在应用上来说他们其实和在命名空间中一样。</p>
<p>静态方法跟静态变量一样，如果将Print也改为静态的，调用时同样需要使用<code>Entity::Print();</code></p>
<p>但静态方法不能访问非静态变量，将num改为非静态变量，Print保持为静态方法，这时编译会报错<code>error: invalid use of member &#39;Entity::num&#39; in static member function</code>，原因是静态方法没有类实例。每个非静态方法总是会获得当前类的一个实例作为参数，这我们是看不见的，在底层通过隐藏参数发挥作用，而静态方法不会得到那个隐藏参数。类中的静态方法拿到类外面在编译的时候实际上是这个样子的，实际上传进去了一个实例参数，这样就不会报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(Entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; e.num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity e;</span><br><span class="line">	e.num = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">Print</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，当你需要跨类使用变量时，类内静态变量将会派上用场。那这么说创建一个全局变量或者静态变量不也一样吗？NO！如果你有一条消息，想要在所有实例之间共享数据，把这个消息变量放在类中是有意义的，因为它在逻辑上跟这个类有关。要想组织好你的代码，最好在类中创建一个静态变量，而不是将全局或者静态变量到处乱写。</p>
<h2 id="23-局部静态"><a href="#23-局部静态" class="headerlink" title="23.局部静态"></a>23.局部静态</h2><p>局部静态允许我们创建一个变量，它的生存周期基本相当于整个程序的生存期，但是作用范围被限制在这个域中。来看一段程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	i++;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见输出为11111。要是想将i每次递增实现输出12345，你的第一反应可能是将i改为全局变量。但是这样做会使每个人都能访问这个变量，如果要避免这个问题，可以在局部作用域下将i声明为static。这样程序也可以输出12345，与全局变量效果相同，但是此时i只是函数作用域下的局部变量。</p>
<p>使用局部静态的主要作用是可以使代码更干净，我们来看另一个例子。创建一个单例类（单例类是只存在一个实例的类），如果不使用静态局部作用域来创建单例类，就需要创建静态的单例实例，可能是一个指针，并返回一个引用，即为创建的实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Singleton* s_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *s_Instance;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用局部静态来创建，代码会变得干净很多：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码里如果没有static，当代码运行到函数右花括号处，即函数作用域结束时，instance就会被销毁。通过添加static，它的生存周期被延长到永远，在第一次调用Get的时候，实际上会构造一个单例实例，接下来它只会返回这个已存在的实例。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>范子琦第二次作业</title>
    <url>/posts/337c96c3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><p><strong>范子琦 2019330301153 机器人工程(1)班</strong></p>
<p>下文坐标系定义原则: $\left\{\begin{matrix}<br>x_i\parallel z_{i-1}\\<br>x_i\perp z_{i-1}<br>\end{matrix}\right.$​</p>
<p>图注:</p>
<ol>
<li><p>相同颜色为同一坐标系, 绿色虚线为延长线</p>
</li>
<li><p>有尺寸的以数字表示, 无尺寸的参照图中定义</p>
</li>
</ol>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>平面三连杆机械臂的坐标系定义如下图所示:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/test1.jpeg" alt="test1" style="zoom:50%;"></p>
<p>由上图坐标系配置可求得平面三连杆机械臂的DH参数:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$i$</th>
<th style="text-align:left">$\theta_i$</th>
<th>$d_i$</th>
<th>$a_i$</th>
<th>$\alpha_i$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td style="text-align:left">${\theta_1}^*+90$</td>
<td>$0$</td>
<td>$0$</td>
<td>$90$</td>
</tr>
<tr>
<td>$2$</td>
<td style="text-align:left">$0$</td>
<td>$L_1+{d_2}^*$</td>
<td>$0$</td>
<td>$-90$</td>
</tr>
<tr>
<td>$3$</td>
<td style="text-align:left">${\theta_3}^*$</td>
<td>$0$</td>
<td>$L_3$</td>
<td>$0$​</td>
</tr>
</tbody>
</table>
</div>
<p>MATLAB代码:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line">syms t1 d2 t3 L1 L3</span><br><span class="line"><span class="comment">%          theta   d          a         alpha     sigma</span></span><br><span class="line">L(<span class="number">1</span>)=Link([t1+<span class="built_in">pi</span>/<span class="number">2</span> <span class="number">0</span>          <span class="number">0</span>         <span class="built_in">pi</span>/<span class="number">2</span>        <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">2</span>)=Link([<span class="number">0</span>       L1+d2      <span class="number">0</span>        -<span class="built_in">pi</span>/<span class="number">2</span>        <span class="number">1</span>     ]);</span><br><span class="line">L(<span class="number">3</span>)=Link([t3      <span class="number">0</span>          L3        <span class="number">0</span>           <span class="number">0</span>     ]);</span><br><span class="line">robot=SerialLink(L,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Three&#x27;</span>)</span><br><span class="line">T=robot.fkine([t1 d2 t3])</span><br></pre></td></tr></table></figure>
<p>运动学正解矩阵:</p>
<script type="math/tex; mode=display">
^0T_3=
\begin{bmatrix}
cos(\theta_1 + \theta_3) & -sin(\theta_1 + \theta_3) & 0 & L_3*cos(\theta_1 + \theta_3) + d_2*sin(\theta_1) \\ 
sin(\theta_1 + \theta_3) &  cos(\theta_1 + \theta_3) & 0 & L_3*sin(\theta_1 + \theta_3) - d_2*cos(\theta_1) \\ 
           0 &             0 & 1 &                            0 \\ 
           0 &             0 & 0 &                            1 
\end{bmatrix}</script><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>PUMA260的坐标系定义如下图所示:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/test2.jpeg" alt="test2" style="zoom:50%;"></p>
<p>由上图坐标系配置可求得PUMA260的DH参数:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$i$</th>
<th style="text-align:left">$\theta_i$</th>
<th>$d_i$</th>
<th>$a_i$</th>
<th>$\alpha_i$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td style="text-align:left">${\theta_1}^*$</td>
<td>$13$</td>
<td>$0$</td>
<td>$-90$</td>
</tr>
<tr>
<td>$2$</td>
<td style="text-align:left">${\theta_2}^*$</td>
<td>$-d_2$</td>
<td>$8$</td>
<td>$0$</td>
</tr>
<tr>
<td>$3$</td>
<td style="text-align:left">${\theta_3}^*+90$</td>
<td>$0$</td>
<td>$0$</td>
<td>$90$</td>
</tr>
<tr>
<td>$4$</td>
<td style="text-align:left">${\theta_4}^*$</td>
<td>$8$</td>
<td>$0$</td>
<td>$-90$</td>
</tr>
<tr>
<td>$5$</td>
<td style="text-align:left">${\theta_5}^*-90$</td>
<td>$0$</td>
<td>$0$</td>
<td>$90$</td>
</tr>
<tr>
<td>$6$</td>
<td style="text-align:left">${\theta_6}^*$</td>
<td>$d_6$</td>
<td>$0$</td>
<td>$0$</td>
</tr>
</tbody>
</table>
</div>
<p>MATLAB代码:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line">syms t1 t2 t3 t4 t5 t6 d2 d6</span><br><span class="line"><span class="comment">%          theta   d          a         alpha     sigma</span></span><br><span class="line">L(<span class="number">1</span>)=Link([t1      <span class="number">13</span>         <span class="number">0</span>         -<span class="built_in">pi</span>/<span class="number">2</span>       <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">2</span>)=Link([t2      -d2        <span class="number">8</span>         <span class="number">0</span>           <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">3</span>)=Link([t3+<span class="built_in">pi</span>/<span class="number">2</span> <span class="number">0</span>          <span class="number">0</span>         <span class="built_in">pi</span>/<span class="number">2</span>        <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">4</span>)=Link([t4      <span class="number">8</span>          <span class="number">0</span>         -<span class="built_in">pi</span>/<span class="number">2</span>       <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">5</span>)=Link([t5-<span class="built_in">pi</span>/<span class="number">2</span> <span class="number">0</span>          <span class="number">0</span>         <span class="built_in">pi</span>/<span class="number">2</span>        <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">6</span>)=Link([t6      d6         <span class="number">0</span>         <span class="number">0</span>           <span class="number">0</span>     ]);</span><br><span class="line">robot=SerialLink(L,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;PUMA260&#x27;</span>)</span><br><span class="line">T=robot.fkine([t1 t2 t3 t4 t5 t6])</span><br></pre></td></tr></table></figure>
<p>运动学正解矩阵:</p>
<script type="math/tex; mode=display">
^0T_3=
\begin{bmatrix}

 - sin(\theta_6)*(cos(\theta_4)*sin(\theta_1) - sin(\theta_4)*(cos(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_1)*cos(\theta_2)*cos(\theta_3))) - cos(\theta_6)*(cos(\theta_5)*(sin(\theta_1)*sin(\theta_4) + cos(\theta_4)*(cos(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_1)*cos(\theta_2)*cos(\theta_3))) + sin(\theta_5)*(cos(\theta_1)*cos(\theta_2)*sin(\theta_3) + cos(\theta_1)*cos(\theta_3)*sin(\theta_2)))& sin(\theta_6)*(cos(\theta_5)*(sin(\theta_1)*sin(\theta_4) + cos(\theta_4)*(cos(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_1)*cos(\theta_2)*cos(\theta_3))) + sin(\theta_5)*(cos(\theta_1)*cos(\theta_2)*sin(\theta_3) + cos(\theta_1)*cos(\theta_3)*sin(\theta_2))) - cos(\theta_6)*(cos(\theta_4)*sin(\theta_1) - sin(\theta_4)*(cos(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_1)*cos(\theta_2)*cos(\theta_3)))& cos(\theta_5)*(cos(\theta_1)*cos(\theta_2)*sin(\theta_3) + cos(\theta_1)*cos(\theta_3)*sin(\theta_2)) - sin(\theta_5)*(sin(\theta_1)*sin(\theta_4) + cos(\theta_4)*(cos(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_1)*cos(\theta_2)*cos(\theta_3)))& 8*cos(\theta_1)*cos(\theta_2) + d_2*sin(\theta_1) - d_6*(sin(\theta_5)*(sin(\theta_1)*sin(\theta_4) + cos(\theta_4)*(cos(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_1)*cos(\theta_2)*cos(\theta_3))) - cos(\theta_5)*(cos(\theta_1)*cos(\theta_2)*sin(\theta_3) + cos(\theta_1)*cos(\theta_3)*sin(\theta_2))) + 8*cos(\theta_1)*cos(\theta_2)*sin(\theta_3) + 8*cos(\theta_1)*cos(\theta_3)*sin(\theta_2)\\
   sin(\theta_6)*(cos(\theta_1)*cos(\theta_4) + sin(\theta_4)*(sin(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_2)*cos(\theta_3)*sin(\theta_1))) + cos(\theta_6)*(cos(\theta_5)*(cos(\theta_1)*sin(\theta_4) - cos(\theta_4)*(sin(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_2)*cos(\theta_3)*sin(\theta_1))) - sin(\theta_5)*(cos(\theta_2)*sin(\theta_1)*sin(\theta_3) + cos(\theta_3)*sin(\theta_1)*sin(\theta_2)))& cos(\theta_6)*(cos(\theta_1)*cos(\theta_4) + sin(\theta_4)*(sin(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_2)*cos(\theta_3)*sin(\theta_1))) - sin(\theta_6)*(cos(\theta_5)*(cos(\theta_1)*sin(\theta_4) - cos(\theta_4)*(sin(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_2)*cos(\theta_3)*sin(\theta_1))) - sin(\theta_5)*(cos(\theta_2)*sin(\theta_1)*sin(\theta_3) + cos(\theta_3)*sin(\theta_1)*sin(\theta_2)))& sin(\theta_5)*(cos(\theta_1)*sin(\theta_4) - cos(\theta_4)*(sin(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_2)*cos(\theta_3)*sin(\theta_1))) + cos(\theta_5)*(cos(\theta_2)*sin(\theta_1)*sin(\theta_3) + cos(\theta_3)*sin(\theta_1)*sin(\theta_2))& 8*cos(\theta_2)*sin(\theta_1) + d_6*(sin(\theta_5)*(cos(\theta_1)*sin(\theta_4) - cos(\theta_4)*(sin(\theta_1)*sin(\theta_2)*sin(\theta_3) - cos(\theta_2)*cos(\theta_3)*sin(\theta_1))) + cos(\theta_5)*(cos(\theta_2)*sin(\theta_1)*sin(\theta_3) + cos(\theta_3)*sin(\theta_1)*sin(\theta_2))) - d_2*cos(\theta_1) + 8*cos(\theta_2)*sin(\theta_1)*sin(\theta_3) + 8*cos(\theta_3)*sin(\theta_1)*sin(\theta_2)\\
                                                                                                                                                                sin(\theta_2 + \theta_3)*sin(\theta_4)*sin(\theta_6) - cos(\theta_6)*(cos(\theta_2 + \theta_3)*sin(\theta_5) + sin(\theta_2 + \theta_3)*cos(\theta_4)*cos(\theta_5))&                                                                                                                                                              sin(\theta_6)*(cos(\theta_2 + \theta_3)*sin(\theta_5) + sin(\theta_2 + \theta_3)*cos(\theta_4)*cos(\theta_5)) + sin(\theta_2 + \theta_3)*cos(\theta_6)*sin(\theta_4)&                                                                                                   cos(\theta_2 + \theta_3)*cos(\theta_5) - sin(\theta_2 + \theta_3)*cos(\theta_4)*sin(\theta_5)&                                                                                                                     8*cos(\theta_2 + \theta_3) - 8*sin(\theta_2) - (d_6*sin(\theta_2 + \theta_3)*sin(\theta_4 + \theta_5))/2 + d_6*cos(\theta_2 + \theta_3)*cos(\theta_5) + (d_6*sin(\theta_4 - \theta_5)*sin(\theta_2 + \theta_3))/2 + 13\\
0&0&0&1

\end{bmatrix}</script><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>JAKA ZU3的坐标系定义如下图所示:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/test3.jpeg" alt="test3" style="zoom:50%;"></p>
<p>由上图坐标系配置可求得JAKA ZU3的DH参数:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$i$</th>
<th style="text-align:left">$\theta_i$</th>
<th>$d_i$</th>
<th>$a_i$</th>
<th>$\alpha_i$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td style="text-align:left">${\theta_1}^*$</td>
<td>$150.55$</td>
<td>$0$</td>
<td>$-90$</td>
</tr>
<tr>
<td>$2$</td>
<td style="text-align:left">${\theta_2}^*-90$</td>
<td>$115$</td>
<td>$246$</td>
<td>$0$</td>
</tr>
<tr>
<td>$3$</td>
<td style="text-align:left">${\theta_3}^*$</td>
<td>$-116.3$</td>
<td>$190$</td>
<td>$0$</td>
</tr>
<tr>
<td>$4$</td>
<td style="text-align:left">${\theta_4}^*+90$</td>
<td>$117.5$</td>
<td>$0$</td>
<td>$90$</td>
</tr>
<tr>
<td>$5$</td>
<td style="text-align:left">${\theta_5}^*$</td>
<td>$117.5$</td>
<td>$0$</td>
<td>$-90$</td>
</tr>
<tr>
<td>$6$</td>
<td style="text-align:left">${\theta_6}^*+180$</td>
<td>$-105$</td>
<td>$0$</td>
<td>$180$</td>
</tr>
</tbody>
</table>
</div>
<p>MATLAB代码:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line">syms t1 t2 t3 t4 t5 t6</span><br><span class="line"><span class="comment">%          theta   d          a         alpha     sigma</span></span><br><span class="line">L(<span class="number">1</span>)=Link([t1      <span class="number">150.55</span>     <span class="number">0</span>         -<span class="built_in">pi</span>/<span class="number">2</span>       <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">2</span>)=Link([t2-<span class="built_in">pi</span>/<span class="number">2</span> <span class="number">115</span>        <span class="number">246</span>       <span class="number">0</span>           <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">3</span>)=Link([t3      <span class="number">-116.3</span>     <span class="number">190</span>       <span class="number">0</span>           <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">4</span>)=Link([t4+<span class="built_in">pi</span>/<span class="number">2</span> <span class="number">117.5</span>      <span class="number">0</span>         <span class="built_in">pi</span>/<span class="number">2</span>        <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">5</span>)=Link([t5      <span class="number">117.5</span>      <span class="number">0</span>         -<span class="built_in">pi</span>/<span class="number">2</span>       <span class="number">0</span>     ]);</span><br><span class="line">L(<span class="number">6</span>)=Link([t6+<span class="built_in">pi</span>   <span class="number">-105</span>       <span class="number">0</span>         <span class="number">180</span>         <span class="number">0</span>     ]);</span><br><span class="line">robot=SerialLink(L,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;JAKA-ZU3&#x27;</span>)</span><br><span class="line">T=robot.fkine([t1 t2 t3 t4 t5 t6])</span><br></pre></td></tr></table></figure>
<p>运动学正解矩阵:</p>
<script type="math/tex; mode=display">
^0T_3=
\begin{bmatrix}


 - cos(\theta_6)*(sin(\theta_1)*sin(\theta_5) - cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*cos(\theta_5)) - sin(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*sin(\theta_6), cos(180)*sin(\theta_6)*(sin(\theta_1)*sin(\theta_5) - cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*cos(\theta_5)) - sin(180)*(cos(\theta_5)*sin(\theta_1) + cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*sin(\theta_5)) - sin(\theta_2 + \theta_3 + \theta_4)*cos(180)*cos(\theta_1)*cos(\theta_6), sin(\theta_2 + \theta_3 + \theta_4)*sin(180)*cos(\theta_1)*cos(\theta_6) - sin(180)*sin(\theta_6)*(sin(\theta_1)*sin(\theta_5) - cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*cos(\theta_5)) - cos(180)*(cos(\theta_5)*sin(\theta_1) + cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*sin(\theta_5)), 246*cos(\theta_1)*cos(\theta_2) - (581*sin(\theta_1))/5 + 105*cos(\theta_5)*sin(\theta_1) - 190*cos(\theta_1)*sin(\theta_2)*sin(\theta_3) + 105*cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_1)*sin(\theta_5) + (235*cos(\theta_2 + \theta_3)*cos(\theta_1)*sin(\theta_4))/2 + (235*sin(\theta_2 + \theta_3)*cos(\theta_1)*cos(\theta_4))/2 + 190*cos(\theta_1)*cos(\theta_2)*cos(\theta_3)\\
   cos(\theta_6)*(cos(\theta_1)*sin(\theta_5) + cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_5)*sin(\theta_1)) - sin(\theta_2 + \theta_3 + \theta_4)*sin(\theta_1)*sin(\theta_6), sin(180)*(cos(\theta_1)*cos(\theta_5) - cos(\theta_2 + \theta_3 + \theta_4)*sin(\theta_1)*sin(\theta_5)) - cos(180)*sin(\theta_6)*(cos(\theta_1)*sin(\theta_5) + cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_5)*sin(\theta_1)) - sin(\theta_2 + \theta_3 + \theta_4)*cos(180)*cos(\theta_6)*sin(\theta_1), cos(180)*(cos(\theta_1)*cos(\theta_5) - cos(\theta_2 + \theta_3 + \theta_4)*sin(\theta_1)*sin(\theta_5)) + sin(180)*sin(\theta_6)*(cos(\theta_1)*sin(\theta_5) + cos(\theta_2 + \theta_3 + \theta_4)*cos(\theta_5)*sin(\theta_1)) + sin(\theta_2 + \theta_3 + \theta_4)*sin(180)*cos(\theta_6)*sin(\theta_1), (581*cos(\theta_1))/5 - 105*cos(\theta_1)*cos(\theta_5) + 246*cos(\theta_2)*sin(\theta_1) - 190*sin(\theta_1)*sin(\theta_2)*sin(\theta_3) + 105*cos(\theta_2 + \theta_3 + \theta_4)*sin(\theta_1)*sin(\theta_5) + (235*cos(\theta_2 + \theta_3)*sin(\theta_1)*sin(\theta_4))/2 + (235*sin(\theta_2 + \theta_3)*cos(\theta_4)*sin(\theta_1))/2 + 190*cos(\theta_2)*cos(\theta_3)*sin(\theta_1)\\
                                     - cos(\theta_2 + \theta_3 + \theta_4)*sin(\theta_6) - sin(\theta_2 + \theta_3 + \theta_4)*cos(\theta_5)*cos(\theta_6),                                                                 sin(\theta_2 + \theta_3 + \theta_4)*sin(180)*sin(\theta_5) - cos(\theta_2 + \theta_3 + \theta_4)*cos(180)*cos(\theta_6) + sin(\theta_2 + \theta_3 + \theta_4)*cos(180)*cos(\theta_5)*sin(\theta_6),                                                                 cos(\theta_2 + \theta_3 + \theta_4)*sin(180)*cos(\theta_6) + sin(\theta_2 + \theta_3 + \theta_4)*cos(180)*sin(\theta_5) - sin(\theta_2 + \theta_3 + \theta_4)*sin(180)*cos(\theta_5)*sin(\theta_6),                                                                        (235*cos(\theta_2 + \theta_3)*cos(\theta_4))/2 - 246*sin(\theta_2) - (235*sin(\theta_2 + \theta_3)*sin(\theta_4))/2 - sin(\theta_5)*(105*cos(\theta_2 + \theta_3)*sin(\theta_4) + 105*sin(\theta_2 + \theta_3)*cos(\theta_4)) - 190*sin(\theta_2 + \theta_3) + 3011/20\\
0,0,0,1


\end{bmatrix}</script><p>运动学逆解</p>
<p>建立仿真环境</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line">L(<span class="number">1</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">150.55</span>, <span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,   <span class="string">&#x27;alpha&#x27;</span>,-<span class="built_in">pi</span>/<span class="number">2</span>, <span class="string">&#x27;qlim&#x27;</span>,[-<span class="built_in">pi</span>,<span class="built_in">pi</span>]);</span><br><span class="line">L(<span class="number">2</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">115</span>,    <span class="string">&#x27;a&#x27;</span>,<span class="number">246</span>, <span class="string">&#x27;alpha&#x27;</span>,<span class="number">0</span>,     <span class="string">&#x27;qlim&#x27;</span>,[-<span class="built_in">pi</span>,<span class="built_in">pi</span>]);</span><br><span class="line">L(<span class="number">3</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">-116.3</span>, <span class="string">&#x27;a&#x27;</span>,<span class="number">190</span>, <span class="string">&#x27;alpha&#x27;</span>,<span class="number">0</span>,     <span class="string">&#x27;qlim&#x27;</span>,[-<span class="built_in">pi</span>,<span class="built_in">pi</span>]);</span><br><span class="line">L(<span class="number">4</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">117.5</span>,  <span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,   <span class="string">&#x27;alpha&#x27;</span>,<span class="built_in">pi</span>/<span class="number">2</span>,  <span class="string">&#x27;qlim&#x27;</span>,[-<span class="built_in">pi</span>,<span class="built_in">pi</span>]);</span><br><span class="line">L(<span class="number">5</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">117.5</span>,  <span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,   <span class="string">&#x27;alpha&#x27;</span>,-<span class="built_in">pi</span>/<span class="number">2</span>, <span class="string">&#x27;qlim&#x27;</span>,[-<span class="built_in">pi</span>,<span class="built_in">pi</span>]);</span><br><span class="line">L(<span class="number">6</span>)=Link(<span class="string">&#x27;d&#x27;</span>,<span class="number">-105</span>,   <span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,   <span class="string">&#x27;alpha&#x27;</span>,<span class="built_in">pi</span>,    <span class="string">&#x27;qlim&#x27;</span>,[-<span class="built_in">pi</span>,<span class="built_in">pi</span>]);</span><br><span class="line">robot=SerialLink(L,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;JAKA-ZU3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>第一组数据</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">view(<span class="number">3</span>)</span><br><span class="line">robot.teach([<span class="number">0</span>+<span class="number">0</span> <span class="built_in">pi</span>/<span class="number">2</span>-<span class="built_in">pi</span> <span class="number">0</span>+<span class="number">0</span> <span class="built_in">pi</span>/<span class="number">2</span>+<span class="number">0</span> <span class="built_in">pi</span>+<span class="number">0</span> <span class="number">0</span>+<span class="built_in">pi</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8B%E5%8D%8810.11.06.png" alt="截屏2021-11-14 下午10.11.06" style="zoom:50%;"></p>
<p>第二组数据</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">view(<span class="number">3</span>)</span><br><span class="line">robot.teach([<span class="number">30.906</span>*(<span class="built_in">pi</span>/<span class="number">180</span>)+<span class="number">0</span> <span class="number">72.993</span>*(<span class="built_in">pi</span>/<span class="number">180</span>)-<span class="built_in">pi</span> <span class="number">-68.722</span>*(<span class="built_in">pi</span>/<span class="number">180</span>)+<span class="number">0</span> <span class="number">84.098</span>*(<span class="built_in">pi</span>/<span class="number">180</span>)+<span class="number">0</span> <span class="number">91.007</span>*(<span class="built_in">pi</span>/<span class="number">180</span>)+<span class="number">0</span> <span class="number">0.051</span>*(<span class="built_in">pi</span>/<span class="number">180</span>)+<span class="built_in">pi</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2021-11-14%20%E4%B8%8B%E5%8D%8810.09.30.png" alt="截屏2021-11-14 下午10.09.30" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——44智能指针</title>
    <url>/posts/b0f9a474.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——44智能指针"><a href="#深入学习C-——44智能指针" class="headerlink" title="深入学习C++——44智能指针"></a>深入学习C++——44智能指针</h1><p>我们都知道使用new在堆上分配内存，使用delete释放内存，因为它不会自动释放内存。智能指针本质上是一个原始指针的包装类，当创建一个智能指针，它会调用new并为其分配内存，基于这个智能指针，这些内存会在某一时刻自动释放。下面介绍三种智能指针</p>
<p>使用智能指针的时候要包含memory头文件</p>
<h2 id="作用域指针unique-ptr"><a href="#作用域指针unique-ptr" class="headerlink" title="作用域指针unique_ptr"></a>作用域指针unique_ptr</h2><p><code>unique_ptr</code>是作用域指针，超出作用域时会被销毁，然后调用delete。<br>我们不能复制一个unique_ptr，因为如果复制一个unique_ptr，那么他们会指向同一个内存块。如果其中一个死了，它会释放那段内存，而指向同一块内存的另一个指针就会指向已经被释放的内存。</p>
<p>我们首先创建一个类来理解智能指针，类中只包含构造和析构函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Entity</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在特定的作用域下创建一个unique_ptr：在main中创建一对大括号，括号内即为空作用域。在里面使用unique_ptr来分配Entity：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_ptr&lt;Entity&gt; entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">//错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样构造会报错，因为unique_ptr的构造函数是explicit的，需要显式调用构造函数，没有构造函数的隐式转换，所以应该：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>; <span class="comment">//正确</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过更推荐使用下面这种方法！原因是出于异常安全。如果构造函数碰巧抛出异常，使用make_unique会保证你最终得到的不是没有引用的悬空指针，从而造成内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以跟原始指针一样地使用智能指针，比如使用箭头操作符调用函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">		entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单步调试，可以看到程序在进入作用域{时输出<code>Created Entity</code>，出作用域}时输出<code>Destroyed Entity</code>，即为智能指针的自动创建与销毁。</p>
<p>如果需要拷贝或共享这个指针，使得这个指针可以被传递到一个函数中或一个类中，unique_ptr将不可用。如果试图复制一个unique_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">		std::unique_ptr&lt;Entity&gt; e0 = entity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会报错，因为在unique_ptr的定义中，删除了拷贝构造函数和拷贝构造操作符，因为这是不被允许的。这是为了防止你跳到大坑里，因为其中一个unique_ptr死了，这个堆分配对象的底层内存会被释放，另一个unique_ptr会指向这个不存在的内存。所以出现了共享指针shared_ptr：</p>
<h2 id="共享指针shared-ptr"><a href="#共享指针shared-ptr" class="headerlink" title="共享指针shared_ptr"></a>共享指针shared_ptr</h2><p>共享指针shared_ptr更牛逼一点，shared_ptr实现的方式实际上取决于编译器和你在编译器中使用的标准库，在大多数情况下，它使用的是引用计数。引用计数基本上是一种方法，可以跟踪你的指针有多少个引用，一旦引用计数达到0，它就会被删除。如果我创建了一个shared_ptr，又创建了另外一个shared_ptr来复制他，此时的引用计数就是2，当第一个shared_ptr死了，引用计数减1变成1，当最后一个shared_ptr也死了，引用计数变为0，这个指针也就会被销毁内存被释放。</p>
<p>但是不要这样写！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="function">std::shared_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在unique_ptr中不直接调用new的原因是因为异常安全，而在shared_ptr中有所不同。因为shared_ptr需要分配另一块内存，叫做控制块，用来存储引用计数。如果使用new创建一个Entity然后传递给shared_ptr构造函数，那么它必须做两次内存分配：先做一次new Entity的分配，然后是shared_ptr的控制内存块的分配。使用make_shared就可以将两个步骤合起来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;	</span><br><span class="line">		std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shared_ptr可以被复制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;	</span><br><span class="line">		std::shared_ptr&lt;Entity&gt; entity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">		std::shared_ptr&lt;Entity&gt; e0 = sharedEntity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们更改一下main函数，创建两个作用域来演示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;<span class="comment">//作用域1</span></span><br><span class="line">		std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">		&#123;<span class="comment">//作用域2</span></span><br><span class="line">			std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">			e0 = sharedEntity;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时SharedEntity已经死亡，但是e0还存活（引用计数为1），所以这里没有调用析构函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里e0也死亡了（引用计数为0），此时调用析构函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单步调试，进入作用域1时输出<code>Created Entity</code>，此时出作用域2，并没有析构Entity，因为e0还存活，并且持有对该Entity的引用。出作用域1，输出<code>Destroyed Entity</code>，所有的引用此时都消失。</p>
<h2 id="弱指针weak-ptr"><a href="#弱指针weak-ptr" class="headerlink" title="弱指针weak_ptr"></a>弱指针weak_ptr</h2><p>将一个shared_ptr赋值给另一个shared_ptr时会增加引用计数，但是将一个shared_ptr赋值给一个weak_ptr时不会增加引用计数。这常用于：如果你不想要Entity的所有权，例如你在排序一个Entity列表，你不关心他们是否有效，只需要存储一个他们的引用，这时就可以使用weak_ptr。可以询问weak_ptr底层对象是否还存活，但它不会保持底层对象存活，因为它不会增加引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;<span class="comment">//作用域1</span></span><br><span class="line">		std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">		&#123;<span class="comment">//作用域2</span></span><br><span class="line">			std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">			e0 = sharedEntity; <span class="comment">// 弱指针不会引用计数</span></span><br><span class="line">		&#125;<span class="comment">//出作用域2的时候就调用了析构函数</span></span><br><span class="line">		<span class="comment">//此时weak_ptr为一个无效指针</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>综上，使用智能指针可以使内存管理自动化，防止忘记调用delete而造成内存泄露。优先选用unique_ptr，如需在作用域之间复制共享就使用shared_ptr。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>麦克纳姆轮运动学解算</title>
    <url>/posts/b6e9d4e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="麦克纳姆轮运动学解算"><a href="#麦克纳姆轮运动学解算" class="headerlink" title="麦克纳姆轮运动学解算"></a>麦克纳姆轮运动学解算</h1><h2 id="一、麦克纳姆轮介绍"><a href="#一、麦克纳姆轮介绍" class="headerlink" title="一、麦克纳姆轮介绍"></a>一、麦克纳姆轮介绍</h2><p>了解过Robomaster的同学都知道，RM战车所用的轮子均为麦克纳姆轮，这种轮子安装方式与普通轮子无异，可安装于平行轴上，但是麦克纳姆轮可以实现全向移动，即<strong>前后运动</strong>、<strong>水平移动</strong>、<strong>绕中心自转</strong>。正因为以上优点，许多工业上的全向移动平台都会应用这种轮子。缺点也有，就是不耐磨，需要定期更换。</p>
<p>麦克纳姆轮由两部分组成：<strong>轮毂</strong>和<strong>辊子</strong>，轮毂为轮子的主体，辊子为轮毂周围的类似椭球体的小轮子，轮毂和辊子都有自己的轴，且轮毂轴与辊子轴夹角为45°（可以为其他角度但45°角最为常见）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-1.png" alt="ML-1" style="zoom: 25%;"></p>
<p>麦轮的安装方式也有讲究，虽然都是同轴安装，但与普通轮子不同，麦轮分为左旋和右旋两种，在一个四轮底盘上需要用两个左旋和两个右旋。安装方式为O型，如图所示：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-2.png" alt="ML-2"></p>
<p>左图为安装后你看到的样子，右图为四个轮子与地面接触的辊子围成的形状，也就是“O形”</p>
<p><strong>这里的O形指的是与地面接触的辊子围成的形状噢，不要再问为什么左图看起来是个X了</strong></p>
<h2 id="二、麦克纳姆轮运动学模型"><a href="#二、麦克纳姆轮运动学模型" class="headerlink" title="二、麦克纳姆轮运动学模型"></a>二、麦克纳姆轮运动学模型</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><h4 id="1-1-坐标系统"><a href="#1-1-坐标系统" class="headerlink" title="1.1 坐标系统"></a>1.1 坐标系统</h4><p>在ROS机器人中，坐标系统使用右手定义</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-3.png" alt="ML-3"></p>
<p>对于ROS机器人，如果以它为坐标系的原点，那么</p>
<ul>
<li>x轴：前方</li>
<li>y轴：左方</li>
<li>z轴：上方</li>
</ul>
<p>如图所示：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-4.png" alt="ML-4"></p>
<p>除此之外，对于旋转运动，也使用右手定义：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-5.png" alt="ML-5" style="zoom:150%;"></p>
<p>根据<strong>右手定义</strong>，围绕 <strong>z轴正旋转</strong> 是 <strong>逆时针旋转</strong></p>
<h4 id="1-2-测量单位"><a href="#1-2-测量单位" class="headerlink" title="1.2 测量单位"></a>1.2 测量单位</h4><p>ROS使用公制 ：</p>
<ul>
<li>线速度：<code>m/s</code></li>
<li>角速度：<code>rad/s</code></li>
</ul>
<h4 id="1-3-轮子序号定义"><a href="#1-3-轮子序号定义" class="headerlink" title="1.3 轮子序号定义"></a>1.3 轮子序号定义</h4><p>左前<strong>1</strong> 右前<strong>2</strong></p>
<p>左后<strong>3</strong> 右后<strong>4</strong></p>
<h3 id="2-逆运动学解析"><a href="#2-逆运动学解析" class="headerlink" title="2. 逆运动学解析"></a>2. 逆运动学解析</h3><p>逆运动学模型（inverse kinematic model）得到的公式可以根据底盘的运动状态解算出四个轮子的速度。</p>
<h4 id="2-1-底盘运动的分解"><a href="#2-1-底盘运动的分解" class="headerlink" title="2.1 底盘运动的分解"></a>2.1 底盘运动的分解</h4><p>刚体在平面内的运动可以分解为三个独立分量：X轴平动、Y轴平动、yaw 轴自转。底盘的运动也可以分解为三个量：</p>
<p>如下图所示:</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-6.PNG" alt="ML-6"></p>
<ul>
<li>$v_{tx}$ 表示 X 轴运动的速度，即前后方向，定义向前为正；</li>
<li>$v_{ty}$ 表示 Y 轴运动的速度，即左右方向，定义向左为正；</li>
<li>$\overrightarrow{\omega}$ 表示 yaw 轴自转的角速度，定义逆时针为正。</li>
</ul>
<h4 id="2-2-计算轮子轴心位置的速度"><a href="#2-2-计算轮子轴心位置的速度" class="headerlink" title="2.2 计算轮子轴心位置的速度"></a>2.2 计算轮子轴心位置的速度</h4><p>如下图所示，以右前轮为例，蓝色的方框代表轮子，定义以下变量：</p>
<ul>
<li>$\overrightarrow{r}$为从底盘中心指向轮子轴心的矢量；</li>
<li>$\overrightarrow{v}$为轮子轴心的速度矢量；</li>
<li>$\overrightarrow{v_r}$为轮子轴心沿垂直于$\overrightarrow{r}$的方向（即切线方向）的速度分量；</li>
</ul>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-7.PNG" alt="ML-7" style="zoom: 67%;"></p>
<p>可以计算出：</p>
<script type="math/tex; mode=display">
\begin{align*}
\overrightarrow{v} &= \overrightarrow{v_t}+\overrightarrow{v_r} \\ &= \overrightarrow{v_t}+\overrightarrow{\omega}\times\overrightarrow{r}
\end{align*}</script><p>将$\overrightarrow{r}$分解为$r_x$和$r_y$，分别计算轮子轴心在X、Y轴的速度分量：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
v_x=v_{tx}+\omega\cdot{r_y} \\ 
v_y=v_{ty}+\omega\cdot{r_x}
\end{matrix}\right.</script><p>其他三个轮子同理</p>
<h4 id="2-3计算与地面接触的辊子速度"><a href="#2-3计算与地面接触的辊子速度" class="headerlink" title="2.3计算与地面接触的辊子速度"></a>2.3计算与地面接触的辊子速度</h4><p>由2.2算得的轮子轴心速度，可以分解为沿辊子轴方向的$\overrightarrow{v_\parallel}$ 和垂直辊子轴方向的 $\overrightarrow{v_\perp}$ ，如图所示</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-8.PNG" alt="ML-8" style="zoom:50%;"></p>
<p>其中$\overrightarrow{v_\perp}$用于让辊子空转，可以忽略</p>
<p>定义一个沿辊子方向的单位矢量$\hat{e}$，对于右前轮来说，$\hat{e}=\frac{1}{\sqrt{2}}\cdot\hat{i}+\frac{1}{\sqrt{2}}\cdot\hat{j}$</p>
<p>则沿轴线的速度为$\overrightarrow{v}$在$\hat{e}$方向的投影：</p>
<script type="math/tex; mode=display">
\begin{align*}
 \overrightarrow{v_\parallel}&=\overrightarrow{v}\cdot\hat{e} \\ 
 &=(v_x\cdot\hat{i}+v_y\cdot\hat{j})\cdot(\frac{1}{\sqrt{2}}\cdot\hat{i}+\frac{1}{\sqrt{2}}\cdot\hat{j}) \\ 
 &= \frac{1}{\sqrt{2}}v_x+\frac{1}{\sqrt{2}}v_y
\end{align*}</script><h4 id="2-4-计算轮子的转速（和地面接触点的线速度）"><a href="#2-4-计算轮子的转速（和地面接触点的线速度）" class="headerlink" title="2.4 计算轮子的转速（和地面接触点的线速度）"></a>2.4 计算轮子的转速（和地面接触点的线速度）</h4><p>如图所示，轮子转速为$v_w$</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ML-9.PNG" alt="ML-9" style="zoom:50%;"></p>
<p>由于辊子与轮轴呈45°角，则$v_\omega$可求得：</p>
<script type="math/tex; mode=display">
\begin{align*}
 v_w&=\frac{v_\parallel}{cos45^{\circ}} \\ 
 &=\sqrt{2}(\frac{1}{\sqrt{2}}v_x+\frac{1}{\sqrt{2}}v_y) \\ 
 &= v_x+v_y
\end{align*}</script><p>将2.2求出的$\left\{\begin{matrix}<br>v_x=v_{tx}+\omega\cdot{r_y} \\<br>v_y=v_{ty}+\omega\cdot{r_x}<br>\end{matrix}\right.$带入上式，可求出此轮的转速：</p>
<script type="math/tex; mode=display">
v_w=v_{tx}+v_{ty}+\omega(r_x+r_y)</script><p>结合以上四个步骤，可以根据底盘运动状态解算出四个轮子的转速：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
v_{w1}=v_{tx}-v_{ty}-\omega(r_x+r_y)\\ 
v_{w2}=v_{tx}+v_{ty}+\omega(r_x+r_y)\\ 
v_{w3}=v_{tx}+v_{ty}-\omega(r_x+r_y)\\ 
v_{w4}=v_{tx}-v_{ty}+\omega(r_x+r_y)
\end{matrix}\right.</script><p>以上方程组就是O形麦轮底盘的逆运动学模型。</p>
<h4 id="2-5-代码实现"><a href="#2-5-代码实现" class="headerlink" title="2.5 代码实现"></a>2.5 代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODER_RESOLUTION      1440.0   <span class="comment">//编码器分辨率, 轮子转一圈，编码器产生的脉冲数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHEEL_DIAMETER          0.058    <span class="comment">//轮子直径,单位：米</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D_X                     0.18     <span class="comment">//底盘Y轴上两轮中心的间距</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D_Y                     0.25     <span class="comment">//底盘X轴上两轮中心的间距</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_RATE                50       <span class="comment">//PID调节PWM值的频率</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> pulse_per_meter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> rx_plus_ry_cali = <span class="number">0.3</span>;</span><br><span class="line"><span class="keyword">double</span> angular_correction_factor = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> linear_correction_factor = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> angular_correction_factor = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数作用：运动学解析参数初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kinematics_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//轮子转动一圈，移动的距离为轮子的周长WHEEL_DIAMETER*3.1415926，编码器产生的脉冲信号为ENCODER_RESOLUTION。则电机编码器转一圈产生的脉冲信号除以轮子周长可得轮子前进1m的距离所对应编码器计数的变化</span></span><br><span class="line">    pulse_per_meter = (<span class="keyword">float</span>)(ENCODER_RESOLUTION/(WHEEL_DIAMETER*<span class="number">3.1415926</span>))/linear_correction_factor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> r_x = D_X/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> r_y = D_Y/<span class="number">2</span>;</span><br><span class="line">    rx_plus_ry_cali = (r_x + r_y)/angular_correction_factor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数作用：逆向运动学解析，底盘三轴速度--&gt;轮子速度</span></span><br><span class="line"><span class="comment">  * @输入：机器人三轴速度 m/s</span></span><br><span class="line"><span class="comment">  * @输出：电机应达到的目标速度（一个PID控制周期内，电机编码器计数值的变化）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kinematics_Inverse</span><span class="params">(<span class="keyword">int16_t</span>* input, <span class="keyword">int16_t</span>* output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> v_tx   = (<span class="keyword">float</span>)input[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">float</span> v_ty   = (<span class="keyword">float</span>)input[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">float</span> omega = (<span class="keyword">float</span>)input[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">float</span> v_w[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	v_w[<span class="number">0</span>] = v_tx - v_ty - (r_x + r_y)*omega;</span><br><span class="line">	v_w[<span class="number">1</span>] = v_tx + v_ty + (r_x + r_y)*omega;</span><br><span class="line">	v_w[<span class="number">2</span>] = v_tx + v_ty - (r_x + r_y)*omega;</span><br><span class="line">	v_w[<span class="number">3</span>] = v_tx - v_ty + (r_x + r_y)*omega;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算一个PID控制周期内，电机编码器计数值的变化</span></span><br><span class="line">	output[<span class="number">0</span>] = (<span class="keyword">int16_t</span>)(v_w[<span class="number">0</span>] * pulse_per_meter/PID_RATE);</span><br><span class="line">	output[<span class="number">1</span>] = (<span class="keyword">int16_t</span>)(v_w[<span class="number">1</span>] * pulse_per_meter/PID_RATE);</span><br><span class="line">	output[<span class="number">2</span>] = (<span class="keyword">int16_t</span>)(v_w[<span class="number">2</span>] * pulse_per_meter/PID_RATE);</span><br><span class="line">	output[<span class="number">3</span>] = (<span class="keyword">int16_t</span>)(v_w[<span class="number">3</span>] * pulse_per_meter/PID_RATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-正运动学解析"><a href="#3-正运动学解析" class="headerlink" title="3. 正运动学解析"></a>3. 正运动学解析</h3><h4 id="3-1-正运动学模型"><a href="#3-1-正运动学模型" class="headerlink" title="3.1 正运动学模型"></a>3.1 正运动学模型</h4><p>正运动学模型（forward kinematic model）让我们可以通过四个轮子的速度，计算出底盘的运动状态。可以直接根据逆运动学模型中的三个方程解出来，比如：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
v_{tx}=\frac{v_4+v_3}{2}\\ 
v_{ty}=\frac{v_3-v_1}{2}\\ 
\omega=\frac{v_2-v_3}{2(r_x+r_y)}
\end{matrix}\right.</script><p>转换为底盘坐标系下对时间求积分即为里程计变化量</p>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODER_MAX 32767        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODER_MIN -32768 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODER_LOW_WRAP  ((ENCODER_MAX - ENCODER_MIN)*0.3+ENCODER_MIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODER_HIGH_WRAP ((ENCODER_MAX - ENCODER_MIN)*0.7+ENCODER_MIN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量定义</span></span><br><span class="line"><span class="keyword">int32_t</span>  wheel_turns[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int32_t</span>  encoder_sum_current[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数功能：正向运动学解析，轮子编码值-&gt;底盘三轴里程计坐标</span></span><br><span class="line"><span class="comment">  * @输入：编码器累加值</span></span><br><span class="line"><span class="comment">  * @输出：三轴里程计 x y yaw</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kinematics_Forward</span><span class="params">(<span class="keyword">int16_t</span>* input, <span class="keyword">int16_t</span>* output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">double</span> dv_w_times_dt[<span class="number">4</span>]; <span class="comment">//轮子瞬时变化量dxw=dvw*dt</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">double</span> dv_t_times_dt[<span class="number">3</span>]; <span class="comment">//底盘瞬时变化量dxt=dvt*dt</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int16_t</span> encoder_sum[<span class="number">4</span>];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将左面轮子编码器累加值乘以-1，以计算前进的距离</span></span><br><span class="line">	encoder_sum[<span class="number">0</span>] = -input[<span class="number">0</span>];</span><br><span class="line">	encoder_sum[<span class="number">1</span>] = input[<span class="number">1</span>];</span><br><span class="line">	encoder_sum[<span class="number">2</span>] = -input[<span class="number">2</span>];</span><br><span class="line">	encoder_sum[<span class="number">3</span>] = input[<span class="number">3</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编码器计数溢出处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(encoder_sum[i] &lt; ENCODER_LOW_WRAP &amp;&amp; encoder_sum_current[i] &gt; ENCODER_HIGH_WRAP)</span><br><span class="line">			wheel_turns[i]++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(encoder_sum[i] &gt; ENCODER_HIGH_WRAP &amp;&amp; encoder_sum_current[i] &lt; ENCODER_LOW_WRAP)</span><br><span class="line">			wheel_turns[i]--;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			wheel_turns[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将编码器数值转化为前进的距离，单位m</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">	&#123;	</span><br><span class="line">		dv_w_times_dt[i] = <span class="number">1.0</span>*(encoder_sum[i] + wheel_turns[i]*(ENCODER_MAX-ENCODER_MIN)-encoder_sum_current[i])/pulse_per_meter;</span><br><span class="line">		encoder_sum_current[i] = encoder_sum[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//要计算坐标所以变回来</span></span><br><span class="line">	dv_w_times_dt[<span class="number">0</span>] = -dv_w_times_dt[<span class="number">0</span>];</span><br><span class="line">	dv_w_times_dt[<span class="number">1</span>] =  dv_w_times_dt[<span class="number">1</span>];</span><br><span class="line">	dv_w_times_dt[<span class="number">2</span>] = -dv_w_times_dt[<span class="number">2</span>];</span><br><span class="line">	dv_w_times_dt[<span class="number">3</span>] =  dv_w_times_dt[<span class="number">3</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算底盘坐标系(base_link)下x轴、y轴变化距离m与Yaw轴朝向变化rad 一段时间内的变化量</span></span><br><span class="line">	dv_t_times_dt[<span class="number">0</span>] = ( dv_w_times_dt[<span class="number">3</span>] + dv_w_times_dt[<span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">	dv_t_times_dt[<span class="number">1</span>] = ( dv_w_times_dt[<span class="number">2</span>] - dv_w_times_dt[<span class="number">0</span>])/<span class="number">2.0</span>;</span><br><span class="line">	dv_t_times_dt[<span class="number">2</span>] = ( dv_w_times_dt[<span class="number">1</span>] - dv_w_times_dt[<span class="number">2</span>])/(<span class="number">2</span>*wheel_track_cali);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//积分计算里程计坐标系(odom_frame)下的机器人X,Y,Yaw轴坐标</span></span><br><span class="line">	<span class="comment">//dx = ( vx*cos(theta) - vy*sin(theta) )*dt</span></span><br><span class="line">	<span class="comment">//dy = ( vx*sin(theta) + vy*cos(theta) )*dt</span></span><br><span class="line">	output[<span class="number">0</span>] += (<span class="keyword">int16_t</span>)(<span class="built_in">cos</span>((<span class="keyword">double</span>)output[<span class="number">2</span>])*dv_t_times_dt[<span class="number">0</span>] - <span class="built_in">sin</span>((<span class="keyword">double</span>)output[<span class="number">2</span>])*dv_t_times_dt[<span class="number">1</span>]);</span><br><span class="line">	output[<span class="number">1</span>] += (<span class="keyword">int16_t</span>)(<span class="built_in">sin</span>((<span class="keyword">double</span>)output[<span class="number">2</span>])*dv_t_times_dt[<span class="number">0</span>] + <span class="built_in">cos</span>((<span class="keyword">double</span>)output[<span class="number">2</span>])*dv_t_times_dt[<span class="number">1</span>]);</span><br><span class="line">	output[<span class="number">2</span>] += (<span class="keyword">int16_t</span>)(dv_t_times_dt[<span class="number">2</span>]*<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//Yaw轴坐标变化范围控制-2Π -&gt; 2Π</span></span><br><span class="line">	<span class="keyword">if</span>(output[<span class="number">2</span>] &gt; PI)</span><br><span class="line">		output[<span class="number">2</span>] -= <span class="number">2</span>*PI;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(output[<span class="number">2</span>] &lt; -PI)</span><br><span class="line">		output[<span class="number">2</span>] += <span class="number">2</span>*PI;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//发送机器人X轴y轴Yaw轴瞬时变化量，在ROS端除以时间</span></span><br><span class="line">	output[<span class="number">3</span>] = (<span class="keyword">int16_t</span>)(dv_t_times_dt[<span class="number">0</span>]);</span><br><span class="line">	output[<span class="number">4</span>] = (<span class="keyword">int16_t</span>)(dv_t_times_dt[<span class="number">1</span>]);</span><br><span class="line">	output[<span class="number">5</span>] = (<span class="keyword">int16_t</span>)(dv_t_times_dt[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>【1】<a href="https://zhuanlan.zhihu.com/p/20282234">https://zhuanlan.zhihu.com/p/20282234</a></p>
<p>【2】<a href="https://blog.csdn.net/shixiaolu63/article/details/78496457">https://blog.csdn.net/shixiaolu63/article/details/78496457</a></p>
]]></content>
      <categories>
        <category>ROS机器人学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——5C++工作原理</title>
    <url>/posts/a6a7cea1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——5C-工作原理"><a href="#深入学习C-——5C-工作原理" class="headerlink" title="深入学习C++——5C++工作原理"></a>深入学习C++——5C++工作原理</h1><h2 id="分析main-cpp"><a href="#分析main-cpp" class="headerlink" title="分析main.cpp"></a>分析main.cpp</h2><p>对于一个后缀为<code>.cpp</code>的C++源文件，先来分析一下文件的结构</p>
<p><code>#</code>符号之后的都是预处理语句（叫预处理的原因为它实际上在编译之前就发生了）。<code>#include</code>的含义是找到&lt;&gt;中的文件，然后将该文件中的所有内容拷贝到现在的文件内。这些被包含的文件称为头文件，在C++中通常以<code>.hpp</code>为后缀。</p>
<p>来看一个预处理的神奇操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*file2.hpp*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*file1.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;file2.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这个程序能否成功编译？可以看到main函数是没有右花括号的，但是<code>#include &quot;file2.hpp&quot;</code>这一句将file2中的文件原封不动拷贝到了当前的地方，即补上了一个花括号，所以可以编译成功。</p>
<p>除了#include，常用的预处理命令还有<code>#if #endif</code>，这一对是这么用的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int a = 1;会被编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 1;不会被编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来是main函数。<code>main</code>函数是程序的入口，当运行程序时计算机从这个函数开始执行代码。在这里，main函数的返回类型是int，但是代码中没有返回任何东西，这是因为main函数是特殊的，它不一定需要返回值。没有写return进行返回的话，它会默认返回了0。注意，这只对main函数适用！</p>
<p><code>&lt;&lt;</code> 符号叫做重载运算符，可以理解为一个函数。</p>
<h2 id="代码如何编译为二进制文件"><a href="#代码如何编译为二进制文件" class="headerlink" title="代码如何编译为二进制文件"></a>代码如何编译为二进制文件</h2><p>项目中的每一个cpp文件都会被编译，但是头文件不会被编译，头文件的内容在预处理时全部拷贝到了到了cpp中。每一个cpp文件都被编译为object file（目标文件），我们需要将这些文件合并成一个执行文件，链接（Link）会将所有的目标文件合并成一个.exe文件。</p>
<p>如果在一个文件（比如main.cpp）中使用了另一个文件中的函数，编译会报错，需要在main.cpp中声明那个函数的存在。声明表示这个符号、函数是存在的，去掉函数的结构体后加分号就是函数的声明。声明与定义不同，定义是说明这个函数到底是什么，是函数的函数体。<code>void Log(const char* message);</code>这就是一个声明，其实<code>void Log(const char*);</code>这样写也可以，但习惯上使用前者，会更加清晰。在构建整个项目时，所有.cpp文件都会被编译，链接器会找到正确的Log函数的定义在哪里，如果找不到定义，会报链接错误。</p>
<p>关于编译器和链接器会单独讲解</p>
<hr>
<p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p>
<p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p>
<p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——7链接器</title>
    <url>/posts/9823ae96.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——7链接器"><a href="#深入学习C-——7链接器" class="headerlink" title="深入学习C++——7链接器"></a>深入学习C++——7链接器</h1><p>从文本形式的源文件到可执行文件中间其实经过了编译和链接两个步骤，本文来讨论一下C++链接器是如何工作的。</p>
<h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><p>当我们编译好源文件，我们需要通过一个叫做链接的过程。链接的任务是找到每个符号和函数所在的地方，并把它们链接起来。多个翻译单元（一个CPP文件可以理解为一个翻译单元）之间并不互通，我们需要一种方法把这些文件连接起来成一个项目。即使只有一个翻译单元，也需要将main函数连接起来，这就是链接器的主要目的和要做的事情。</p>
<h2 id="一些常见的链接错误"><a href="#一些常见的链接错误" class="headerlink" title="一些常见的链接错误"></a>一些常见的链接错误</h2><h3 id="未解决的外部符号"><a href="#未解决的外部符号" class="headerlink" title="未解决的外部符号"></a>未解决的外部符号</h3><p>当链接器找不到确切定义时会发生。来看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，Multiply函数没有被任何函数调用，其中的Log函数虽然被声明了但是并没有并定义。这样依然会报错。虽然我们没有使用Multiply函数，但是在技术上来讲，我们有可能会用到Log函数，所以链接器需要链接到它，所以会报错。但是如果使用static将Multiply函数限制在该文件中使用<code>static void Multiply(int a, int b)</code>，由于我们没有使用该函数，所以不再报错。</p>
<p>如果一个函数的声明和定义中的输入和返回的数据类型不对应，也会报错。</p>
<h3 id="有重复的符号"><a href="#有重复的符号" class="headerlink" title="有重复的符号"></a>有重复的符号</h3><p>如果我们的函数或变量具有相同的名字或签名，链接器会不知道该链接哪一个。即使没有申明，两个相同的函数放在不同的文件中，依然会报错。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，如果一个函数需要在其它文件中使用，则要将函数的定义写在cpp中，然后在对应的hpp文件中写上该函数的声明，最后在需要用它的文件中#include这个hpp文件即可避免链接错误。</p>
<hr>
<p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p>
<p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p>
<p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——6编译器</title>
    <url>/posts/dac51109.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——6编译器"><a href="#深入学习C-——6编译器" class="headerlink" title="深入学习C++——6编译器"></a>深入学习C++——6编译器</h1><p>从文本形式的源文件到可执行文件中间其实经过了编译和链接两个步骤，本文来讨论一下C++编译器是如何工作的。</p>
<p>C++编译器只负责一件事，将文本文件（我们写的代码）转换成称为目标文件的中间格式。这些目标文件可以传递到链接，链接可以做它所有要链接的事情。</p>
<p>编译器在生成这些目标文件时，首先会预处理代码，这意味着所有的预处理器语句都会先处理。然后进行记号化和解析，将文本转换为编译器真正能够理解和推理的格式。这创建了所谓的抽象语法树。语法树一旦被创建，编译器就可以开始实际生成代码。目标文件中都是机器码，如果进行反汇编，就可以看到相对应的汇编语句。</p>
<hr>
<p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p>
<p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p>
<p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习C++——34关键词const</title>
    <url>/posts/4307fde0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——34关键词const"><a href="#深入学习C-——34关键词const" class="headerlink" title="深入学习C++——34关键词const"></a>深入学习C++——34关键词const</h1><p>const是一种“伪”关键词，他不像void int，const对代码的生成不会造成什么影响。它类似于private、public这样的关键词，它是对开发人员写代码强制特定的规则。const是你做出的承诺，它承诺某些东西将是不变的。（这种承诺是可以打破的，你是否遵守承诺取决于你自己，但是请遵守你自己的承诺）</p>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>下面演示const最基础的应用场景，const在程序中一般修饰一个需要保持不变的数字，比如<code>MAX_AGE</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line">MAX_AGE = <span class="number">100</span>; <span class="comment">//正确，a的值可以被修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line">MAX_AGE = <span class="number">100</span>; <span class="comment">//错误，const常量不能被修改</span></span><br></pre></td></tr></table></figure>
<h2 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h2><p>再来讨论一下指针的问题。首先声明一个未被const修饰的整形指针a：（定义<code>int MAX_AGE = 90;</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*a = <span class="number">2</span>;<span class="comment">//可以改变指针指向的内容</span></span><br><span class="line">a = &amp;MAX_AGE;<span class="comment">//可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *a &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure>
<p>此时在<code>*</code>前加上<code>const</code>，就变成了<strong>常量指针</strong>，意味着不能修改指针指向的内容：</p>
<p>常量指针有两种写法，<code>const int *</code>和<code>int const *</code>都是可以的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*b = <span class="number">2</span>;<span class="comment">//错误。不可以改变指针指向的内容</span></span><br><span class="line">b = &amp;MAX_AGE;<span class="comment">//可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *b &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure>
<p>如果在<code>*</code>后加上<code>const</code>，就变成了<strong>指针常量</strong>，意味着指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化：</p>
<p>指针常量只能写成<code>int * const</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*c = <span class="number">2</span>;<span class="comment">//可以改变指针指向的内容</span></span><br><span class="line">c = &amp;MAX_AGE;<span class="comment">//错误。不可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *c &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure>
<p>同理，如果写成<code>const int* const d = new int;</code>，即意味着不能改变指针指向的内容，也不能改变指针变量指向的地址。</p>
<h2 id="类内方法中使用const"><a href="#类内方法中使用const" class="headerlink" title="类内方法中使用const"></a>类内方法中使用const</h2><p>在类中的方法名后加上const，表示方法不会修改任何实际的类，因此不能修改类成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_x, m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        m_x = <span class="number">2</span>;<span class="comment">//错误，不能修改类成员变量</span></span><br><span class="line">		<span class="keyword">return</span> m_x;<span class="comment">//只能读不能写</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假如此时有一个函数，使用了常量引用，它保证了函数内不会对这个类做任何的修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但此时将<code>GetX()</code>方法后的<code>const</code>去掉，上面函数内就不能调用GetX了。因为GetX函数已经不能保证它不会写入Entity了。<strong>常对象只能调用常函数</strong>。所以我们常常会见到函数的两个版本，此时常对象就会调用带有const的那个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所诉，如果你的方法实际上没有修改类或者他们不应该修改类，那就把他们标记成const。否则在有常量引用的情况下就用不了你的方法了。</p>
<hr>
<p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p>
<p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p>
<p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu20.04安装OpenCV并配置Clion工程</title>
    <url>/posts/eb0a41f8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Ubuntu20-04安装OpenCV并配置Clion工程"><a href="#Ubuntu20-04安装OpenCV并配置Clion工程" class="headerlink" title="Ubuntu20.04安装OpenCV并配置Clion工程"></a>Ubuntu20.04安装OpenCV并配置Clion工程</h1><h2 id="1-OpenCV安装"><a href="#1-OpenCV安装" class="headerlink" title="1 OpenCV安装"></a>1 OpenCV安装</h2><h3 id="1-1-二进制安装"><a href="#1-1-二进制安装" class="headerlink" title="1.1 二进制安装"></a>1.1 二进制安装</h3><p>Ubuntu20.04支持apt二进制安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libopencv-dev python3-opencv</span><br></pre></td></tr></table></figure>
<p>查看版本号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import cv2; print(cv2.__version__)&quot;</span></span><br></pre></td></tr></table></figure>
<p>安装成功返回<code>4.2.0</code></p>
<h3 id="1-2-源码安装"><a href="#1-2-源码安装" class="headerlink" title="1.2 源码安装"></a>1.2 源码安装</h3><h4 id="1-2-1-安装编译环境和依赖"><a href="#1-2-1-安装编译环境和依赖" class="headerlink" title="1.2.1 安装编译环境和依赖"></a>1.2.1 安装编译环境和依赖</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential cmake git pkg-config libgtk-3-dev \</span><br><span class="line">    libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \</span><br><span class="line">    libxvidcore-dev libx264-dev libjpeg-dev libpng-dev libtiff-dev \</span><br><span class="line">    gfortran openexr libatlas-base-dev python3-dev python3-numpy \</span><br><span class="line">    libtbb2 libtbb-dev libdc1394-22-dev libopenexr-dev \</span><br><span class="line">    libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-Clone最新的OpenCV源码"><a href="#1-2-2-Clone最新的OpenCV源码" class="headerlink" title="1.2.2 Clone最新的OpenCV源码"></a>1.2.2 Clone最新的OpenCV源码</h4><p>截止2022.02.27，GitHub更新到OpenCV4.5.5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/opencv_build &amp;&amp; <span class="built_in">cd</span> ~/opencv_build</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-Cmake编译"><a href="#1-2-3-Cmake编译" class="headerlink" title="1.2.3 Cmake编译"></a>1.2.3 Cmake编译</h4><h5 id="1-2-3-1-创建临时目录"><a href="#1-2-3-1-创建临时目录" class="headerlink" title="1.2.3.1 创建临时目录"></a>1.2.3.1 创建临时目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv_build/opencv</span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-2-设置编译选项"><a href="#1-2-3-2-设置编译选项" class="headerlink" title="1.2.3.2 设置编译选项"></a>1.2.3.2 设置编译选项</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=ON \</span><br><span class="line">    -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">    -D OPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">    -D OPENCV_EXTRA_MODULES_PATH=~/opencv_build/opencv_contrib/modules \</span><br><span class="line">    -D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure>
<p>正常应该出现以下提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/vagrant/opencv_build/opencv/build</span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-3-开始Cmake编译"><a href="#1-2-3-3-开始Cmake编译" class="headerlink" title="1.2.3.3 开始Cmake编译"></a>1.2.3.3 开始Cmake编译</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>注：j后面的数字为处理器内核数，可以使用<code>nproc</code>来查询</p>
<h4 id="1-2-4-安装OpenCV"><a href="#1-2-4-安装OpenCV" class="headerlink" title="1.2.4 安装OpenCV"></a>1.2.4 安装OpenCV</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-验证安装"><a href="#1-2-5-验证安装" class="headerlink" title="1.2.5 验证安装"></a>1.2.5 验证安装</h4><p>C++</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config --modversion opencv4</span><br></pre></td></tr></table></figure>
<p>返回<code>4.3.0</code></p>
<p>Python</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import cv2; print(cv2.__version__)&quot;</span></span><br></pre></td></tr></table></figure>
<p>返回<code>4.3.0-dev</code></p>
<h2 id="2-Clion工程配置"><a href="#2-Clion工程配置" class="headerlink" title="2 Clion工程配置"></a>2 Clion工程配置</h2><p>新建工程，本文选择C++11标准</p>
<p>编辑<code>CmakeList.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenCV_Test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(OpenCV_Test main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(OpenCV_Test <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>到运行调试配置中修改工作目录为<code>$ProjectFileDir$</code>（或手动输入当前main.cpp所在目录）</p>
<p>在工作目录下放置一个图片命名为<code>test.jpg</code></p>
<p>编写测试程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;OpenCV-Test&quot;</span>,image);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，若配置无误即可显示出图片。</p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习笔记</title>
    <url>/posts/404e593e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><h2 id="1-导入图像视频和网络摄像头"><a href="#1-导入图像视频和网络摄像头" class="headerlink" title="1 导入图像视频和网络摄像头"></a>1 导入图像视频和网络摄像头</h2><p>首先包含三个常用的头文件和IO库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>然后需要使用命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-图像"><a href="#1-1-图像" class="headerlink" title="1.1 图像"></a>1.1 图像</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先需要定义图像文件路径，使用string类型来存储</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">    <span class="comment">// 用Mat类型读取图像</span></span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;图像&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 使用waitKey进行一个延时，否则图像会立即关闭。0为无穷大，即不会关闭。</span></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-视频"><a href="#1-2-视频" class="headerlink" title="1.2 视频"></a>1.2 视频</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先需要定义视频文件路径，使用string类型来存储</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_video.mp4&quot;</span>;</span><br><span class="line">	<span class="comment">// 构造VideoCapture类型对象</span></span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line">	<span class="comment">// 单帧图像</span></span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="comment">// 对于视频来说需要捕获所有帧并显示，所以需要while循环。</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 读取一帧图像</span></span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		<span class="comment">// 显示图像</span></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;视频&quot;</span>, img);</span><br><span class="line">		<span class="comment">// 这时需要延时，否则视频非常快</span></span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视频结束后会抛出错误（无法读取文件），原因为视频结束后没有图像送入img所以报错。</p>
<h3 id="1-3-摄像头"><a href="#1-3-摄像头" class="headerlink" title="1.3 摄像头"></a>1.3 摄像头</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 摄像头不需要路径，需要输入相机的ID号，剩下的和读取视频一样</span></span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;摄像头&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-基本函数"><a href="#2-基本函数" class="headerlink" title="2 基本函数"></a>2 基本函数</h2><p>前文包含的头文件<code>#include &lt;opencv2/imgproc.hpp&gt;</code>就是图像处理的头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	Mat imgGray;</span><br><span class="line">	<span class="comment">// “convert”，即为转换图像的颜色空间，这里将彩色图想转换为灰度图像</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line"></span><br><span class="line">	Mat imgBlur;</span><br><span class="line">	<span class="comment">// 添加高斯模糊(7*7)</span></span><br><span class="line">	<span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line"></span><br><span class="line">	Mat imgCanny;</span><br><span class="line">	<span class="comment">// 边缘检测，通常在边缘检测前对图像进行一次高斯模糊(可以自行对比有什么区别)</span></span><br><span class="line">	<span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀</span></span><br><span class="line">	Mat imgDil, imgErode;</span><br><span class="line">	<span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgDil);</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Erode&quot;</span>, imgErode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122257889.png" alt="image-20220309122257889"></p>
<h2 id="3-对图像进行伸缩和剪裁"><a href="#3-对图像进行伸缩和剪裁" class="headerlink" title="3 对图像进行伸缩和剪裁"></a>3 对图像进行伸缩和剪裁</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 伸缩</span></span><br><span class="line">	Mat imgResize;</span><br><span class="line">	<span class="comment">// 使用size方法查看图像尺寸</span></span><br><span class="line">	cout &lt;&lt; img.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 可以调整成具体的大小</span></span><br><span class="line">	<span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">400</span>,<span class="number">600</span>));</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Resize Size()&quot;</span>, imgResize);</span><br><span class="line">	<span class="comment">// 也可以调整缩放比例fxfy</span></span><br><span class="line">	<span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(),<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Resize &quot;</span>, imgResize);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 裁剪</span></span><br><span class="line">	Mat imgCrop;</span><br><span class="line">	<span class="comment">// 矩形数据类型，前两个参数为剪裁起点（左上角 x = 0, y = 0），后两个参数为宽和高</span></span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(<span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 使用刚刚定义的矩形对图像进行裁剪</span></span><br><span class="line">	imgCrop = <span class="built_in">img</span>(roi);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122213509.png" alt="image-20220309122213509"></p>
<h2 id="4-绘制形状和文字"><a href="#4-绘制形状和文字" class="headerlink" title="4 绘制形状和文字"></a>4 绘制形状和文字</h2><p>下文中，使用Point()定义一个点，使用Scalar()定义一个标量（颜色）</p>
<p>绘制形状和文字所用函数中最后两个参数均为颜色和厚度(FILLED为填充)，不再重复说明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个空白图像，512*512大小，8位3通道(CV_8UC3)，白色(255,255,255)</span></span><br><span class="line">	<span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">512</span>, <span class="number">512</span>, CV_8UC3, Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画圆 传入圆心，半径</span></span><br><span class="line">	<span class="built_in">circle</span>(img, <span class="built_in">Point</span>(<span class="number">256</span>, <span class="number">256</span>), <span class="number">155</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),FILLED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画矩形 传入左上角与右下角点的坐标</span></span><br><span class="line">	<span class="built_in">rectangle</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">226</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">286</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画线 传入起点和终点的坐标</span></span><br><span class="line">	<span class="built_in">line</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">296</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">296</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制文字 传入文字，左上角坐标，字体，比例</span></span><br><span class="line">	<span class="built_in">putText</span>(img, <span class="string">&quot;OpenCV Learning&quot;</span>, <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">262</span>), FONT_HERSHEY_COMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122144678.png" alt="image-20220309122144678"></p>
<h2 id="5-透视变换"><a href="#5-透视变换" class="headerlink" title="5 透视变换"></a>5 透视变换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/cards.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以使用画图工具获取到点坐标，使用Point2f创建浮点数</span></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>,<span class="number">142</span>&#125;,&#123;<span class="number">771</span>,<span class="number">190</span>&#125;,&#123;<span class="number">405</span>,<span class="number">395</span>&#125;,&#123;<span class="number">674</span>,<span class="number">457</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 变换后的大小</span></span><br><span class="line">	<span class="keyword">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建变换矩阵</span></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 透视变换</span></span><br><span class="line">	Mat imgWarp;</span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Size</span>(w, h));</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示四个顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，成功将图形矫正</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122100872.png" alt="image-20220309122100872"></p>
<h2 id="6-颜色识别"><a href="#6-颜色识别" class="headerlink" title="6 颜色识别"></a>6 颜色识别</h2><p>颜色识别需要设定选取好的hsv三个通道的最大值和最小值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/lambo.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">	Mat imgHSV;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义选取好的六个值</span></span><br><span class="line">	<span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line">	<span class="keyword">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line">	<span class="comment">// 定义下限和上限</span></span><br><span class="line">	<span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">	<span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建遮罩</span></span><br><span class="line">	Mat mask;</span><br><span class="line">	<span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行查看效果</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121922828.png" alt="image-20220309121922828"></p>
<p>上面的值可以使用Trackbar试出来，替换一张图片再次尝试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">	Mat imgHSV;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设定初始值</span></span><br><span class="line">	<span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">0</span>, vmin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> hmax = <span class="number">179</span>, smax = <span class="number">255</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建遮罩</span></span><br><span class="line">	Mat mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义窗口名</span></span><br><span class="line">	<span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line">	<span class="comment">// 创建Trackbar</span></span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">	<span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">		<span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">		<span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始值是这样的</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121750288.png" alt="image-20220309121750288"></p>
<p>因为这张图里都是确定的颜色，所以只需要拖动前两行即可筛选出想要的颜色</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121842503.png" alt="image-20220309121842503"></p>
<h2 id="7-形状识别"><a href="#7-形状识别" class="headerlink" title="7 形状识别"></a>7 形状识别</h2><p>本节将学习如何检测圆形、正方形、矩形、三角形这些形状，和识别出图像中的轮廓</p>
<h3 id="7-1-预处理"><a href="#7-1-预处理" class="headerlink" title="7.1 预处理"></a>7.1 预处理</h3><p>首先对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。详见</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在识别形状之前需要对图片进行一系列的预处理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 灰度处理</span></span><br><span class="line">	Mat imgGray;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯模糊</span></span><br><span class="line">	Mat imgBlur;</span><br><span class="line">	<span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边缘检测</span></span><br><span class="line">	Mat imgCanny;</span><br><span class="line">	<span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 膨胀和腐蚀</span></span><br><span class="line">	Mat imgDil, imgErode;</span><br><span class="line">	<span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//	// 在这里进行边缘检测</span></span><br><span class="line"><span class="comment">//	getContours(imgDil,img);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Dil&quot;</span>, imgDil);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从处理后的图像可以看到，单单使用边缘检测，三角形的轮廓线断断续续，会对之后的识别造成影响。经过膨胀之后的图像轮廓线是实线，边缘特性更好。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309144348598.png" alt="image-20220309144348598"></p>
<p>关闭主函数中无用的输出，只留下<code>imshow(&quot;Image&quot;, img);</code>，然后去除<code>getContours(imgDil,img);</code>的注释，再进行下一步。</p>
<h3 id="7-2-找到轮廓"><a href="#7-2-找到轮廓" class="headerlink" title="7.2 找到轮廓"></a>7.2 找到轮廓</h3><p>根据边缘找到轮廓</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment">	 * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment">	 * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 找到轮廓</span></span><br><span class="line"><span class="comment">	 * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment">	 * 		取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment">	 * 		取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment">	 * 		取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment">	 * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours</span></span><br><span class="line"><span class="comment">	 * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">drawContours</span>(img_output, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，图像轮廓被正确地识别出来了。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309134724054.png" alt="image-20220309134724054"></p>
<h3 id="7-3-去除噪声"><a href="#7-3-去除噪声" class="headerlink" title="7.3 去除噪声"></a>7.3 去除噪声</h3><p>假设图像中最小的黑色圆圈为噪声，我们要将其滤除，所以需要判断轮廓大小并对其筛选。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设图像中有噪声，需要将其过滤</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//检测轮廓大小</span></span><br><span class="line">		<span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		cout &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">drawContours</span>(img_output, contours, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，黑色噪声成功被滤除</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309135058081.png" alt="image-20220309135058081"></p>
<h3 id="7-4-识别形状"><a href="#7-4-识别形状" class="headerlink" title="7.4 识别形状"></a>7.4 识别形状</h3><p>下一步我们要找到这些轮廓的角点，并对角点的数量进行判断，例如三角形就是3，四边形就是4，圆形可能七八个，并同时绘制出边界框与形状名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">	<span class="comment">// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//	drawContours(img_output, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义图形形状字符串</span></span><br><span class="line">	string object_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line">			<span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">			cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 找出边界框</span></span><br><span class="line">			bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 通过判断角点的数量来确定是什么形状</span></span><br><span class="line">			<span class="keyword">int</span> object_corners = (<span class="keyword">int</span>)contours_corners[i].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span>(object_corners == <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				object_type = <span class="string">&quot;Triangle&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(object_corners == <span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 通过计算宽高比来区分正方形和矩形</span></span><br><span class="line">				<span class="keyword">float</span> aspect_ratio = (<span class="keyword">float</span>)bounding_box[i].width / (<span class="keyword">float</span>)bounding_box[i].height;</span><br><span class="line">				cout &lt;&lt; aspect_ratio &lt;&lt; endl;</span><br><span class="line">				<span class="comment">// 宽高比在0.95~1.05范围内算作正方形</span></span><br><span class="line">				<span class="keyword">if</span> (aspect_ratio &gt; <span class="number">0.95</span> &amp;&amp; aspect_ratio &lt; <span class="number">1.05</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					object_type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 其余的算作矩形</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					object_type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(object_corners &gt; <span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				object_type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 只绘制角点之间的边框线</span></span><br><span class="line">			<span class="built_in">drawContours</span>(img_output, contours_corners, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">			<span class="comment">// 绘制矩形，bounding_box[i].tl()左上角，bounding_box[i].br()右下角</span></span><br><span class="line">			<span class="built_in">rectangle</span>(img_output, bounding_box[i].<span class="built_in">tl</span>(), bounding_box[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">5</span>);</span><br><span class="line">			<span class="comment">// 绘制文字（什么形状），绘制在边框的左上角再往上5像素</span></span><br><span class="line">			<span class="built_in">putText</span>(img_output, object_type, <span class="built_in">Point</span>(bounding_box[i].x, bounding_box[i].y - <span class="number">5</span> ), FONT_HERSHEY_PLAIN, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，不同形状的物体被成功识别出。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309143927287.png" alt="image-20220309143927287"></p>
<h2 id="8-人脸检测"><a href="#8-人脸检测" class="headerlink" title="8 人脸检测"></a>8 人脸检测</h2><p>人脸检测需要包含<code>#include &lt;opencv2/objdetect.hpp&gt;</code>头文件</p>
<p>使用OpenCV自带的Haar特征分类器进行检测。Haar特征分类器就是一个XML文件，该文件中会描述人体各个部位的Haar特征值。包括人脸、眼睛、嘴唇等等。通常被放置在一个叫haarcascades的目录下（全盘搜索一下就能找到），有以下这些：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309152132992.png" alt="image-20220309152132992"></p>
<p>根据命名可以知道各个分类器的用途。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/face.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写级联分类器</span></span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	<span class="comment">// 加载训练好的模型（族特征数据库）这里的路径请自行修改</span></span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个矩形向量</span></span><br><span class="line">	vector&lt;Rect&gt; faces;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 族检测算法</span></span><br><span class="line"><span class="comment">	 * 参数1：image--待检测图片，一般为灰度图像加快检测速度；</span></span><br><span class="line"><span class="comment">	 * 参数2：objects--被检测物体的矩形框向量组；</span></span><br><span class="line"><span class="comment">	 * 参数3：scaleFactor--表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%;</span></span><br><span class="line"><span class="comment">	 * 参数4：minNeighbors--表示构成检测目标的相邻矩形的最小个数(默认为3个)。</span></span><br><span class="line"><span class="comment">	 * 		如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。</span></span><br><span class="line"><span class="comment">	 * 		如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，</span></span><br><span class="line"><span class="comment">	 * 		这种设定值一般用在用户自定义对检测结果的组合程序上；</span></span><br><span class="line"><span class="comment">	 * 参数5：flags--要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING</span></span><br><span class="line"><span class="comment">	 * 		如果设置为CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域，因此这些区域通常不会是人脸所在区域；</span></span><br><span class="line"><span class="comment">	 * 参数6、7：minSize和maxSize用来限制得到的目标区域的范围。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在脸四周画出矩形</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行可以看到成功检测到人脸</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309153539038.png" alt="image-20220309153539038"></p>
<p>同样地，可以对视频流进行同样的处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">		vector&lt;Rect&gt; faces;</span><br><span class="line">		faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面演示三个应用</p>
<h2 id="应用1-空间绘图"><a href="#应用1-空间绘图" class="headerlink" title="应用1 空间绘图"></a>应用1 空间绘图</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////  Project 1 - 虚拟绘图 //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints;  <span class="comment">// to store all points</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////  颜色定义 ////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用前面讲过的程序提取颜色</span></span><br><span class="line"><span class="comment">// hmin, smin, vmin hmax, smax, vmax</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; myColors&#123; &#123;<span class="number">95</span>,<span class="number">22</span>,<span class="number">49</span>,<span class="number">139</span>,<span class="number">138</span>,<span class="number">92</span>&#125;, <span class="comment">// Green</span></span><br><span class="line">							  &#123;<span class="number">144</span>,<span class="number">76</span>,<span class="number">63</span>,<span class="number">179</span>,<span class="number">166</span>,<span class="number">154</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line">vector&lt;Scalar&gt; myColorValues&#123; &#123;<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>&#125;,		<span class="comment">// Green</span></span><br><span class="line">							  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">getContours</span><span class="params">(Mat img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义笔头位置</span></span><br><span class="line">	<span class="function">Point <span class="title">myPoint</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">			cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 设定笔头位置为设定点</span></span><br><span class="line">			myPoint.x = bounding_box[i].x + bounding_box[i].width / <span class="number">2</span>;</span><br><span class="line">			myPoint.y = bounding_box[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//			// 显示角和边界框</span></span><br><span class="line"><span class="comment">//			drawContours(img, contours_corners, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//			rectangle(img, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> myPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findColor</span>(Mat img)</span><br><span class="line">&#123;</span><br><span class="line">	Mat imgHSV;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myColors.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Scalar <span class="title">lower</span><span class="params">(myColors[i][<span class="number">0</span>], myColors[i][<span class="number">1</span>], myColors[i][<span class="number">2</span>])</span></span>;</span><br><span class="line">		<span class="function">Scalar <span class="title">upper</span><span class="params">(myColors[i][<span class="number">3</span>], myColors[i][<span class="number">4</span>], myColors[i][<span class="number">5</span>])</span></span>;</span><br><span class="line">		Mat mask;</span><br><span class="line">		<span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="built_in">to_string</span>(i), mask);</span><br><span class="line">		Point myPoint = <span class="built_in">getContours</span>(mask);</span><br><span class="line">		<span class="keyword">if</span> (myPoint.x != <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 每个myPoint都有三个值，xy和颜色序号</span></span><br><span class="line">			newPoints.<span class="built_in">push_back</span>(&#123; myPoint.x,myPoint.y,i &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawOnCanvas</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newPoints.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(img, <span class="built_in">Point</span>(newPoints[i][<span class="number">0</span>],newPoints[i][<span class="number">1</span>]), <span class="number">10</span>, myColorValues[newPoints[i][<span class="number">2</span>]], FILLED);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">	cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		newPoints = <span class="built_in">findColor</span>(img);</span><br><span class="line">		<span class="built_in">drawOnCanvas</span>(newPoints, myColorValues);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-应用2-文章扫描"><a href="#10-应用2-文章扫描" class="headerlink" title="10 应用2 文章扫描"></a>10 应用2 文章扫描</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 2 - Document Scanner  //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat imgOriginal, imgGray, imgBlur, imgCanny, imgThre, imgDil, imgErode, imgWarp, imgCrop;</span><br><span class="line">vector&lt;Point&gt; initialPoints,docPoints;</span><br><span class="line"><span class="keyword">float</span> w = <span class="number">420</span>, h = <span class="number">596</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">preProcessing</span><span class="params">(Mat img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line">	<span class="comment">//erode(imgDil, imgErode, kernel);</span></span><br><span class="line">	<span class="keyword">return</span> imgDil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">getContours</span><span class="params">(Mat image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">findContours</span>(image, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">	<span class="comment">//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	vector&lt;Point&gt; biggest;</span><br><span class="line">	<span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		string objectType;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (area &gt; maxArea &amp;&amp; conPoly[i].<span class="built_in">size</span>()==<span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">				biggest = &#123; conPoly[i][<span class="number">0</span>],conPoly[i][<span class="number">1</span>] ,conPoly[i][<span class="number">2</span>] ,conPoly[i][<span class="number">3</span>] &#125;;</span><br><span class="line">				maxArea = area;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line">			<span class="comment">//rectangle(imgOriginal, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawPoints</span><span class="params">(vector&lt;Point&gt; points, Scalar color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(imgOriginal, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line">		<span class="built_in">putText</span>(imgOriginal, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">reorder</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Point&gt; newPoints;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line">		subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//0</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//1</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//2</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">getWarp</span><span class="params">(Mat img, vector&lt;Point&gt; points, <span class="keyword">float</span> w, <span class="keyword">float</span> h )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imgWarp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string path = <span class="string">&quot;res/paper.jpg&quot;</span>;</span><br><span class="line">	imgOriginal = <span class="built_in">imread</span>(path);</span><br><span class="line">	<span class="built_in">resize</span>(imgOriginal, imgOriginal, <span class="built_in">Size</span>(), <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Preprpcessing - Step 1</span></span><br><span class="line">	imgThre = <span class="built_in">preProcessing</span>(imgOriginal);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get Contours - Biggest  - Step 2</span></span><br><span class="line">	initialPoints = <span class="built_in">getContours</span>(imgThre);</span><br><span class="line"><span class="comment">//	drawPoints(initialPoints, Scalar(0, 0, 255));</span></span><br><span class="line">	docPoints = <span class="built_in">reorder</span>(initialPoints);</span><br><span class="line"><span class="comment">//	drawPoints(docPoints, Scalar(0, 255, 0));</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Warp - Step 3</span></span><br><span class="line">	imgWarp = <span class="built_in">getWarp</span>(imgOriginal, docPoints, w, h);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Crop - Step 4</span></span><br><span class="line">	<span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, w - (<span class="number">2</span> * cropVal), h - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">	imgCrop = <span class="built_in">imgWarp</span>(roi);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, imgOriginal);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgThre);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用3-车牌检测"><a href="#应用3-车牌检测" class="headerlink" title="应用3 车牌检测"></a>应用3 车牌检测</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 3 - 牌照检测 //////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	CascadeClassifier plateCascade;</span><br><span class="line">	plateCascade.<span class="built_in">load</span>(<span class="string">&quot;Resources/haarcascade_russian_plate_number.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (plateCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;Rect&gt; plates;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		plateCascade.<span class="built_in">detectMultiScale</span>(img, plates, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plates.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			Mat imgCrop = <span class="built_in">img</span>(plates[i]);</span><br><span class="line">			<span class="comment">//imshow(to_string(i), imgCrop);</span></span><br><span class="line">			<span class="built_in">imwrite</span>(<span class="string">&quot;Resources/Plates/&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;.png&quot;</span>, imgCrop);</span><br><span class="line">			<span class="built_in">rectangle</span>(img, plates[i].<span class="built_in">tl</span>(), plates[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</title>
    <url>/posts/b5b2ecfc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"><a href="#OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道" class="headerlink" title="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"></a>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGB_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mat RGB_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line">	<span class="function">Mat* <span class="title">Set_RGB_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line">	<span class="function">Mat <span class="title">Get_R</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_G</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_B</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> RGB_Color_Channels[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//HSV类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSV_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Mat HSV_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line">	<span class="function">Mat* <span class="title">Set_HSV_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line">	<span class="function">Mat <span class="title">Get_V</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_S</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">Get_H</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HSV_Color_Channels[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//彩色图片的读取</span></span><br><span class="line">	Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line">	<span class="comment">//RGB三通道分离并显示</span></span><br><span class="line">	RGB_Channels my_rgb;</span><br><span class="line">	<span class="built_in">split</span>(image,my_rgb.<span class="built_in">Set_RGB_Color_Channels</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;R&quot;</span>,my_rgb.<span class="built_in">Get_R</span>());</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;G&quot;</span>,my_rgb.<span class="built_in">Get_G</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;B&quot;</span>,my_rgb.<span class="built_in">Get_B</span>());	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//RGB转HSV</span></span><br><span class="line">	Mat image_hsv;</span><br><span class="line">	<span class="built_in">cvtColor</span>(image, image_hsv, COLOR_BGR2HSV_FULL);</span><br><span class="line">	<span class="comment">//HSV三通道分离并显示</span></span><br><span class="line">	HSV_Channels my_hsv;</span><br><span class="line">	<span class="built_in">split</span>(image_hsv,my_hsv.<span class="built_in">Set_HSV_Color_Channels</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;H&quot;</span>,my_hsv.<span class="built_in">Get_H</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;S&quot;</span>,my_hsv.<span class="built_in">Get_S</span>());</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;V&quot;</span>,my_hsv.<span class="built_in">Get_V</span>());</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/8f0ffc2404d1a1957390a20f6bb47673.png" alt="image-20220302161619338"></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV滤波算法</title>
    <url>/posts/8b4c19c3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV滤波算法"><a href="#OpenCV滤波算法" class="headerlink" title="OpenCV滤波算法"></a>OpenCV滤波算法</h1><h2 id="三种滤波的优缺点对比"><a href="#三种滤波的优缺点对比" class="headerlink" title="三种滤波的优缺点对比"></a>三种滤波的优缺点对比</h2><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯滤波适合有高斯噪声的图片。能够很好的抑制图像输入时随机引入的噪声，将像素点跟邻域像素看作是一种高斯分布的关系，它的操作是将图像和一个高斯核进行卷积操作。但是不能很好地抑制椒盐噪声。</p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值滤波适合有椒盐噪声的图片。将窗口函数里面的所有像素进行排序取得中位数来代表该窗口中心的像素值，对椒盐噪声和脉冲噪声的抑制效果特别好，同时又能保留边缘细节。但是不能很好地抑制高斯噪声。</p>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>把每个像素都用周围的8个像素来做均值操作，幅值近似相等且随机分布在不同位置上，这样可以平滑图像，速度较快，算法简单。但是无法去掉噪声，只能微弱的减弱它。对于椒盐噪声，中值滤波是选择适当的点来替代污染点的值，所以处理效果好，由于椒盐噪声的均值不为0，所以均值滤波不能很好地去除噪声点。</p>
<h2 id="三种滤波算法对不同噪声的处理"><a href="#三种滤波算法对不同噪声的处理" class="headerlink" title="三种滤波算法对不同噪声的处理"></a>三种滤波算法对不同噪声的处理</h2><p><strong>给经过灰度处理的图像分别加入椒盐噪声、高斯噪声和椒盐高斯噪声，分别使用高斯滤波、中值滤波和均值滤波对图像进行滤波，下面为运行后的效果图：</strong></p>
<h3 id="添加椒盐噪声"><a href="#添加椒盐噪声" class="headerlink" title="添加椒盐噪声"></a>添加椒盐噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132251591.png" alt="image-20220308132251591"></p>
<h3 id="添加高斯噪声"><a href="#添加高斯噪声" class="headerlink" title="添加高斯噪声"></a>添加高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132404182.png" alt="image-20220308132404182"></p>
<h3 id="添加椒盐噪声和高斯噪声"><a href="#添加椒盐噪声和高斯噪声" class="headerlink" title="添加椒盐噪声和高斯噪声"></a>添加椒盐噪声和高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132459737.png" alt="image-20220308132459737"></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//生成高斯噪声</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">generate_gause_noise</span><span class="params">(<span class="keyword">double</span> mu, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//定义小值</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">double</span> epsilon = numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">double</span> z0, z1;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		flag = !flag;</span><br><span class="line">		<span class="comment">//flag为假构造高斯随机变量X</span></span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">			<span class="keyword">return</span> z1 * sigma + mu;</span><br><span class="line">		<span class="keyword">double</span> u1, u2;</span><br><span class="line">		<span class="comment">//构造随机变量</span></span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			u1 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">			u2 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">		&#125; <span class="keyword">while</span> (u1 &lt;= epsilon);</span><br><span class="line">		<span class="comment">//flag为真构造高斯随机变量</span></span><br><span class="line">		z0 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">cos</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line">		z1 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">sin</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line">		<span class="keyword">return</span> z0*sigma + mu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为图像加入高斯噪声</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_gause_noise</span><span class="params">(Mat&amp; image)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> channels = image.<span class="built_in">channels</span>();</span><br><span class="line">		<span class="keyword">int</span> rowsNumber = image.rows;</span><br><span class="line">		<span class="keyword">int</span> colsNumber = image.cols*channels;</span><br><span class="line">		<span class="comment">//推断图像的连续性</span></span><br><span class="line">		<span class="keyword">if</span> (image.<span class="built_in">isContinuous</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			colsNumber *= rowsNumber;</span><br><span class="line">			rowsNumber = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsNumber; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colsNumber; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//加入高斯噪声</span></span><br><span class="line">				<span class="keyword">int</span> val = image.ptr&lt;uchar&gt;(i)[j] + <span class="built_in">generate_gause_noise</span>(<span class="number">3</span>, <span class="number">0.8</span>) * <span class="number">32</span>;</span><br><span class="line">				<span class="keyword">if</span> (val &lt; <span class="number">0</span>)</span><br><span class="line">					val = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (val&gt;<span class="number">255</span>)</span><br><span class="line">					val = <span class="number">255</span>;</span><br><span class="line">				image.ptr&lt;uchar&gt;(i)[j] = (uchar)val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加椒盐噪声</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_salt_noise</span><span class="params">(Mat&amp; image, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line">			<span class="comment">// 灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;uchar&gt;(j, i) = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 彩色图像</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line">			<span class="comment">// 灰度图像</span></span><br><span class="line">			<span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;uchar&gt;(j, i) = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 彩色图像</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">			&#123;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中值滤波</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">median_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">		<span class="keyword">int</span> start = win_size/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">				vector&lt;uchar&gt; model;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">						<span class="comment">//cout &lt;&lt; int(src.at&lt;uchar&gt;(i, j)) &lt;&lt; endl;</span></span><br><span class="line">						model.<span class="built_in">push_back</span>(src.at&lt;uchar&gt;(i, j));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">sort</span>(model.<span class="built_in">begin</span>(), model.<span class="built_in">end</span>());     <span class="comment">//采用快速排序进行</span></span><br><span class="line">				src.at&lt;uchar&gt;(m, n) = model[win_size*win_size/<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//均值滤波</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mean_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">		<span class="keyword">int</span> start = win_size / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">						sum += src.at&lt;uchar&gt;(i, j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum / win_size / win_size);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成高斯模板</span></span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; <span class="built_in">gause_template</span>(<span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> xcore = size / <span class="number">2</span>, ycore = size / <span class="number">2</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; res;</span><br><span class="line">		<span class="keyword">float</span> base = <span class="number">1.0</span> / <span class="number">2</span> / CV_PI / sigma / sigma;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</span><br><span class="line">			vector&lt;<span class="keyword">float</span>&gt;v;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; size; y++) &#123;</span><br><span class="line">				<span class="keyword">float</span> t1 = (<span class="built_in">pow</span>(x - xcore, <span class="number">2</span>) + <span class="built_in">pow</span>(y - ycore, <span class="number">2</span>)) / <span class="number">2.0</span> / sigma / sigma;</span><br><span class="line">				<span class="keyword">float</span> temp = base*<span class="built_in">exp</span>(-t1);</span><br><span class="line">				v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">			&#125;</span><br><span class="line">			res.<span class="built_in">push_back</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//高斯滤波</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">gause_filter</span><span class="params">(Mat&amp; src, <span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = <span class="built_in">gause_template</span>(sigma,size);</span><br><span class="line">		<span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line">		<span class="keyword">int</span> start = size / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">				<span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">						<span class="comment">//cout &lt;&lt; gaussTem[i - m + start][j - n + start] &lt;&lt; endl;</span></span><br><span class="line">						sum += src.at&lt;uchar&gt;(i, j)*gaussTem[i-m+start][j-n+start];  <span class="comment">//重点理解！！！</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Flitter my_flitter;</span><br><span class="line">	Mat src = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line">	<span class="comment">//灰度处理</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(src, src,COLOR_BGR2GRAY);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;灰度处理过的原始图像&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//椒盐噪声</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//添加椒盐噪声</span></span><br><span class="line">		Mat src_add_salt_noise;</span><br><span class="line">		src.<span class="built_in">convertTo</span>(src_add_salt_noise, CV_8UC1);</span><br><span class="line">		my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_noise, <span class="number">3000</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐噪声&quot;</span>, src_add_salt_noise);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中值滤波</span></span><br><span class="line">		Mat Trans_Median = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//均值滤波</span></span><br><span class="line">		Mat Trans_Mean = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//高斯滤波</span></span><br><span class="line">		<span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		Mat Trans_Gause = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//高斯噪声</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//添加高斯噪声</span></span><br><span class="line">		Mat src_add_gause_noise;</span><br><span class="line">		src.<span class="built_in">convertTo</span>(src_add_gause_noise, CV_8UC1);</span><br><span class="line">		my_flitter.<span class="built_in">add_gause_noise</span>(src_add_gause_noise);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;添加高斯噪声&quot;</span>, src_add_gause_noise);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中值滤波</span></span><br><span class="line">		Mat Trans_Median = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//均值滤波</span></span><br><span class="line">		Mat Trans_Mean = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//高斯滤波</span></span><br><span class="line">		<span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		Mat Trans_Gause = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//椒盐+高斯噪声</span></span><br><span class="line">	&#123;</span><br><span class="line">		Mat src_add_salt_and_gause_noise;</span><br><span class="line">		src.<span class="built_in">convertTo</span>(src_add_salt_and_gause_noise, CV_8UC1);</span><br><span class="line">		<span class="comment">//添加椒盐噪声</span></span><br><span class="line">		my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_and_gause_noise, <span class="number">3000</span>);</span><br><span class="line">		<span class="comment">//添加高斯噪声</span></span><br><span class="line">		my_flitter.<span class="built_in">add_gause_noise</span>(src_add_salt_and_gause_noise);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐+高斯噪声&quot;</span>, src_add_salt_and_gause_noise);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中值滤波</span></span><br><span class="line">		Mat Trans_Median = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//均值滤波</span></span><br><span class="line">		Mat Trans_Mean = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//高斯滤波</span></span><br><span class="line">		<span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">		vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		Mat Trans_Gause = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">		my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV直方图均衡化</title>
    <url>/posts/ab9acae.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV直方图均衡化"><a href="#OpenCV直方图均衡化" class="headerlink" title="OpenCV直方图均衡化"></a>OpenCV直方图均衡化</h1><p>直方图均衡化，是对图像进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。<strong>直方图均衡化适用于增强直方图呈尖峰分布的图像。</strong></p>
<h2 id="几种图片的的直方图均衡化处理效果"><a href="#几种图片的的直方图均衡化处理效果" class="headerlink" title="几种图片的的直方图均衡化处理效果"></a>几种图片的的直方图均衡化处理效果</h2><h3 id="欠曝"><a href="#欠曝" class="headerlink" title="欠曝"></a>欠曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140221839.png" alt="image-20220308140221839"></p>
<h3 id="过曝"><a href="#过曝" class="headerlink" title="过曝"></a>过曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140259367.png" alt="image-20220308140259367"></p>
<p>从上面两个图片可以看到，直方图均衡化对于背景和前景都太亮或者太暗的图像效果较好，而且这是一个可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图。但缺点是直方图均衡化对处理的数据不加选择，它可能会增加背景噪声的对比度并且降低有用信号的对比度；变换后图像的灰度级减少，某些细节消失；某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。</p>
<p>下面再贴一张Luna的处理图：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140434486.png" alt="image-20220308140434486"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直方图均衡化</span></span><br><span class="line"><span class="function">Mat <span class="title">Histogramequalization</span><span class="params">(Mat src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> R[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> G[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> B[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> rows = src.rows;</span><br><span class="line">	<span class="keyword">int</span> cols = src.cols;</span><br><span class="line">	<span class="keyword">int</span> sum = rows * cols;</span><br><span class="line">	<span class="comment">//统计直方图的RGB分布</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]]++;</span><br><span class="line">			G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]]++;</span><br><span class="line">			R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构建直方图的累计分布方程，用于直方图均衡化</span></span><br><span class="line">	<span class="keyword">double</span> val[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		val[<span class="number">0</span>] += B[i];</span><br><span class="line">		val[<span class="number">1</span>] += G[i];</span><br><span class="line">		val[<span class="number">2</span>] += R[i];</span><br><span class="line">		B[i] = val[<span class="number">0</span>] * <span class="number">255</span> / sum;</span><br><span class="line">		G[i] = val[<span class="number">1</span>] * <span class="number">255</span> / sum;</span><br><span class="line">		R[i] = val[<span class="number">2</span>] * <span class="number">255</span> / sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//归一化直方图</span></span><br><span class="line">	<span class="function">Mat <span class="title">dst</span><span class="params">(rows, cols, CV_8UC3)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			dst.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]];</span><br><span class="line">			dst.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]];</span><br><span class="line">			dst.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat luna = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Luna——原始图像&quot;</span>, luna);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Luna——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(luna));</span><br><span class="line"></span><br><span class="line">	Mat guobao = <span class="built_in">imread</span>(<span class="string">&quot;./guobao.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;过曝光——原始图像&quot;</span>, guobao);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;过曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(guobao));</span><br><span class="line"></span><br><span class="line">	Mat qianbao = <span class="built_in">imread</span>(<span class="string">&quot;./qianbao.jpg&quot;</span>);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——原始图像&quot;</span>, qianbao);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(qianbao));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>透视变换MATLAB仿真，OpenCV验证</title>
    <url>/posts/bc853aec.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="透视变换MATLAB仿真，OpenCV验证"><a href="#透视变换MATLAB仿真，OpenCV验证" class="headerlink" title="透视变换MATLAB仿真，OpenCV验证"></a>透视变换MATLAB仿真，OpenCV验证</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220311102049452.png" alt="image-20220311102049452"></p>
<h2 id="Matlab仿真"><a href="#Matlab仿真" class="headerlink" title="Matlab仿真"></a>Matlab仿真</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原图像的四个顶点分别左乘变换矩阵，并对其归一化。然后使用一个矩形将这个四边形框在内，矩形的选取规则为：左下顶点为所有xy的最小值，右上顶点为所有xy的最大值。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 原图像F的四个顶点坐标</span></span><br><span class="line">x0y0 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line">xnyn = [<span class="number">640</span>;<span class="number">480</span>;<span class="number">1</span>];</span><br><span class="line">x0yn = [<span class="number">0</span>;<span class="number">480</span>;<span class="number">1</span>];</span><br><span class="line">xny0 = [<span class="number">640</span>;<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 变换矩阵</span></span><br><span class="line">A = [<span class="number">6.01</span> <span class="number">-1.65</span> <span class="number">537</span>;<span class="number">0.188</span> <span class="number">2.88</span> <span class="number">554</span>;<span class="number">0.000584</span> <span class="number">-0.000620</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 计算透视变换后图像的四个顶点坐标</span></span><br><span class="line">toushi_x0y0 = (A * x0y0) / (A(<span class="number">3</span>,<span class="number">1</span>) * x0y0(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * x0y0(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_xnyn = (A * xnyn) / (A(<span class="number">3</span>,<span class="number">1</span>) * xnyn(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * xnyn(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_x0yn = (A * x0yn) / (A(<span class="number">3</span>,<span class="number">1</span>) * x0yn(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * x0yn(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_xny0 = (A * xny0) / (A(<span class="number">3</span>,<span class="number">1</span>) * xny0(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * xny0(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 画图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 原图像（黑色）</span></span><br><span class="line"><span class="built_in">plot</span>(x0y0(<span class="number">1</span>,<span class="number">1</span>),x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(x0yn(<span class="number">1</span>,<span class="number">1</span>),x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(xnyn(<span class="number">1</span>,<span class="number">1</span>),xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(xny0(<span class="number">1</span>,<span class="number">1</span>),xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([x0y0(<span class="number">1</span>,<span class="number">1</span>),x0yn(<span class="number">1</span>,<span class="number">1</span>)],[x0y0(<span class="number">2</span>,<span class="number">1</span>),x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([x0yn(<span class="number">1</span>,<span class="number">1</span>),xnyn(<span class="number">1</span>,<span class="number">1</span>)],[x0yn(<span class="number">2</span>,<span class="number">1</span>),xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([xnyn(<span class="number">1</span>,<span class="number">1</span>),xny0(<span class="number">1</span>,<span class="number">1</span>)],[xnyn(<span class="number">2</span>,<span class="number">1</span>),xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([xny0(<span class="number">1</span>,<span class="number">1</span>),x0y0(<span class="number">1</span>,<span class="number">1</span>)],[xny0(<span class="number">2</span>,<span class="number">1</span>),x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 变换后图像（蓝色）</span></span><br><span class="line"><span class="built_in">plot</span>(toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>)],[toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>)],[toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">1</span>,<span class="number">1</span>)],[toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>)],[toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用一个矩形框起来（绿色）</span></span><br><span class="line">all_x = [toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>)];</span><br><span class="line">all_y = [toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>)];</span><br><span class="line">new_x0y0 = [<span class="built_in">min</span>(all_x);<span class="built_in">min</span>(all_y)]</span><br><span class="line">new_x0yn = [<span class="built_in">min</span>(all_x);<span class="built_in">max</span>(all_y)];</span><br><span class="line">new_xnyn = [<span class="built_in">max</span>(all_x);<span class="built_in">max</span>(all_y)]</span><br><span class="line">new_xny0 = [<span class="built_in">max</span>(all_x);<span class="built_in">min</span>(all_y)];</span><br><span class="line"><span class="built_in">plot</span>(new_x0y0(<span class="number">1</span>,<span class="number">1</span>),new_x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_x0yn(<span class="number">1</span>,<span class="number">1</span>),new_x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_xnyn(<span class="number">1</span>,<span class="number">1</span>),new_xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_xny0(<span class="number">1</span>,<span class="number">1</span>),new_xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_x0y0(<span class="number">1</span>,<span class="number">1</span>),new_x0yn(<span class="number">1</span>,<span class="number">1</span>)],[new_x0y0(<span class="number">2</span>,<span class="number">1</span>),new_x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_x0yn(<span class="number">1</span>,<span class="number">1</span>),new_xnyn(<span class="number">1</span>,<span class="number">1</span>)],[new_x0yn(<span class="number">2</span>,<span class="number">1</span>),new_xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_xnyn(<span class="number">1</span>,<span class="number">1</span>),new_xny0(<span class="number">1</span>,<span class="number">1</span>)],[new_xnyn(<span class="number">2</span>,<span class="number">1</span>),new_xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_xny0(<span class="number">1</span>,<span class="number">1</span>),new_x0y0(<span class="number">1</span>,<span class="number">1</span>)],[new_xny0(<span class="number">2</span>,<span class="number">1</span>),new_x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%输出G的尺寸</span></span><br><span class="line">delta_x = <span class="built_in">max</span>(all_x) - <span class="built_in">min</span>(all_x)</span><br><span class="line">delta_y = <span class="built_in">max</span>(all_y) - <span class="built_in">min</span>(all_y)</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>运行代码，输出图像，下图中<strong>黑色矩形</strong>为原图像F，<strong>蓝色矩形</strong>为透视变换后的图像，<strong>绿色矩形</strong>是用矩形框起来的最终图像G：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308173653334.png" alt="image-20220308173653334" style="zoom:67%;"></p>
<p>同时MATLAB控制台输出<strong>delta_x = 3.7003e+03</strong>，<strong>delta_y = 2.2660e+03</strong></p>
<p>也就是说经过透视变换后的图像G的尺寸为<strong>3700.3*2266</strong></p>
<h2 id="OpenCV验证"><a href="#OpenCV验证" class="headerlink" title="OpenCV验证"></a>OpenCV验证</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>随便选取一张图片，将其拉伸到640*480，再对其进行上述变换矩阵指定的透视变换，最后输出图片。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 伸缩图片至640*480</span></span><br><span class="line">	Mat imgResize;</span><br><span class="line">	<span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">640</span>,<span class="number">480</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 变换前与变换后的顶点坐标</span></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">640</span>,<span class="number">480</span>&#125;,&#123;<span class="number">0</span>,<span class="number">480</span>&#125;,&#123;<span class="number">640</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">537.0f</span>,<span class="number">554.0f</span>&#125;,&#123;<span class="number">3337.2f</span>,<span class="number">1911.2f</span>&#125;,&#123;<span class="number">-363.0f</span>,<span class="number">2756.8</span>&#125;,&#123;<span class="number">3190.8</span>,<span class="number">490.9</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建变换矩阵</span></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 透视变换</span></span><br><span class="line">	Mat imgWarp;</span><br><span class="line">	<span class="built_in">warpPerspective</span>(imgResize, imgWarp, matrix, <span class="built_in">Size</span>(<span class="number">4000</span>, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记原始图像位置</span></span><br><span class="line">	<span class="built_in">rectangle</span>(imgWarp, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">640</span>, <span class="number">480</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">	<span class="built_in">putText</span>(imgWarp, <span class="string">&quot;Origin Image&quot;</span>, <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>), FONT_HERSHEY_COMPLEX, <span class="number">2</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出变换后图像</span></span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;res/output.jpg&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>下图中左上角为原始图像（合并显示有点麻烦所以只画了一个跟原始图像一样大的白色矩形代替）</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/output.jpg" alt="output" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV文档矫正</title>
    <url>/posts/c780224b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV文档矫正"><a href="#OpenCV文档矫正" class="headerlink" title="OpenCV文档矫正"></a>OpenCV文档矫正</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将一个斜着拍摄的文档矫正成正的，如图所示：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_origin.jpg" alt="opencv-wendang-image_origin"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_output.jpg" alt="opencv-wendang-image_output"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>读取原始图像，若图像太大可以先进行缩放处理，并获取原始图像的宽和高</li>
<li>对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</li>
<li>找到最大的轮廓，并提取角点<ol>
<li>进行降噪处理：检测轮廓面积，只保留大于阈值面积的轮廓</li>
<li>计算每个轮廓的周长，使用DP算法计算出轮廓点的个数，规则为周长*0.02</li>
<li>找到图像中面积最大的，且角点为4的轮廓</li>
</ol>
</li>
<li>将找到的四个角点排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角<ol>
<li>将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</li>
<li>将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</li>
<li>重新排列四个角点</li>
</ol>
</li>
<li>进行透视变换<ol>
<li>根据变换前及变换后的四个角点，创建变换矩阵</li>
<li>根据变换矩阵对图像进行透视变换</li>
</ol>
</li>
<li>若透视变换后有一些毛边，按需要进行裁剪，裁剪后重新调整比例<ol>
<li>创建一个矩形用来裁剪，并设定四周裁剪5像素</li>
<li>裁剪后重新调整图像宽高</li>
</ol>
</li>
<li>显示变换后图像</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码中均有详细注释，请仔细阅读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些定义</span></span><br><span class="line">Mat image_origin,     <span class="comment">// 原始图像</span></span><br><span class="line">	image_gray,       <span class="comment">// 灰度处理后的图像</span></span><br><span class="line">	image_blur,       <span class="comment">// 高斯模糊处理后的图像</span></span><br><span class="line">	image_canny,      <span class="comment">// 边缘检测后的图像</span></span><br><span class="line">	image_dilate,     <span class="comment">// 膨胀后的图像</span></span><br><span class="line">	image_erode,      <span class="comment">// 腐蚀后的图像</span></span><br><span class="line">	image_preprocess, <span class="comment">// 预处理后的图像</span></span><br><span class="line">	image_trans,      <span class="comment">// 透视变换后的图像</span></span><br><span class="line">	image_crop;	      <span class="comment">// 裁剪后的图像</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; origin_points,  <span class="comment">// 重新排列前的角点</span></span><br><span class="line">			  reorder_points; <span class="comment">// 重新排列后的角点</span></span><br><span class="line">			  </span><br><span class="line">			  </span><br><span class="line"><span class="keyword">int</span> origin_width = <span class="number">0</span>, origin_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：预处理，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line"><span class="comment"> * 输入：图像，是否显示(0-不显示 1-显示每一步处理后的图像 2-只显示最终图像)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PreProcess</span><span class="params">(<span class="keyword">const</span> Mat&amp; image, <span class="keyword">int</span> display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 灰度处理</span></span><br><span class="line">	<span class="built_in">cvtColor</span>(image, image_gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯模糊</span></span><br><span class="line">	<span class="built_in">GaussianBlur</span>(image_gray, image_blur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边缘检测(边缘检测前对图像进行一次高斯模糊)</span></span><br><span class="line">	<span class="built_in">Canny</span>(image_blur, image_canny, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 膨胀和腐蚀(有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀)</span></span><br><span class="line">	<span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">	Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="built_in">dilate</span>(image_canny, image_dilate, kernel);</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="comment">//erode(image_dilate, image_erode, kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示预处理效果</span></span><br><span class="line">	<span class="keyword">if</span>(display == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;灰度处理后的图像&quot;</span>, image_gray);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;高斯模糊后的图像&quot;</span>, image_blur);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;边缘检测后的图像&quot;</span>, image_canny);</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;膨胀后的图像&quot;</span>, image_dilate);</span><br><span class="line"><span class="comment">//		imshow(&quot;腐蚀后的图像&quot;, image_erode);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(display == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;预处理后的图像&quot;</span>, image_dilate);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> image_dilate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：找到面积最大的轮廓</span></span><br><span class="line"><span class="comment"> * 输入：源图像</span></span><br><span class="line"><span class="comment"> * 输出：最大轮廓的四个角点数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">GetMaxContour</span><span class="params">(<span class="keyword">const</span> Mat&amp; img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment">	 * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment">	 * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment">	 * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * findContours找到轮廓</span></span><br><span class="line"><span class="comment">	 * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment">	 * 		取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment">	 * 		取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment">	 * 		取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment">	 * 		取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment">	 * 		取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment">	 * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * drawContours绘出轮廓</span></span><br><span class="line"><span class="comment">	 * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment">	 * 第二个参数：contours</span></span><br><span class="line"><span class="comment">	 * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment">	 * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment">	 * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line"><span class="comment">//	// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//	drawContours(image, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">	vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">corners_contours</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line">	<span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">	vector&lt;Point&gt; biggest_contours;</span><br><span class="line">	<span class="keyword">double</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 检测轮廓面积</span></span><br><span class="line">		<span class="keyword">double</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//		cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 假设图像中有噪声，需要将其过滤，只保留面积大于1000的轮廓</span></span><br><span class="line">		<span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line">			<span class="keyword">double</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line">			<span class="built_in">approxPolyDP</span>(contours[i], corners_contours[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 找到图像中面积最大的，且角点为4的轮廓</span></span><br><span class="line">			<span class="keyword">if</span> (contour_area &gt; max_area &amp;&amp; corners_contours[i].<span class="built_in">size</span>() == <span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//drawContours(image_origin, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">				biggest_contours = &#123; corners_contours[i][<span class="number">0</span>],corners_contours[i][<span class="number">1</span>] ,corners_contours[i][<span class="number">2</span>] ,corners_contours[i][<span class="number">3</span>] &#125;;</span><br><span class="line">				max_area = contour_area;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//			// 只绘制角点之间的边框线，Debug用，取消注释可以看到检测出的所有边界框</span></span><br><span class="line"><span class="comment">//			drawContours(image_origin, corners_contours, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//			rectangle(image_origin, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回最大的轮廓</span></span><br><span class="line">	<span class="keyword">return</span> biggest_contours;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：绘制一些点</span></span><br><span class="line"><span class="comment"> * 输入：点集，颜色</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoints</span><span class="params">(vector&lt;Point&gt; points, <span class="keyword">const</span> Scalar&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">circle</span>(image_origin, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line">		<span class="built_in">putText</span>(image_origin, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：重新排列四个角点的顺序</span></span><br><span class="line"><span class="comment"> * 最终顺序为： 0  1</span></span><br><span class="line"><span class="comment"> * 			  2  3</span></span><br><span class="line"><span class="comment"> * 			  数组中为左上角-右上角-左下角-右下角</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">ReorderPoints</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Point&gt; newPoints;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// OpenCV中左上顶点为(0,0)，右为x轴正向，下为y轴正向。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</span></span><br><span class="line">		sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line">		<span class="comment">// 将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</span></span><br><span class="line">		subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新排列</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 0 和的最小值</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 1 差的最大值</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 2 差的最小值</span></span><br><span class="line">	newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 3 和的最大值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：</span></span><br><span class="line"><span class="comment"> * 输入：源图像，四个角点的集合(角点的顺序为，左上角-右上角-左下角-右下角)，输出的宽，输出的高</span></span><br><span class="line"><span class="comment"> * 输出：透视变换后的图像</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PerspectiveTrans</span><span class="params">(<span class="keyword">const</span> Mat&amp; img, vector&lt;Point&gt; points, <span class="keyword">float</span> width, <span class="keyword">float</span> height )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 前面经过重新排列，四个角点的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line">	<span class="comment">// 变换后的四个角点</span></span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;width,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,height&#125;,&#123;width,height&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建变换矩阵</span></span><br><span class="line">	Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line">	<span class="comment">// 透视变换</span></span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, image_trans, matrix, <span class="built_in">Point</span>(width, height));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> image_trans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1.读取原始图像</span></span><br><span class="line">	string path = <span class="string">&quot;res/image_origin.jpg&quot;</span>;</span><br><span class="line">	image_origin = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	// 若图像太大可以先进行缩放处理</span></span><br><span class="line"><span class="comment">//	resize(image_origin, image_origin, Size(), 0.5, 0.5);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取原始图像的宽和高</span></span><br><span class="line">	origin_width  = image_origin.<span class="built_in">size</span>().width;</span><br><span class="line">	origin_height = image_origin.<span class="built_in">size</span>().height;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line">	image_preprocess = <span class="built_in">PreProcess</span>(image_origin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.找到最大的轮廓，并提取角点</span></span><br><span class="line">	origin_points = <span class="built_in">GetMaxContour</span>(image_preprocess);</span><br><span class="line"><span class="comment">//	DrawPoints(origin_points, Scalar(0, 0, 255)); // 红色</span></span><br><span class="line">	<span class="comment">// 此时发现，角点的顺序不固定，为了后面进行透视变换时与代码中变换后点集的顺序相同，需要将其排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">	reorder_points = <span class="built_in">ReorderPoints</span>(origin_points);</span><br><span class="line"><span class="comment">//	DrawPoints(reorder_points, Scalar(0, 255, 0)); //绿色</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.透视变换</span></span><br><span class="line">	image_trans = <span class="built_in">PerspectiveTrans</span>(image_origin, reorder_points, origin_width, origin_height);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 透视变换后有一些毛边，若需要可以进行裁剪</span></span><br><span class="line">	<span class="comment">// 四周裁剪5像素</span></span><br><span class="line">	<span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 创建一个矩形用来裁剪</span></span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, origin_width - (<span class="number">2</span> * cropVal), origin_height - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">	image_crop = <span class="built_in">image_trans</span>(roi);</span><br><span class="line">	<span class="comment">// 裁剪后重新调整比例</span></span><br><span class="line">	<span class="built_in">resize</span>(image_crop, image_crop, <span class="built_in">Size</span>(origin_width, origin_height));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.显示并输出变换后图像</span></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;源图像&quot;</span>, image_origin);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;最终图像&quot;</span>, image_crop);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;res/image_output.jpg&quot;</span>, image_crop);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image.jpg" alt="opencv-wendang-image"></p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人动力学——拉格朗日法</title>
    <url>/posts/c0ff5b54.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器人动力学——拉格朗日法"><a href="#机器人动力学——拉格朗日法" class="headerlink" title="机器人动力学——拉格朗日法"></a>机器人动力学——拉格朗日法</h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p>机器人动力学所用到的运动学方程是一组具有下列形式的二阶微分方程组</p>
<script type="math/tex; mode=display">
\tau = M ( \theta ) \ddot { \theta } + h ( \theta , \dot { \theta } ) \label{1}</script><p>式中，对于所有关节均为驱动关节的开式运动链，广义坐标 $\theta \in \mathbb{R}^{n}$ 表示关节变量；广义力 $\tau \in \mathbb{R}^{n}$ 表示力或力矩，如果 $\theta_i$ 是旋转关节，则 $\tau_i$ 对应力矩；如果 $\theta_i$ 为平动关节，则 $\tau_i$ 对应力； $M ( \theta )\in \mathbb{R}^{n\times{n}}$ 是一个对称且正定的质量矩阵；$h ( \theta , \dot { \theta })\in \mathbb{R}^{n}$ 是将向心力、科里奥利力、重力和摩擦力等集合在一起的力向量，该向量取决于 $\theta$ 和 $ \dot { \theta}$ 这两个变量。</p>
<p>运动学同样区分正运动学和逆运动学，正向动力学问题是在给定状态变量 $( \theta , \dot { \theta })$ 以及关节力和力矩的前提下确定机器人的加速度 $\ddot { \theta }$ ，即</p>
<script type="math/tex; mode=display">
\ddot { \theta } = M ^ { - 1 } ( \theta ) ( \tau - h ( \theta , \dot { \theta } ) )</script><p>逆动力学问题则是找到对应于机器人状态和期望加速度的关节力和力矩$\tau$，即式 $\eqref{1}$ </p>
<p>机器人的动力学方程通常可以通过<strong>牛顿-欧拉公式</strong>或<strong>拉格朗日动力学公式</strong>得到。对于简单结构的机器人，如3自由度或自由度更少的情形，拉格朗日形式不仅在概念上十分优雅，并且在实际中非常有效。但对于自由度数目更多的机器人来讲，其计算可能会很快变得烦琐。</p>
<p>下文将讨论拉格朗日动力学公式</p>
<h2 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h2><p>力学系统的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 定义为整个系统的动能 ${ \cal K } ( q , \dot { q } )$ 减去势能 ${ \cal P } ( q )$ ，式中的—组独立坐标 $q \in \mathbb{R}^{n}$ 用来描述系统的位形（这个坐标 $q$ 被称为广义坐标）</p>
<script type="math/tex; mode=display">
{ \cal L } ( q , \dot { q } ) = { \cal K } ( q , \dot { q } ) - { \cal P } ( q )</script><p>运动方程现在可以用拉格朗日函数表示如下（推导过程略，详见动力学教材）</p>
<script type="math/tex; mode=display">
f = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { q } } - \frac { \partial { \cal L } } { \partial q }</script><p>这个方程也称为<strong>含外力的欧拉-拉格朗日方程</strong>（在标准形式的欧拉-拉格朗日方程中，外力 $f$ 等于零）</p>
<h2 id="2R-开链机器人举例"><a href="#2R-开链机器人举例" class="headerlink" title="$2R$ 开链机器人举例"></a>$2R$ 开链机器人举例</h2><p>下面以在重力作用下的—个 $2R$ 开链机器人为例推导动力学方程，如下图所示</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220315193736585.png" alt="image-20220315193736585" style="zoom:80%;"></p>
<p>将关节坐标 $\theta =(\theta_{1},\theta_{2})$ 选做广义坐标，广义力 $\tau =(\tau_{1},\tau_{2})$ 则对应于关节力矩（因为 $\tau^T\dot{\theta}$ 对应于功率）。本例中的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 可以写成如下分量形式:</p>
<script type="math/tex; mode=display">
\mathcal{L}(\theta, \dot{\theta})=\sum_{i=1}^{2}\left(\mathcal{K}_{i}-\mathcal{P}_{i}\right)</script><p>则欧拉-拉格朗日方程可以写成如下分量形式（ $\tau$ 为关节力和力矩向量）:</p>
<script type="math/tex; mode=display">
\tau_i = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { \theta_i } } - \frac { \partial { \cal L } } { \partial \theta_i } \qquad i = 1,2  \label{6}</script><p>下面我们需要计算两杆的动能和势能（认为两杆各自的质量 $\mathrm { m }1$ 和 $\mathrm { m }2$ 均集中于各杆末端）</p>
<p>连杆1质心的位置和速度:</p>
<script type="math/tex; mode=display">
\begin{array}{l}
{\left[\begin{array}{l}
x_{1} \\
y_{1}
\end{array}\right]=\left[\begin{array}{c}
L_{1} \cos \theta_{1} \\
L_{1} \sin \theta_{1}
\end{array}\right]} \\
{\left[\begin{array}{c}
\dot{x}_{1} \\
\dot{y}_{1}
\end{array}\right]=\left[\begin{array}{r}
-L_{1} \sin \theta_{1} \\
L_{1} \cos \theta_{1}
\end{array}\right] \dot{\theta}_{1}}
\end{array}</script><p>连杆2质心的位置和速度:</p>
<script type="math/tex; mode=display">
\begin{array}{l}
{\left[\begin{array}{l}
x_{2} \\
y_{2}
\end{array}\right]=\left[\begin{array}{c}
L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\
L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)
\end{array}\right]} \\
{\left[\begin{array}{l}
\dot{x}_{2} \\
\dot{y}_{2}
\end{array}\right]=\left[\begin{array}{rr}
-L_{1} \sin \theta_{1}-L_{2} \sin \left(\theta_{1}+\theta_{2}\right) & -L_{2} \sin \left(\theta_{1}+\theta_{2}\right) \\
L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) & L_{2} \cos \left(\theta_{1}+\theta_{2}\right)
\end{array}\right]\left[\begin{array}{l}
\dot{\theta}_{1} \\
\dot{\theta}_{2}
\end{array}\right] }
\end{array}</script><p>由 $\mathcal{K} =\frac{1}{2} \mathfrak{m} v^2 = \frac{1}{2} \mathfrak{m}(\dot{x}^2 + \dot{y}^2)$ ，连杆的动能项 ${ \cal K }_1$ 和 ${ \cal K }_2$ 分别为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{K}_{1} &=\frac{1}{2} \mathfrak{m}_{1}\left(\dot{x}_{1}^{2}+\dot{y}_{1}^{2}\right) \\

&=\frac{1}{2} \mathfrak{m}_{1} L_{1}^{2} \dot{\theta}_{1}^{2} \\

\mathcal{K}_{2} &=\frac{1}{2} \mathfrak{m}_{2}\left(\dot{x}_{2}^{2}+\dot{y}_{2}^{2}\right) \\

&=\frac{1}{2} \mathfrak{m}_{2}\left(\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \dot{\theta}_{1}^{2}+2\left(L_{2}^{2}+L_{1} L_{2} \cos \theta_{2}\right) \dot{\theta}_{1} \dot{\theta}_{2}+L_{2}^{2} \dot{\theta}_{2}^{2}\right)
\end{aligned}</script><p>势能只取决于高度，即 $y$ 坐标。由 $\mathcal{P} = \mathfrak{m} g y$ ，连杆的势能项 ${ \cal P }_1$ 和 ${ \cal P }_2$ 分别为</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\mathcal{P}_{1}=\mathfrak{m}_{1} g y_{1}=\mathfrak{m}_{1} g L_{1} \sin \theta_{1} \\
\mathcal{P}_{2}=\mathfrak{m}_{2} g y_{2}=\mathfrak{m}_{2} g\left(L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\right)
\end{array}</script><p>将动能项与势能项带入拉格朗日函数 $\eqref{6}$ 即可得到平面 $2R$ 运动链的动力学方程:</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
\tau_{1}=&\left(\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right)\right) \ddot{\theta}_{1} \\
&+\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{2}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\
&+\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right), \\
\tau_{2}=& \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{1}+\mathfrak{m}_{2} L_{2}^{2} \ddot{\theta}_{2}+\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2} \\
&+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) .
\end{aligned}
\right.</script><p>可以看到，即使是一个简单的 $2R$ 机器人，其逆运动学方程也十分复杂。对上述各项进行整理，得到如下形式的方程:</p>
<script type="math/tex; mode=display">
\tau=M(\theta) \ddot{\theta}+\underbrace{c(\theta, \dot{\theta})+g(\theta)}_{h(\theta, \dot{\theta})}</script><p>式中</p>
<script type="math/tex; mode=display">
\begin{aligned}
M(\theta) &=\left[\begin{array}{cc}
\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \\
\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}L_{2}^{2} \\
\end{array}\right] \\
c(\theta, \dot{\theta}) &=\left[\begin{array}{c}
-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\
\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2}
\end{array}\right] \\
g(\theta) &=\left[\begin{array}{c}
\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\
\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right)
\end{array}\right]
\end{aligned}</script><p>式中 <strong>$M(\theta)$ 为对称正定的质量矩阵</strong>， <strong>$c(\theta, \dot{\theta})$ 为速度乘积项，包含科里奥利和向心力矩的向量</strong>，其中包含 $\dot{\theta}^2$ 的二次项称为向心项，包含 $\dot{\theta}_{i} \dot{\theta}_{j}(i \ne j)$ 的二次项则称为科里奥利项。 <strong>$g(\theta)$ 为重力项</strong> ，因为此处势能仅来自重力，若末端有弹簧，弹簧也会贡献势能。这些揭示了运动方程是 $\ddot{\theta}$ 的线性函数、 $\dot{\theta}$ 的二次函数、 $\theta$ 的三角函数。上述结论不仅适用于 $2R$ 型机器人，对于包含转动关节的串联运动链也同样适用。</p>
]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派使用串口</title>
    <url>/posts/dab7fbfc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派使用串口"><a href="#树莓派使用串口" class="headerlink" title="树莓派使用串口"></a>树莓派使用串口</h1><p>树莓派默认将 serial0 映射到 外接GPIO的15、16脚。默认将 serial1 映射到 BT蓝牙上。所以如果想要将 ttyAMA0映射到外部 GPIO上，只需要禁用蓝牙，并将 serial0 和serial1 他们链接的对象互换。</p>
<p>但树莓派4B的更改方式与旧版本不同，终端输入<code>ls -l /dev/serial*</code>，发现只有serial1-&gt;ttyAMA0，没有serial0也没有ttyS0，更没有二者的映射。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>不要去修改<code>config.txt</code>里的配置！！！</strong>网上很多教程<strong>误人子弟</strong>，此文件开头就明确声明了禁止修改，用户的修改均要放置到<code>usercfg.txt</code>中！打开<code>config.txt</code>可以看到这个文件引用了<code>syscfg.txt</code>，这个文件里面写了<code>enable_uart=0</code>，也就是说即便在<code>config.txt</code>中修改了<code>enable_uart=1</code>，下面还是会被重新赋值为<code>enable_uart=0</code>。而<code>usercfg.txt</code>是在<code>syscfg.txt</code>后引用的，所以用户的修改项会覆盖上面的所有配置。</p>
<p>正确方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /boot/firmware</span><br><span class="line">sudo vi usercfg.txt</span><br></pre></td></tr></table></figure>
<p>在里面添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enable_uart=1</span><br><span class="line">dtoverlay=disable-bt</span><br></pre></td></tr></table></figure>
<p>保存，然后禁用跟蓝牙有关的开机启动项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> bluetooth</span><br></pre></td></tr></table></figure>
<p>重启树莓派</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>然后再次<code>ls -l /dev/serial*</code>就可以看到正确的映射关系</p>
]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>FOC控制原理——Clark变换和Park变换</title>
    <url>/posts/9532f19e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC控制原理——Clark变换和Park变换"><a href="#FOC控制原理——Clark变换和Park变换" class="headerlink" title="FOC控制原理——Clark变换和Park变换"></a>FOC控制原理——Clark变换和Park变换</h1><h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153620081.png" alt="image-20220323153620081"></p>
<p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    \begin{aligned}
    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\
            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c
    \end{aligned} \\
    \begin{aligned}
    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\
           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c
    \end{aligned}
\end{array}\right.</script><p>可以将其整理成矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{ccc}
    1 & -\frac{1}{2}       & -\frac{1}{2} \\
    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}
\end{array}\right]
\left[\begin{array}{c}
    I_{a} \\
    I_{b} \\
    I_{c}
\end{array}\right]</script><p>由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故也可整理为：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
    I_\alpha=\frac{3}{2}I_a \\
    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b
\end{array}\right.</script><p>反Clark变换则将三向信号转换为两向信号，根据上式可以解得</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
    I_{a} \\
    I_{b} \\
    I_{c}
\end{array}\right]=
\left[\begin{array}{ccc}
    \frac{2}{3}  & 0       \\
    -\frac{1}{3} & \frac{1}{\sqrt{3}} \\
    -\frac{1}{3} & -\frac{1}{\sqrt{3}}
\end{array}\right]
\left[\begin{array}{c}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]</script><p>也可通过计算Clark变换常数矩阵的伪逆来确定反Clark变换的常数矩阵（使用MATLAB中的 <code>pinv()</code>函数）</p>
<h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323152939436.png" alt="image-20220323152939436"></p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323150553068.png" alt="image-20220323150553068"></p>
<p>通过图像可以看到，输入信号的幅值为1，经过Clark变换后的图像幅值变为1.5，即变为 $\frac{3}{2}$ 倍；进行反Clark变换后幅值又变为1.5，即变为 $\frac{2}{3}$ 倍。所以要进行等幅值变换。修改仿真：</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153007076.png" alt="image-20220323153007076"></p>
<p>可以看到，经过等幅值变换后，幅值统一为1。</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323151818659.png" alt="image-20220323151818659"></p>
<h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Park变换可以将正弦变量线性化</p>
<p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/v2-d15d057327992a5c50016aea5bb7201b_1440w.jpg" alt="img"></p>
<p>也就是说 $d-q$ 坐标系始终跟着转子旋转。</p>
<p>则可以写出</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
I_{d}=I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \\
I_{q}=-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)
\end{array}\right.</script><p>整理成矩阵形式</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
    I_{d} \\
    I_{q}
\end{array}\right]=
\left[\begin{array}{cc}
     \cos \theta & \sin \theta \\
    -\sin \theta & \cos \theta
\end{array}\right]
\left[\begin{array}{l}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]</script><p>所以如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。</p>
<p>同理，可以求得反Park变换</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
    I_{\alpha} \\
    I_{\beta}
\end{array}\right]=
\left[\begin{array}{cc}
     \cos \theta & -\sin \theta \\
     \sin \theta & \cos \theta
\end{array}\right]
\left[\begin{array}{l}
    I_{d} \\
    I_{q}
\end{array}\right]</script><h3 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>在Clark变换和等幅值变换的基础上添加Park变换</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160805870.png" alt="image-20220323160805870"></p>
<p>关注Park部分</p>
<p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160942614.png" alt="image-20220323160942614"></p>
]]></content>
      <categories>
        <category>电机</category>
      </categories>
      <tags>
        <tag>FOC</tag>
      </tags>
  </entry>
</search>
