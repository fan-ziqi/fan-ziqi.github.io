# 动作

## 动作简介

前面几篇文章介绍到的话题和服务是ROS中最重要的两种底层通信机制，但也并不是说能解决所有应用层的问题，举一个例子，如果要让机械臂抓取一个物体，我们不仅要发出指令，还需要获取机械臂的实时反馈，如果直接用话题和服务也可以实现，不过一下得上好几个，有点麻烦。

针对类似的场景，ROS推出了一个应用级的通信机制——动作（ `Action`），主要应用于需要运行一段时间的机器人任务。action也并不是一个全新的机制，而是由底层的三个话题和服务组成：

* 任务**目标**（ `Goal`，服务）: Action客户端告诉服务端要做什么，服务端针对该目标要有响应。解决了不能确认服务端接收并处理目标问题
* 执行**结果**（ `Result`，服务）: Action服务端最终告诉客户端其执行结果，结果最后返回，用于表示任务最终执行情况。
* 周期数据**反馈**（ `Feedback`，话题）: Action服务端告诉客户端此时做的进度如何（类似与工作汇报）。解决执行过程中没有反馈问题

Action是可抢占式的，如果执行过程中不想跑了，那可以随时发送取消指令，动作终止，如果执行过程中发送一个新的action目标，则会直接中断上一个目标开始执行最新的任务目标。

总体上来讲，action是一个客户端-服务器的通信模型，`动作客户端`发送一个任务目标，`动作服务器`根据收到的目标执行并周期反馈状态，执行完成后反馈一个执行结果。

![Action-SingleActionClient](https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Action-SingleActionClient.gif)

下面, 我们将从一个实例出发, 手把手写一段动作程序


