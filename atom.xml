<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>范子琦的博客</title>
  
  
  <link href="https://www.robotsfan.com/atom.xml" rel="self"/>
  
  <link href="https://www.robotsfan.com/"/>
  <updated>2024-07-19T03:48:56.032Z</updated>
  <id>https://www.robotsfan.com/</id>
  
  <author>
    <name>Ziqi Fan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AMP论文解析</title>
    <link href="https://www.robotsfan.com/posts/1742892a.html"/>
    <id>https://www.robotsfan.com/posts/1742892a.html</id>
    <published>2024-07-19T04:00:00.000Z</published>
    <updated>2024-07-19T03:48:56.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AMP论文解析"><a href="#AMP论文解析" class="headerlink" title="AMP论文解析"></a>AMP论文解析</h1><p>AMP: Adversarial Motion Priors for Stylized Physics-Based Character Control</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>先从从模仿学习IL(Imitation Learning)说起。正常的强化学习RL(Reinforcement Learning)过程是”环境互动+最大化认为人为设计的奖励函数=最优Actor”</p><p>逆强化学习IRL(Inverse Reinforcement Learning)则没有奖励，取而代之的是”环境互动+最大化从专家数据学到的奖励函数=最优Actor”<br>GAIL(Generative Adversarial Imitation Learning)是使用GAN(Generative Adversarial Network)的IRL，即训练一个生成器 $G$ ，它从一个普通的分布逐渐生成与现有数据分布相似的分布。GAIL的数据集(参考运动)是 $\{(s,a)\}$ 。同样，我们希望我们的 Actor 能够模仿专家，即 Actor 产生的轨迹（的分布）与专家产生的轨迹（的分布）相似。GAN中的生成器和判别器这里不再赘述。reward是鼓励policy的行为和数据集里面的 $(𝑠,𝑎)$ 对尽可能像。</p><h2 id="AMP目标"><a href="#AMP目标" class="headerlink" title="AMP目标"></a>AMP目标</h2><p>本文的目标是训练一个agent，让其完成某个目标(Goal)，同时保持某种风格(Style)，其中风格由expert dataset或者demonstration dataset提供。本文混合了目标实现和模仿学习，其中模仿学习使用对抗性方式学习对给定风格的遵守，AMP中的A(Adversarial)就是对抗性。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020240719001013.png" alt="Pasted image 20240719001013" style="zoom: 50%;"></p><p>奖励函数由两部分组成，一部分是目标奖励 $r_t^G$ ，另一部分是风格奖励 $r_t^S$ ，通过计算两者的加权和得到总奖励：</p><script type="math/tex; mode=display">r(s_t,a_t,s_{t+1},g)=w^Gr^G(s_t,a_t,s_{t+1},g)+w^Sr^S(s_t,s_{t+1})</script><h2 id="目标奖励"><a href="#目标奖励" class="headerlink" title="目标奖励"></a>目标奖励</h2><p>agent可以是人形机器人，也可以是四足机器人或者霸王龙。目标奖励函数 $r_t^G$ 描述到达目标的程度，其根据目标来设计，如接近某个目标点或击打一个物体，这部分内容在附录中有详细介绍。作者针对不通的目标设计了很多奖励塑造，比如击打目标物体的任务，如果离目标很远则跑过去，如果离目标很近则切换到行走，如果与目标足够近则击打目标。agent观测环境得到state，生成action来实现目标。这里的任务设计是经典的策略梯度方法RL。</p><h2 id="风格奖励"><a href="#风格奖励" class="headerlink" title="风格奖励"></a>风格奖励</h2><p>数据集可以是动捕数据，也可以从已经学会的Policy中得到。数据集只提供运动的风格，而不提供如何实现目标。风格奖励 $r_t^S$ 描述遵守数据集中风格的程度，由运动先验(Motion Prior)进行判断，运动先验由GAN训练得到，经典的GAN Loss为：</p><script type="math/tex; mode=display">\arg\min_{D}\:-\mathbb{E}_{d^{M}(\mathrm{s,a})}\left[\log\left(D(\mathrm{s,a})\right)\right]-\mathbb{E}_{d^{\pi}(\mathrm{s,a})}\left[\log\left(1-D(\mathrm{s,a})\right)\right]</script><p>这里首先简单介绍一下标准的GAN(Generative Adversarial Network)，就是要训练一个生成器和一个鉴别器。生成器接收随机噪声作为输入，从一个普通的分布逐渐生成与数据集分布相似的分布。鉴别器的任务是需要区分数据集中已有的 $(𝑠,a)$ 和生成器产生的 $(𝑠,a)$ ，最后的目标是欺骗鉴别器：生成器产生的数据来自数据集。</p><p>本文中使用的GAN与传统GAN有一些改动。首先对于Agent，基于当前状态 $s$ ，采取动作 $a$ ，得到下一个状态 $s’$ 。但是数据集中只有连续的状态 $s_i$ 而并没有对应的 $a_i$ ，所以只使用上述三个参数中的 $s$ 和 $s’$ 来描述一次Transition，故GAN的状态对变为 $(𝑠,s’)$ 。除此之外与经典GAN不同的是，本文中的生成器其实就是Policy，输出也是 $(𝑠,s’)$ ，所以鉴别器的任务就变成了区分数据集中已有的 $(𝑠,s’)$ 和Policy产生的 $(𝑠,s’)$ ，最后的目标同样是欺骗鉴别器：Policy产生的真实数据来自数据集。这里的鉴别器实际上就是运动先验。</p><p>本文使用的Loss也与经典GAN不同，使用了最小二乘鉴别器(Least-Squares Discriminator)，使用平方损失，这样可以获得更好的梯度：</p><script type="math/tex; mode=display">\underset{D}{\operatorname*{\arg\min}}\:\mathbb{E}_{d^{M}(s,s^{\prime})}\left[\left(D(s,s^{\prime})-1\right)^{2}\right]+\mathbb{E}_{d^{\pi}(s,s^{\prime})}\left[\left(D(s,s^{\prime})+1\right)^{2}\right]</script><p>上述公式的意思就是：如果数据来自真实数据 $M$ ， $D(s,s^{\prime})$ 会接近1；如果数据来自Policy $\Pi$ ， $D(s,s^{\prime})$ 会接近-1。</p><p>使用鉴别器的输出来设计风格奖励函数：</p><script type="math/tex; mode=display">r(s_t,s_{t+1})=\max\left[0,1-0.25{\left(D(s_t,s_{t+1})-1\right)}^2\right]</script><p>可以看出，风格奖励被限制在0到1之间。如果鉴别器的输出 $D(s_t,s_{t+1})=1$ ，此时奖励达到最大（1），即鉴别器认为 $(𝑠,s’)$ 来自数据集。换句话说就是，当Policy设法产生了鉴别器认为是来自数据集的Transaction $(𝑠,s’)$ ，他就会获得最大奖励。</p><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>总结一下，上述训练过程就是policy在试图达到目标的同时去欺骗鉴别器“我就是数据集”；鉴别器则在试图区分开Policy产生的数据和数据集中的数据。</p><p>上述过程可以用伪代码来表示。1-5行是初始化各种buffer；7-8行使用policy产生m步的轨迹；第10行把transitions给判别器，状态对使用特征函数来 $\Phi$ 表示；11行根据上面的公式，使用鉴别器的输出计算风格奖励；12行通过计算目标奖励和加权奖励的加权和得到总奖励；15行将得到的轨迹存到reply buffer；20行使用reply buffer来更新鉴别器；22行更新价值函数和策略。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/Pasted%20image%2020240719001047.png" alt="Pasted image 20240719001047" style="zoom:50%;"></p><h2 id="梯度惩罚"><a href="#梯度惩罚" class="headerlink" title="梯度惩罚"></a>梯度惩罚</h2><p>GAN训练可能不稳定，使用梯度惩罚可以稳定训练</p><script type="math/tex; mode=display">\begin{aligned}\underset{D}{\operatorname*{\arg\min}}& \mathbb{E}_{d^{\mathcal{M}}(\mathrm{s,s'})}\left[\left(D(\Phi(\mathrm{s}),\Phi(\mathrm{s'}))-1\right)^2\right]  \\&+\mathbb{E}_{d^{\pi}(\mathrm{s,s^{\prime}})}\left[\left(D\left(\Phi(\mathrm{s}),\Phi(\mathrm{s^{\prime}})\right)+1\right)^{2}\right] \\&+\frac{w^\mathrm{gp}}2\:\mathbb{E}_{d^M(\mathrm{s},\mathrm{s}^{\prime})}\left[\left\|\nabla_{\phi}D(\phi)|_{\phi=(\Phi(\mathrm{s}),\Phi(\mathrm{s}^{\prime}))}\right\|^2\right]\end{aligned}</script><p>上面第三行惩罚了判别器出来的梯度范数</p><h2 id="动作组合与过渡"><a href="#动作组合与过渡" class="headerlink" title="动作组合与过渡"></a>动作组合与过渡</h2><p>AMP的另一个强大之处是经过学习之后可以组合数据集中的动作，也可以在多个动作之间自动过渡。比如数据集中只有独立的行走或奔跑而没有从行走到奔跑、从奔跑到行走这种组合，中间的转换过程则由策略自己学习。</p><p>这种多个动作的组合需要用权重来控制，比如举起手行走，如果举手的权重过小，则几乎无法行走；如行走的权重过小，则无法举手。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.youtube.com/watch?v=P38FZrbNHV4">https://www.youtube.com/watch?v=P38FZrbNHV4</a><br><a href="https://blog.csdn.net/weixin_41960890/article/details/123644185">https://blog.csdn.net/weixin_41960890/article/details/123644185</a><br><a href="https://zhuanlan.zhihu.com/p/503357084#ref_1">https://zhuanlan.zhihu.com/p/503357084#ref_1</a><br><a href="https://xbpeng.github.io/projects/AMP_Locomotion/index.html">https://xbpeng.github.io/projects/AMP_Locomotion/index.html</a><br><a href="https://xbpeng.github.io/projects/DeepMimic/index.html">https://xbpeng.github.io/projects/DeepMimic/index.html</a><br><a href="https://xbpeng.github.io/projects/AMP/index.html">https://xbpeng.github.io/projects/AMP/index.html</a><br><a href="https://arxiv.org/abs/2203.14912">https://arxiv.org/abs/2203.14912</a><br><a href="https://rofunc.readthedocs.io/en/latest/lfd/RofuncRL/AMP.html">https://rofunc.readthedocs.io/en/latest/lfd/RofuncRL/AMP.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="RL" scheme="https://www.robotsfan.com/categories/RL/"/>
    
    
    <category term="AMP" scheme="https://www.robotsfan.com/tags/AMP/"/>
    
  </entry>
  
  <entry>
    <title>四足机器人传统控制方法学习笔记</title>
    <link href="https://www.robotsfan.com/posts/311d50f4.html"/>
    <id>https://www.robotsfan.com/posts/311d50f4.html</id>
    <published>2024-06-09T03:30:00.000Z</published>
    <updated>2024-07-17T03:05:25.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="四足机器人传统控制方法学习笔记"><a href="#四足机器人传统控制方法学习笔记" class="headerlink" title="四足机器人传统控制方法学习笔记"></a>四足机器人传统控制方法学习笔记</h1><h2 id="运动学与动力学"><a href="#运动学与动力学" class="headerlink" title="运动学与动力学"></a>运动学与动力学</h2><h3 id="单腿运动学"><a href="#单腿运动学" class="headerlink" title="单腿运动学"></a>单腿运动学</h3><h4 id="正运动学"><a href="#正运动学" class="headerlink" title="正运动学"></a>正运动学</h4><p>目标：已知三个关节的角度 $(\theta_1,\theta_2,\theta_3)$ ，需要求出足端位置 $(x,y,z)$ </p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{T}_{01}&=\begin{bmatrix}\mathrm{rot}_x(\theta_1) & \boldsymbol{0}_{3\times1} \\\boldsymbol{0}_{3\times3} & 1\end{bmatrix}=\begin{bmatrix}1 & 0 & 0 & 0 \\0 & \cos(\theta_1) & -\sin(\theta_1) & 0 \\0 & \sin(\theta_1) & \cos(\theta_1) & 0 \\0 & 0 & 0 & 1\end{bmatrix}\\\boldsymbol{T}_{12}&=\begin{bmatrix}\mathrm{rot}_y(\theta_2) & \boldsymbol{0}_{3\times1} \\\boldsymbol{0}_{3\times3} & 1\end{bmatrix}=\begin{bmatrix}\cos(\theta_2) & 0 & \sin(\theta_2) & 0 \\0 & 1 & 0 & 0 \\-\sin(\theta_2) & 0 & \cos(\theta_2) & 0 \\0 & 0 & 0 & 1\end{bmatrix}\\\boldsymbol{T}_{23}&=\begin{bmatrix}\mathrm{rot}_y(\theta_3) & \left[\begin{matrix}0\\l_1\\l_2\end{matrix}\right] \\\boldsymbol{0}_{3\times3} & 1\end{bmatrix}=\begin{bmatrix}\cos(\theta_3) & 0 & \sin(\theta_3) & 0 \\0 & 1 & 0 & l_1 \\-\sin(\theta_3) & 0 & \cos(\theta_3) & l_2 \\0 & 0 & 0 & 1\end{bmatrix} \quad \begin{aligned} l_1 &= \left\{ \begin{aligned}-l_{abad}&,\text{right}\\l_{abad}&,\text{left}\end{aligned}\right. \\ l_2 &= -l_{hip}\end{aligned}\\\boldsymbol{p}_3 &= \begin{bmatrix}0\\0\\l_3\\1\end{bmatrix} \quad \begin{aligned}l_3=-l_{knee}\end{aligned}\end{aligned}</script><p>根据以上变换即可求出足端位置：</p><script type="math/tex; mode=display">\begin{bmatrix}x_p\\y_p\\z_p\\1\end{bmatrix}=\begin{bmatrix}l_3\sin(\theta_1+\theta_2)+l_2\sin(\theta_2)\\-l_3\sin(\theta_1)\cos(\theta_2+\theta_3)+l_1\cos(\theta_1)-l_2\cos(\theta_2)\sin(\theta_1)\\l_3\cos(\theta_1)\cos(\theta_2+\theta_3)+l_1\sin(\theta_1)+l_2\cos(\theta_1)\cos(\theta_2)\\1\end{bmatrix}\tag{1}</script><h4 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h4><p>目标：已知足端位置 $(x,y,z)$ ，需要求出三个关节的角度 $(\theta_1,\theta_2,\theta_3)$ </p><ol><li><p>求 $\theta_1$ </p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230831154919239.png" alt="image-20230831154919239" style="zoom:50%;"></p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{P}_0 &= \boldsymbol{R}_{01} \boldsymbol{P}_1\\\begin{bmatrix}y_p\\z_p\end{bmatrix}&=\begin{bmatrix}\cos(\theta_1)&-\sin(\theta_1)\\\sin(\theta_1)&\cos(\theta_1)\end{bmatrix}\begin{bmatrix}L\\-L\end{bmatrix}\end{aligned}</script><p>整理得</p><script type="math/tex; mode=display">\left\{\begin{aligned}y_p&=l_1\cos(\theta_1)+L\sin(\theta_1)\\z_p&=l_1\sin(\theta_1)-L\cos(\theta_1)\end{aligned}\right.\Rightarrow\left\{\begin{aligned}\frac{y_p}{\cos(\theta_1)}=l_1+L\tan(\theta_1)\\\frac{z_p}{\cos(\theta_1)}=l_1\tan(\theta_1)-L\end{aligned}\right.</script><p>由于 $z_p \ne 0$ ，可以推出 $\frac{y_p}{z_p}=\frac{l_1+L\tan(\theta_1)}{l_1\tan(\theta_1)-L}$ ，从而可以解出 $\tan(\theta_1)=\frac{z_pl_1+y_pL}{y_pl_1-z_pL}$ ，即 $\theta_1=\arctan\left(\frac{z_pl_1+y_pL}{y_pl_1-z_pL}\right)$ </p></li><li><p>求 $\theta_3$ （余弦定理）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230831154952123.png" alt="image-20230831154952123" style="zoom:50%;"></p><p>从图中可以得</p><script type="math/tex; mode=display">\begin{aligned}\angle{AO_3P}&=\arccos\left(\frac{\left|\overrightarrow{O_3A}\right|^2+\left|\overrightarrow{O_3P}\right|^2-\left|\overrightarrow{AP}\right|^2}{2\left|\overrightarrow{O_3A}\right|\left|\overrightarrow{O_3P}\right|}\right) \quad \text{其中}\left\{\begin{aligned}\left|\overrightarrow{AP}\right|&=\sqrt{x_p^2+y_p^2+z_p^2-l_1^2}\\\left|\overrightarrow{O_3A}\right|&=\sqrt{l_2}\\\left|\overrightarrow{O_3P}\right|&=\sqrt{l_3}\end{aligned}\right.\\&=\arccos\left(\frac{(l_1+l_2+l_3)-(x_p^2+y_p^2+z_p^2)}{2\sqrt{l_2l_3}}\right)\end{aligned}</script><p>则可求出 $\left|\theta_3\right|=\pi-\angle{AO_3P}$ ，选定逆时针为正，则 $\theta_3=\left|\theta_3\right|$ </p></li><li><p>求 $\theta_2$ </p><p>由前文的正运动学公式 $(1)$ 可得：</p><script type="math/tex; mode=display">\left\{\begin{aligned}x_{p} &= \left(l_{3} \cos \theta_{3}+l_{2}\right) \sin \theta_{2}+l_{3} \sin \theta_{3} \cos \theta_{2}\\ y_{p} &= -l_{3} \sin \theta_{1} \cos \left(\theta_{2}+\theta_{3}\right)+l_{1} \cos \theta_{1}-l_{2} \cos \theta_{2} \sin \theta_{1}\\z_{p} &= l_{3} \cos \theta_{1} \cos \left(\theta_{2}+\theta_{3}\right)+l_{1} \sin \theta_{1}+l_{2} \cos \theta_{1} \cos \theta_{2}\end{aligned}\right.</script><p>可以求出</p><script type="math/tex; mode=display">\begin{align}y_{p} \sin \theta_{1}-z_{p} \cos \theta_{1} & = -l_{3} \cos \left(\theta_{2}+\theta_{3}\right)\left(\sin ^{2} \theta_{1}+\cos ^{2} \theta_{1}\right)-l_{2} \cos \theta_{2}\left(\sin ^{2} \theta_{1}+\cos ^{2} \theta_{1}\right) \\ & = l_{3} \sin \theta_{3} \sin \theta_{2}-\left(l_{3} \cos \theta_{3}+l_{2}\right) \cos \theta_{2}\end{align}</script><p>同除 $x_p$ </p><script type="math/tex; mode=display">\begin{aligned}\frac{y_{p} \sin \theta_{1}-z_{p} \cos \theta_{1}}{x_{p}} & = \frac{l_{3} \sin \theta_{3} \sin \theta_{2}-\left(l_{3} \cos \theta_{3}+l_{2}\right) \cos \theta_{2}}{\left(l_{3} \cos \theta_{3}+l_{2}\right) \sin \theta_{2}+l_{3} \sin \theta_{3} \cos \theta_{2}}\end{aligned}</script><p>令 $\left\{\begin{aligned}<br>a_1&amp;=y_p \sin \theta_1-z_p \cos \theta_1 \\<br>a_2&amp;=x_p \\<br>m_1&amp;=l_3 \sin \theta_3 \\<br>m_2&amp;=l_3 \cos \theta_3+l_2<br>\end{aligned}<br>\right.$ ，上式可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}\frac{a_1}{a_2}&=\frac{m_1 \sin \theta_2-m_2 \cos \theta_2}{m_1 \cos \theta_2+m_2 \sin \theta_2} \\&=\frac{m_1 \tan \theta_2-m_2}{m_1+m_2 \tan \theta_2}\quad \end{aligned}</script><p>同除 $\cos(\theta_2)$ 可以解得：</p><script type="math/tex; mode=display">\begin{aligned}\tan(\theta_2)=\frac{a_1 m_1+a_2 m_2}{a_2 m_1-a_1 m_2}\end{aligned}</script><p>即可求出 $\theta_2$ ：</p><script type="math/tex; mode=display">\begin{aligned}\theta_2=\arctan \left(\frac{a_1 m_1+a_2 m_2}{a_2 m_1-a_1 m_2}\right)\end{aligned}</script></li></ol><p>至此完成逆运动学求解。</p><h4 id="雅可比矩阵"><a href="#雅可比矩阵" class="headerlink" title="雅可比矩阵"></a>雅可比矩阵</h4><p>对前文的正运动学公式 $(1)$ 求导：</p><script type="math/tex; mode=display">\left\{\begin{aligned}\dot{x}_p= & 0 \cdot \dot{\theta}_1+\left(l_3 \cos \left(\theta_2+\theta_3\right)+l_2 \cos \theta_2\right) \cdot \dot{\theta}_2+l_3 \cos \left(\theta_2+\theta_3\right) \cdot \dot{\theta}_3 \\\dot{y}_p= & \left(-l_1 \sin \theta_1-l_2 \cos \theta_1 \cos \theta_2-l_3 \cos \theta_1 \cos \left(\theta_2+\theta_3\right)\right) \cdot \dot{\theta}_1+ \\& \left(l_2 \sin \theta_1 \sin \theta_2+l_3 \sin \theta_1 \sin \left(\theta_2+\theta_3\right)\right) \cdot \dot{\theta}_2 + l_3 \sin \theta_1 \sin \left(\theta_2+\theta_3\right) \cdot \dot{\theta}_3 \\\dot{z}_p= & \left(l_1 \cos \theta_1-l_2 \sin \theta_1 \cos \theta_2-l_3 \sin \theta_1 \cos \left(\theta_2+\theta_3\right)\right) \cdot \dot{\theta}_1+ \\& \left(-l_2 \cos \theta_1 \sin \theta_2-l_3 \cos \theta_1 \sin \left(\theta_2+\theta_3\right)\right) \cdot \dot{\theta}_2+\left(-l_3 \cos \theta_1 \sin \left(\theta_2+\theta_3\right)\right) \cdot \dot{\theta}_3\end{aligned}\right.</script><p>整理成矩阵形式：</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{x}_{p}\\ \dot{y}_{p}\\ \dot{z}_{p}\end{bmatrix}=\begin{bmatrix}J_{11} & J_{12} & J_{13}\\ J_{21} & J_{22} & J_{23}\\ J_{31} & J_{32} & J_{33}\end{bmatrix}\cdot\begin{bmatrix}\dot{\theta}_1\\ \dot{\theta}_2\\ \dot{\theta}_3\end{bmatrix}=\boldsymbol{J}\cdot\begin{bmatrix}\ddot{\theta}_1\\ \dot{\theta}_2\\ \dot{\theta}_3\end{bmatrix}\tag{2}</script><p>对其求逆即可得到逆雅可比</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{\theta_1}\\\dot{\theta_2}\\\dot{\theta_3}\end{bmatrix}=\boldsymbol{J}^{-1}\begin{bmatrix}\dot{x}_p\\\dot{y}_p\\\dot{z}_p\end{bmatrix}\tag{3}</script><h3 id="单腿静力学"><a href="#单腿静力学" class="headerlink" title="单腿静力学"></a>单腿静力学</h3><p>当机器人腿部静止于地面，其关节力矩 $\boldsymbol{\tau}=\begin{bmatrix}\tau_1\\\tau_2\\\tau_3\end{bmatrix}$ ，足端对地面的作用力 $\boldsymbol{F}=\begin{bmatrix}F_x\\F_y\\F_z\end{bmatrix}$ </p><p>可以得到其关系</p><script type="math/tex; mode=display">\tau_1\dot{\theta_1}+\tau_2\dot{\theta_2}+\tau_3\dot{\theta_3}=F_x\dot{x_p}+F_y\dot{y_p}+F_z\dot{z_p}</script><p>整理成矩阵形式</p><script type="math/tex; mode=display">\begin{aligned}\begin{bmatrix}\tau_1&\tau_2&\tau_3\end{bmatrix}\begin{bmatrix}\dot{\theta}_1\\\dot{\theta}_2\\\dot{\theta}_3\end{bmatrix}&=\begin{bmatrix}F_{x}&F_{y}&F_{z}\end{bmatrix}\begin{bmatrix}\dot{x}_{p}\\\dot{y}_{p}\\\dot{z}_{p}\end{bmatrix}\\\boldsymbol{\tau}^T\cdot\dot{\boldsymbol{\theta}}&=\boldsymbol{F}^T\cdot \boldsymbol{J}\cdot\dot{\boldsymbol{\theta}}\\\end{aligned}</script><p>则可以得到：</p><script type="math/tex; mode=display">\boldsymbol{\tau}=\boldsymbol{J}^T\cdot \boldsymbol{F}</script><p>同样也可以通过关节力矩得到足端对地面的力</p><script type="math/tex; mode=display">\boldsymbol{F}=\boldsymbol{J}^{-T}\cdot \boldsymbol{\tau}</script><p>地面对足端的力 $\boldsymbol{F}’=-\boldsymbol{F}$ </p><h3 id="四足运动学"><a href="#四足运动学" class="headerlink" title="四足运动学"></a>四足运动学</h3><h4 id="改变姿态"><a href="#改变姿态" class="headerlink" title="改变姿态"></a>改变姿态</h4><p>目标：已知机身姿态，求关节角度</p><p>令足端静止在地面上，将右前腿 $P_0$ 点设为世界坐标系 $\{s\}$ 的原点，则 $\boldsymbol{p}_{si}$ 为常量</p><p>当 $\{s\}$ 和 $\{b\}$ 平行，此时 $\boldsymbol{R}_{sb}=\boldsymbol{I}$ ，可以得到四条腿相对于世界坐标系的位置：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{p}_{si}&=\boldsymbol{R}_{sb}\cdot[\boldsymbol{p}_{bi}(0)-\boldsymbol{p}_{b0}(0)]\\&=\boldsymbol{I}\cdot[\boldsymbol{p}_{bi}(0)-\boldsymbol{p}_{b0}(0)]\\&=\boldsymbol{p}_{bi}(0)-\boldsymbol{p}_{b0}(0)\end{aligned}</script><p>在初始状态下，世界坐标系到机身坐标系的齐次变换矩阵为</p><script type="math/tex; mode=display">\boldsymbol{T}_{sb}(0)=\left[\begin{matrix}{\boldsymbol{R}_{sb}}&{\boldsymbol{O}_{s}}\\{\boldsymbol{0}_{1\times3}}&{1}\\\end{matrix}\right]=\left[\begin{matrix}{\boldsymbol{I}_{3}}&{-\boldsymbol{p}_{b0}(0)}\\{\boldsymbol{0}_{1\times3}}&{0}\\\end{matrix}\right]</script><p>此时改变机身姿态，将其分解为平移与旋转 $\left\{<br>\begin{aligned}<br>\text{平移}&amp;\quad p_d\\<br>\text{旋转}&amp;\quad rpy(\alpha\beta\gamma)<br>\end{aligned}<br>\right.$ </p><script type="math/tex; mode=display">\boldsymbol{T}_{sb}=\left[\begin{matrix}\boldsymbol{R}_{z}(\alpha)\boldsymbol{R}_{y}(\beta)\boldsymbol{R}_{x}(\gamma)&-\boldsymbol{p}_{b0}(0)+\boldsymbol{p}_{d}\\\boldsymbol{0}_{1\times3}&1\end{matrix}\right]</script><p>即可求出机身坐标系下的足端坐标</p><script type="math/tex; mode=display">\boldsymbol{p}_{bi}=\boldsymbol{T}_{bs}\cdot \boldsymbol{p}_{si}=\boldsymbol{T}_{sb}^{-1}\cdot \boldsymbol{p}_{si}</script><p>经过平移可以得到机器人单腿坐标系下的足端坐标，通过运动学逆解可以得到关节角度。</p><h4 id="足端速度"><a href="#足端速度" class="headerlink" title="足端速度"></a>足端速度</h4><p>足端速度由两方面叠加产生</p><ol><li>关节转动产生的足端速度，利用雅可比矩阵可以求得： $\boldsymbol{v}_{bj}=\boldsymbol{J}\dot{\boldsymbol{\theta}}$ </li><li>机身移动或旋转产生的足端速度： $\boldsymbol{v}_{be}$ ，此项待求</li></ol><p>首先考虑刚体上一点的速度与加速度。在刚体平移或转动时，对于刚体上位置为 $\boldsymbol{p}$ 的质点$ P$ ，只考虑平移不考虑旋转，即只需要研究速度 $\dot{\boldsymbol{p}}$ 与加速度 $\ddot{\boldsymbol{p}}$ 。</p><p>设刚体在 $\{b\}$ 中的平移速度为 $\boldsymbol{v}_b$ 、旋转速度为 $\boldsymbol{\omega}_b$ ，即原点 $\boldsymbol{p}_O$ 的平移速度为 $\boldsymbol{v}_b$ 。刚体上位于 $\boldsymbol{p}_P$ 的质点以 $\boldsymbol{v}_b$ 平移，以 $\boldsymbol{\omega}_b$ 绕 $\boldsymbol{p}_O$ 旋转，则：</p><script type="math/tex; mode=display">\dot{\boldsymbol{p}}_P=\boldsymbol{v}_b+\boldsymbol{w}_b\times(\boldsymbol{p}_P-\boldsymbol{p}_O)=\boldsymbol{v}_b+[\boldsymbol{w}_b]_\times(\boldsymbol{p}_P-\boldsymbol{p}_O)</script><p>对等式两边求导可得：</p><script type="math/tex; mode=display">\begin{aligned}\ddot{\boldsymbol{p}}_P&=\dot{\boldsymbol{v}}_b+[\dot{\boldsymbol{\omega}}_b]_\times(\boldsymbol{p}_P-\boldsymbol{p}_O)+[\boldsymbol{\omega}_b]_\times(\dot{\boldsymbol{p}}_P-\dot{\boldsymbol{p}}_O)\quad\text{其中 }\dot{\boldsymbol{p}}_O=\boldsymbol{v}_b\\&=\dot{\boldsymbol{v}}_b+[\boldsymbol{\omega}_b]_\times(\boldsymbol{p}_P-\boldsymbol{p}_O)+[\boldsymbol{\omega}_b]_\times[\boldsymbol{\omega}_b]_\times(\boldsymbol{p}_P-\boldsymbol{p}_O)\end{aligned}</script><p>当前时刻原点与 $\{b\}$ 重合，$\boldsymbol{p}_O=\boldsymbol{0}$  ，则:</p><script type="math/tex; mode=display">\begin{aligned}\dot{\boldsymbol{p}}_P&=\boldsymbol{v}_b+[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_P\\\ddot{\boldsymbol{p}}_P&=\dot{\boldsymbol{v}}_b+[\dot{\boldsymbol{\omega}}_b]_\times \boldsymbol{p}_P+[\boldsymbol{\omega}_b]_\times[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_P\end{aligned}\tag{4}</script><p>将机器人视为刚体，足端牵连速度为：（式中的bfB代表：{b}下feet2body）</p><script type="math/tex; mode=display">\boldsymbol{v}_{be}=\boldsymbol{v}_b+[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_{bfB}</script><p>结合开头的叠加， $\{s\}$ 下足端的速度可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{v}_{sf}&=\boldsymbol{R}_{sb}\left(\boldsymbol{v}_{be}+\boldsymbol{v}_{bj}\right)\\&=\boldsymbol{R}_{sb}\boldsymbol{v}_{b}+\boldsymbol{R}_{sb}[\boldsymbol{\omega}_{b}]_\times \boldsymbol{p}_{bfB}+J\dot{\theta})\\&=\boldsymbol{v}_{s}+\boldsymbol{R}_{sb}([\boldsymbol{\omega}_{b}]_\times \boldsymbol{p}_{bfB}+J\dot{\theta})\end{aligned}</script><p>但式中的 $\boldsymbol{v}_s$ 无法测得。</p><p> $\{s\}$ 下足端相对于机身的速度可以表示为：</p><script type="math/tex; mode=display">\boldsymbol{v}_{sfB}=\boldsymbol{v}_{sf}-\boldsymbol{v}_{s}=\boldsymbol{R}_{sb}([\boldsymbol{\omega}_{b}]_\times \boldsymbol{p}_{bfB}+J\dot{\theta})\tag{5}</script><h3 id="四足动力学"><a href="#四足动力学" class="headerlink" title="四足动力学"></a>四足动力学</h3><h4 id="单刚体动力学"><a href="#单刚体动力学" class="headerlink" title="单刚体动力学"></a>单刚体动力学</h4><p>对于密度 $\rho(x,y,z)$ ，质量 $m=\int_z\int_y\int_x\rho(x,y,z)\mathrm{d}x\mathrm{d}y\mathrm{d}z=\int_B\rho\mathrm{d}V$ 的单刚体，将物体坐标系 $\{b\}$ 建在重心上，则 $\int_{B}\rho \boldsymbol{p}_{b}\mathrm{d}V=\boldsymbol{0}_{3\times1}$ ， $\int_{B}\rho [\boldsymbol{p}_{b}]\mathrm{d}V=\boldsymbol{0}_{3\times3}$ 。</p><p>根据牛二定律 $F=ma$ 与式 $(4)$ ，可以求出重心处所受的合外力 $\boldsymbol{f}_b$ ：</p><script type="math/tex; mode=display">\boldsymbol{f}_{b}=\int_{B}\rho \ddot{\boldsymbol{p}}_{b}\mathrm{d}V=\int_{B}\rho(\dot{\boldsymbol{v}}_{b}+[\dot{\boldsymbol{\omega}}_{b}]_\times \boldsymbol{p}_{b}+[\boldsymbol{\omega}_b]_\times[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_{b})\mathrm{d}V</script><p>提取常量 $\boldsymbol{v}_b$ 和 $\boldsymbol{\omega}_b$ ：</p><script type="math/tex; mode=display">\boldsymbol{f}_{b}=\dot{\boldsymbol{v}}_{b}\int_{B}\rho \mathrm{d}V+[\dot{\boldsymbol{\omega}}_{b}]_\times \int_{B}\rho \boldsymbol{p}_{b}dV+[\boldsymbol{\omega}_{b}]_\times [\boldsymbol{\omega}_{b}]_\times \int_{B}\rho \boldsymbol{p}_{b}\mathrm{d}V</script><p>第一项中的 $\int_{B}\rho \mathrm{d}V=m$ ， $\int_{B}\rho \boldsymbol{p}_{b}dV=0$ ，则上式整理为：</p><script type="math/tex; mode=display">\boldsymbol{f}_b = m \dot{\boldsymbol{v}}_b\tag{6}</script><p>计算重心处的合外力矩（力矩的计算公式为 $\boldsymbol{M}=\boldsymbol{p}\times \boldsymbol{f}$ ）：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{M}_b&=\int_{B}\left[\boldsymbol{p}_{b}\right]_\times\mathrm{d}\boldsymbol{f}=\int_{B}\left[\boldsymbol{p}_{b}\right]_\times\rho \ddot{\boldsymbol{p}}_{b}\mathrm{d}V\\&=\underset{①}{\underline{\int_{B}\rho [\boldsymbol{p}_{b}]_\times\mathrm{d}V\cdot \dot{v}_{b}}}+\underset{②}{\underline{\int_{B}\rho[\boldsymbol{p}_{b}]_\times[\dot{\boldsymbol{\omega}}_{b}]_\times \boldsymbol{p}_{b}\mathrm{d}V}}+\underset{③}{\underline{\int_{B}\rho[\boldsymbol{p}_{b}]_\times[\boldsymbol{\omega}_b]_\times[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_{b}\mathrm{d}V}}\end{aligned}</script><p>分开看这三项：</p><ol><li><p>对于式①：</p><script type="math/tex; mode=display">\int_{B}\rho [\boldsymbol{p}_{b}]_\times\mathrm{d}V=0</script></li><li><p>对于式②：（ $\boldsymbol{a} \times \boldsymbol{b} = -\boldsymbol{b} \times \boldsymbol{a}$ ）</p><script type="math/tex; mode=display">\begin{aligned} \int_{B}\rho[\boldsymbol{p}_b]_\times[\dot{\boldsymbol{\omega}}_b]_\times \boldsymbol{p}_b\mathrm{d}V&=-\int_{B}\rho[\boldsymbol{p}_b]_\times[\boldsymbol{p}_b]_\times\dot{\boldsymbol{\omega}}_b\mathrm{d}V\\ &=\underline{\left(-\int_{B}\rho[\boldsymbol{p}_b]_\times[\boldsymbol{p}_b]_\times\mathrm{d}V\right)}\cdot\dot{\boldsymbol{\omega}}_b\\ &=\underline{\boldsymbol{I}_b}\dot{\boldsymbol{\omega}}_b \end{aligned}</script><p> 定义刚体惯性张量 $\boldsymbol{I}_b=-\int_{B}\rho[\boldsymbol{p}_b]_\times[\boldsymbol{p}_b]_\times\mathrm{d}V$ </p></li><li><p>对于式③：（ $[\boldsymbol{a}]_\times[\boldsymbol{b}]_\times \boldsymbol{c}=(\boldsymbol{a}^{T}\boldsymbol{c})\boldsymbol{b}-(\boldsymbol{a}^{T}\boldsymbol{b})\boldsymbol{c}$ ， $\boldsymbol{a}\times \boldsymbol{a}=[\boldsymbol{a}]_\times \boldsymbol{a}=\boldsymbol{0}$ ）</p><script type="math/tex; mode=display">\begin{aligned}\int_{\mathcal{B}}\rho[\boldsymbol{p}_b]_\times[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b\mathrm{d}V&=\int_{\mathcal{B}}\rho[\boldsymbol{p}_b]_\times\left[(\boldsymbol{\omega}_b^T\boldsymbol{p}_b)\boldsymbol{\omega}_b-(\boldsymbol{\omega}_b^T\boldsymbol{\omega}_b)\boldsymbol{p}_b\right]\mathrm{d}V\\&=\int_{\mathcal{B}}\rho[(\boldsymbol{\omega}_b^T\boldsymbol{p}_b)[\boldsymbol{p}_b]_\times\boldsymbol{\omega}_b-(\boldsymbol{\omega}_b^T\boldsymbol{\omega}_b)[\boldsymbol{p}_b]_\times \boldsymbol{p}_b]\mathrm{d}V\\&=\int_{\mathcal{B}}\rho[(\boldsymbol{\omega}_b^T\boldsymbol{p}_b)[\boldsymbol{p}_b]_\times\boldsymbol{\omega}_b-\boldsymbol{0}]\mathrm{d}V\\&=-\int_{\mathcal{B}}\rho[(\boldsymbol{\omega}_b^T\boldsymbol{p}_b)[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b-\boldsymbol{0}]\mathrm{d}V\\&=-\int_B\rho[(\boldsymbol{\omega}_b+\boldsymbol{p}_b)[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b-(\boldsymbol{p}_b^T\boldsymbol{p}_b)[\boldsymbol{\omega}_b]_\times \boldsymbol{\omega}_b]\mathrm{d}V\\&=-\int_B\rho[\boldsymbol{\omega}_b]_\times[(\boldsymbol{\omega}_b^T\boldsymbol{p}_b)\boldsymbol{p}_b-(\boldsymbol{p}_b^T\boldsymbol{p}_b)\boldsymbol{\omega}_b]\mathrm{d}V\\&=-\int_{B}\rho[\boldsymbol{\omega}_b]_\times[\boldsymbol{p}_b]_\times[\boldsymbol{p}_b]_\times\boldsymbol{\omega}_b\mathrm{d}V\\&=[\boldsymbol{\omega}_b]_\times\left(\underline{-\int_{B}\rho[\boldsymbol{p}_b]_\times[\boldsymbol{p}_b]_\times\mathrm{d}V}\right)\boldsymbol{\omega}_b\\&=[\boldsymbol{\omega}_b]_\times\underline{\boldsymbol{I}_{b}}\boldsymbol{\omega}_b\end{aligned}</script><p>倒数第二项的下划线部分即为惯性张量。</p></li></ol><p>综上可以得到旋转刚体的欧拉方程：</p><script type="math/tex; mode=display">M_b=\boldsymbol{I}_{b}\dot{\boldsymbol{\omega}}_{b}+[\boldsymbol{\omega}_{b}]_\times \boldsymbol{I}_{b}\boldsymbol{\omega}_{b}\tag{7}</script><p>上式中的惯性张量：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{I}_{b}& =-\int_{B}\rho[\boldsymbol{p}_{b}]_\times[\boldsymbol{p}_{b}]_\times\mathrm{d}V  \\&=-\int_{B}\rho\left[\begin{matrix}{0}&{-p_{z}}&{p_{y}}\\{p_{z}}&{0}&{-p_{x}}\\{-p_{y}}&{p_{x}}&{0}\\\end{matrix}\right]\left[\begin{matrix}{0}&{-p_{z}}&{p_{y}}\\{p_{z}}&{0}&{-p_{x}}\\{-p_{y}}&{p_{x}}&{0}\\\end{matrix}\right]\mathrm{d}V \\&=\int_{B}\rho\left[\begin{matrix}{p_{y}^{2}+p_{z}^{2}}&{-p_{x}p_{y}}&{-p_{x}p_{z}}\\{-p_{x}p_{y}}&{p_{x}^{2}+p_{z}^{2}}&{-p_{y}p_{z}}\\{-p_{x}p_{z}}&{-p_{y}p_{z}}&{p_{x}^{2}+p_{y}^{2}}\\\end{matrix}\right]\mathrm{d}V \\&=\begin{bmatrix}I_{xx}&I_{xy}&I_{xz}\\I_{xy}&I_{yy}&I_{yz}\\I_{xz}&I_{yz}&I_{zz}\end{bmatrix}\end{aligned}</script><p>即可以得到下面的结论。可以计算形状不规则、密度不均匀的物体。</p><script type="math/tex; mode=display">\begin{cases}\boldsymbol{I}_{xx}=\int_{B}\rho\left(p_y^2+p_z^2\right)\mathrm{d}V\\\boldsymbol{I}_{yy}=\int_{B}\rho\left(p_x^2+p_z^2\right)\mathrm{d}V\\\boldsymbol{I}_{zz}=\int_{B}\rho\left(p_x^2+p_y^2\right)\mathrm{d}V\\\boldsymbol{I}_{xy}=-\int_{B}\rho p_xp_y\mathrm{d}V\\\boldsymbol{I}_{xz}=-\int_{B}\rho p_xp_z\mathrm{d}V\\\boldsymbol{I}_{yz}=-\int_{B}\rho p_yp_z\mathrm{d}V\end{cases}</script><p>例如对于长方体：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230831155100793.png" alt="image-20230831155100793" style="zoom:50%;"></p><script type="math/tex; mode=display">\boldsymbol{I}_b=\frac1{12}\begin{bmatrix}m(\omega^2+h^2)&0&0\\0&m(l^2+h^2)&0\\0&0&m(l^2+\omega^2)\end{bmatrix}</script><p>在机身坐标系中， $\boldsymbol{I}_b$ 为常量（只与形状、密度分布有关），刚体旋转后世界坐标系下的 $\boldsymbol{I}_s$ 会改变。</p><h4 id="单刚体动能"><a href="#单刚体动能" class="headerlink" title="单刚体动能"></a>单刚体动能</h4><p>由式 $(4)$ ，可以得到刚体整体的动能：（ $v_x^2+v_y^2+v_z^2=\boldsymbol{v}^T\boldsymbol{v}$ ）</p><script type="math/tex; mode=display">\begin{aligned}K&=\int_B\frac{1}{2}\rho \boldsymbol{v}^T\boldsymbol{v}\mathrm{d}V\\&=\frac12\int_B\rho(\boldsymbol{v}_b+[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b)^T(\boldsymbol{v}_b+[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b)\mathrm{d}V\\&=\frac12\int_B\rho(\boldsymbol{v}_b^T+\boldsymbol{p}_b^T[\boldsymbol{\omega}_b]_\times^T)\left(\boldsymbol{v}_b+[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b\right)\mathrm{d}V\\&=\underset{①}{\underline{\frac12\int_B\rho \underset{与\boldsymbol{v}_b有关}{\underline{\boldsymbol{v}_b^T\boldsymbol{v}_b}}\mathrm{d}V}}+\underset{②}{\underline{\frac12\boldsymbol{v}_b^T[\boldsymbol{\omega}_b]_\times\underset{0}{\underline{\int _B\rho \boldsymbol{p}_b\mathrm{d}V}}}}+\underset{③}{\underline{\frac12\underset{0}{\underline{\int_B\rho \boldsymbol{p}_b^T\mathrm{d}V}}[\boldsymbol{\omega}_b]_\times^T\boldsymbol{v}_b}}+\underset{④}{\underline{\frac12\int_B\rho \boldsymbol{p}_b^T\underset{与\boldsymbol{\omega}_b有关}{\underline{[\boldsymbol{\omega}_b]_\times^T[\boldsymbol{\omega}_b]_\times}}\boldsymbol{p}_b\mathrm{d}V}}\end{aligned}</script><p>分开看这四项：</p><ol><li><p>式②、③为0</p></li><li><p>式①与 $\boldsymbol{v}_b$ 有关，定义为移动动能 $K_m$ </p><script type="math/tex; mode=display">\begin{aligned}K_{m}=& \frac{1}{2}\int_{B}\rho \boldsymbol{v}_{b}^{\mathrm{T}}\boldsymbol{v}_{b}\:\mathrm{d}V  \\=& \frac{1}{2}\int_{B}\rho\:\mathrm{d}V\boldsymbol{v}_{b}^{\mathrm{T}}\boldsymbol{v}_{b}  \\=& \frac{1}{2}m\boldsymbol{v}_{b}^{\mathrm{T}}\boldsymbol{v}_{b} \end{aligned}</script></li><li><p>式③与 $\boldsymbol{\omega}_b$ 有关，定义为转动动能 $K_t$ </p><script type="math/tex; mode=display">\begin{aligned}K_t&=\frac12\int_B\rho \boldsymbol{p}_b^T[\boldsymbol{\omega}_b]_\times^T[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b\mathrm{d}V\\&=-\frac12\int_B\rho \boldsymbol{p}_b^T[\boldsymbol{\omega}_b]_\times[\boldsymbol{\omega}_b]_\times \boldsymbol{p}_b\mathrm{d}V\\&=-\frac{1}{2}\int_{B}\rho \boldsymbol{p}_{b}^{T}[(\boldsymbol{\omega}_{b}^{T}\boldsymbol{p}_{b})\boldsymbol{\omega}_{b}-(\boldsymbol{\omega}_{b}^{T}\boldsymbol{\omega}_{b})\boldsymbol{p}_{b}]dV \\&=-\frac{1}{2}\int_{B}\rho [(\boldsymbol{\omega}_{b}^{T}\boldsymbol{p}_{b})(\boldsymbol{p}_{b}^{T}\boldsymbol{\omega}_{b})-(\boldsymbol{\omega}_{b}^{T}\boldsymbol{\omega}_{b})(\boldsymbol{p}_{b}^{T}\boldsymbol{p}_{b})]dV \\&=-\frac{1}{2}\int_{B}\rho [(\boldsymbol{p}_{b}^{T}\boldsymbol{\omega}_{b})(\boldsymbol{\omega}_{b}^{T}\boldsymbol{p}_{b})-(\boldsymbol{p}_{b}^{T}\boldsymbol{p}_{b})(\boldsymbol{\omega}_{b}^{T}\boldsymbol{\omega}_{b})]dV \\&=-\frac{1}{2}\int_{B}\rho \boldsymbol{\omega}_{b}^{T}\left[(\boldsymbol{p}_{b}^{T}\boldsymbol{\omega}_{b})\boldsymbol{p}_{b}-(\boldsymbol{p}_{b}^{T}\boldsymbol{p}_{b})\boldsymbol{\omega}_{b}\right]dV \\&=\frac{1}{2}\boldsymbol{\omega}_{b}^{T}\int_{B}-\rho[\boldsymbol{p}_{b}]_\times[\boldsymbol{p}_{b}]_\times\boldsymbol{\omega}_{b}dV \\&=\frac{1}{2}\boldsymbol{\omega}_b^{T}\boldsymbol{I}_{b}\boldsymbol{\omega}_b\end{aligned}</script><p>在不同坐标系下，刚体的转动动能 $K_t$ 相等。又由 $\boldsymbol{\omega}_{b}=\boldsymbol{R}_{bs}\boldsymbol{\omega}_{s}$ ，故：</p><script type="math/tex; mode=display">\begin{aligned}K_{st}& =K_{bt}  \\\frac{1}{2}\boldsymbol{\omega}_{s}^{\mathrm{T}}\boldsymbol{I}_{s}\boldsymbol{\omega}_{s}& =\frac12\boldsymbol{\omega}_b^\mathrm{T}\boldsymbol{I}_b\boldsymbol{\omega}_b  \\\boldsymbol{\omega}_{s}^{\mathrm{T}}\boldsymbol{I}_{s}\boldsymbol{\omega}_{s}& =(\boldsymbol{R}_{bs}\boldsymbol{\omega}_{s})^{\mathrm{T}}\boldsymbol{I}_{b}(\boldsymbol{R}_{bs}\boldsymbol{\omega}_{s})  \\\boldsymbol{\omega}_{s}^{\mathrm{T}}\boldsymbol{I}_{s}\boldsymbol{\omega}_{s}& =\boldsymbol{\omega}_{s}^{\mathrm{T}}(\boldsymbol{R}_{sb}\boldsymbol{I}_{b}\boldsymbol{R}_{sb}^{\mathrm{T}})\boldsymbol{\omega}_{s} \\\boldsymbol{I}_{s}&=\boldsymbol{R}_{sb}\boldsymbol{I}_{b}\boldsymbol{R}_{sb}^\mathrm{T}\end{aligned}</script><p>由此可以得到世界坐标系下刚体的惯性张量，这将在下一节中被用到。</p></li></ol><h4 id="四足动力学-1"><a href="#四足动力学-1" class="headerlink" title="四足动力学"></a>四足动力学</h4><p>目标：找到足端力与机器人运动的联系。</p><p>由式 $(6)$ 和 $(7)$ 可以得到：</p><script type="math/tex; mode=display">\begin{cases}\boldsymbol{f}_b=m\dot{\boldsymbol{v}}_b\\\boldsymbol{M}_b=\boldsymbol{I}_b\dot{\boldsymbol{\omega}}_b+\underline{[\boldsymbol{\omega}_b]_\times \boldsymbol{I}_b\boldsymbol{\omega}_b}\end{cases}</script><p>由于四足机器人运动时一般不会快速旋转，上式中 $\boldsymbol{\omega}_b$ 很小，故划线部分可以忽略。则上式变为：</p><script type="math/tex; mode=display">\begin{cases}\boldsymbol{f}_b=m\dot{\boldsymbol{v}}_b\\\boldsymbol{M}_b=\boldsymbol{I}_b\dot{\boldsymbol{\omega}}_b\end{cases}</script><p>在世界坐标系中同样满足上式，即为：</p><script type="math/tex; mode=display">\begin{cases}\boldsymbol{f}_s=m\dot{\boldsymbol{v}}_s\\\boldsymbol{M}_s=\boldsymbol{I}_s\dot{\boldsymbol{\omega}}_s=\boldsymbol{R}_\mathrm{sb}\boldsymbol{I}_{b}\boldsymbol{R}_\mathrm{sb}^\mathrm{T}\dot{\boldsymbol{\omega}}_s\end{cases}</script><p>其中，合外力 $\boldsymbol{f}_s$ 由两部分组成：</p><ol><li>重力 $mg$ </li><li>足端力 $\boldsymbol{f}_{is}$ </li></ol><p>合力矩 $\boldsymbol{M}_s$ 由两部分组成：</p><ol><li>重力穿过重心，力矩为 $0$ </li><li>足端力对重心的力矩 $\boldsymbol{p}_{gi}\times \boldsymbol{f}_{is} = [\boldsymbol{p}_{gi}]\boldsymbol{f}_{is}$ </li></ol><p>则：</p><script type="math/tex; mode=display">\left\{\begin{aligned}&mg+\sum_{i=0}^3\boldsymbol{f}_{is}=m\dot{\boldsymbol{v}}_s\\&\sum_{i=0}^3[\boldsymbol{p}_{ig}]_\times \boldsymbol{f}_{is}=\boldsymbol{R}_{sb}\boldsymbol{I}_b\boldsymbol{R}_{sb}^\mathrm{T}\dot{\boldsymbol{\omega}}_s\end{aligned}\right.\tag{8}</script><p>整理成矩阵形式</p><script type="math/tex; mode=display">\begin{bmatrix}\boldsymbol{I}&\boldsymbol{I}&\boldsymbol{I}&\boldsymbol{I}\\[\boldsymbol{p}_{g0}]_\times&[\boldsymbol{p}_{g1}]_\times&[\boldsymbol{p}_{g2}]_\times&[\boldsymbol{p}_{g3}]_\times\end{bmatrix}\begin{bmatrix}\boldsymbol{f}_{s0}\\\boldsymbol{f}_{s1}\\\boldsymbol{f}_{s2}\\\boldsymbol{f}_{s3}\end{bmatrix}=\begin{bmatrix}m(\dot{\boldsymbol{v}}_s-g)\\\boldsymbol{R}_{sb}\boldsymbol{I}_b\boldsymbol{R}_{sb}^\mathrm{T}\dot{\boldsymbol{\omega}}_s\end{bmatrix}</script><p>此时完成了足端力与机器人运动的联系。但此时无法获得机器人姿态 $\boldsymbol{R}_{sb}$ ，且需要知道机器人在世界坐标系下的 $\boldsymbol{v}_s$ 、 $\boldsymbol{\omega}_s$ 。获取这些信息需要用到下一章的状态估计器。</p><h2 id="状态估计器"><a href="#状态估计器" class="headerlink" title="状态估计器"></a>状态估计器</h2><p>状态估计器是四足机器人系统中比较重要的一环节，通过状态估计器可以获得四足机器人质心位姿（位置和姿态角）及速度。姿态角可根据IMU通过坐标变换得到；位置和速度需要使用最小二乘法或卡尔曼滤波器求得，最终将质心位姿和速度作为机械狗的MPC+WBC控制器及单刚体动力学的反馈输入，进而形成了整个系统的闭环控制。本章节分别介绍最小二乘估计和离散卡尔曼滤波器这两个优化方法。</p><h3 id="最小二乘与卡尔曼滤波"><a href="#最小二乘与卡尔曼滤波" class="headerlink" title="最小二乘与卡尔曼滤波"></a>最小二乘与卡尔曼滤波</h3><p>在讲状态估计器之前有必要介绍一下最小二乘和卡尔曼滤波的关系。线性回归是一类问题的概念，而最小二乘估计、最小均方误差估计是参数估计方法，最小二乘法、Kalman、梯度下降都是参数优化方法。<strong>最小二乘是优化方法中的一种特殊情况，卡尔曼滤波是最小二乘法的一种特殊情况。</strong> 古典最小二乘中，假设了每一次测量的权重相同，但事实上这样并不合理，后来演化为加权最小二乘法，至此最小二乘估计所做的都是批处理（Batch），这样比较占内存，不符合动态系统状态估计的需要，即每一次更新输入时，都要从新计算之前所有的记录值。而后，提出递推最小二乘法，模型就不用每次都重新计算了。与递归最小二乘相似，卡尔曼滤波加入了系统内部变化的考虑。即利用process model对系统在下一时刻的状态进行预测。 当对于系统不够了解时，使用最小二乘法比较合适，而对于系统了解比较多时，可以采用Kalman滤波。改变量测噪声、系统噪声都会对Kalman滤波的效果产生影响，而不会对最小二乘滤波产生影响，而改变最小二乘的阶数会对其产生影响。</p><h3 id="使用IMU获得姿态"><a href="#使用IMU获得姿态" class="headerlink" title="使用IMU获得姿态"></a>使用IMU获得姿态</h3><p>使用IMU可以估计质心姿态。现有的IMU基本都可以返回四元数 $\boldsymbol{q}=\begin{bmatrix}w\\x\\y\\z\end{bmatrix}$ ，经过计算即可获得质心姿态角，其公式如下：</p><script type="math/tex; mode=display">\boldsymbol{R}_{sb} = \begin{bmatrix}1-2 y^{2}-2 z^{2} & 2 x y-2 z w & 2 x z+2 y w \\2 x y+2 z w & 1-2 x^{2}-2 z^{2} & 2 y z-2 x w \\2 x z-2 y w & 2 y z+2 x w & 1-2 x^{2}-2 y^{2}\end{bmatrix}</script><p>当然，也可以通过旋转矩阵转成欧拉角（Roll、Pitch、Yaw）：</p><script type="math/tex; mode=display">\begin{aligned}\text{Roll} &= \arctan2\left(\boldsymbol{R}_{sb}(3,2), \boldsymbol{R}_{sb}(3,3)\right) \\\text{Pitch} &= \arcsin\left(-\boldsymbol{R}_{sb}(3,1)\right) \\\text{Yaw} &= \arctan2\left(\boldsymbol{R}_{sb}(2,1), \boldsymbol{R}_{sb}(1,1)\right)\end{aligned}</script><p>在IMU的局部坐标系 $\{b\}$ 中：</p><script type="math/tex; mode=display">\begin{aligned}m\boldsymbol{a}&=-k\boldsymbol{s}+m\boldsymbol{R}_{bs}\boldsymbol{g}\\\boldsymbol{s}&=\frac{m}{k}(\boldsymbol{R}_{bs}\boldsymbol{g}-\boldsymbol{a})\end{aligned}</script><p>上式中由于重力加速度 $\boldsymbol{g}=\begin{bmatrix}0\\ 0 \-9.8\end{bmatrix}$ 是世界坐标系下的，所以需要左乘旋转矩阵 $\boldsymbol{R}_{bs}$ 。则加速度计的读数为：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{a}_b=\boldsymbol{a}_{out}=-\frac{k}{m}\boldsymbol{s}&=\boldsymbol{a}-\boldsymbol{R}_{bs}\boldsymbol{g}=\boldsymbol{a}-\boldsymbol{R}_{sb}^\mathrm{T}\boldsymbol{g}\end{aligned}</script><p>上述公式建立了加速度计读数与质心姿态的关系，通过左乘旋转矩阵可以计算出IMU在 $\{s\}$ 坐标系下的加速度：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{a}_{s}& =\boldsymbol{R}_{sb}\boldsymbol{a}  \\&=\boldsymbol{R}_{sb}\boldsymbol{a}_{b}+\boldsymbol{R}_{sb}\boldsymbol{R}_{sb}^{T}\boldsymbol{g} \\&=\boldsymbol{R}_{sb}\boldsymbol{a}_{b}+\boldsymbol{g}\end{aligned}\tag{9}</script><h3 id="状态空间模型"><a href="#状态空间模型" class="headerlink" title="状态空间模型"></a>状态空间模型</h3><p>状态估计器需要一个描述四足机器人运动状态的状态空间模型。对于一个状态空间模型需要对其进行能控性和能观性的分析，来判断此学系统是否能够被输入所控制，但本文省略这一部分的内容。本章节先介绍连续状态空间模型，再推出离散状态空间模型。</p><h4 id="连续状态空间模型"><a href="#连续状态空间模型" class="headerlink" title="连续状态空间模型"></a>连续状态空间模型</h4><p>“连续”指的是时间连续、定常线性系统的状态空间模型：</p><script type="math/tex; mode=display">\begin{cases}\dot{\boldsymbol{x}}(t)=\boldsymbol{A}_c \boldsymbol{x}(t)+\boldsymbol{B}_c \boldsymbol{u}(t)\\\boldsymbol{y}(t)=\boldsymbol{C}_c \boldsymbol{x}(t)\end{cases}\tag{10}</script><p>其中：</p><ul><li>$\boldsymbol{x}(t)$ ：状态向量</li><li>$\boldsymbol{u}(t)$ ：控制向量</li><li>$\boldsymbol{y}(t)$ ：输出向量</li><li>$\boldsymbol{A}_c$ ：系统矩阵</li><li>$\boldsymbol{B}_c$ ：输入矩阵</li><li>$\boldsymbol{C}_c$ ：输出矩阵</li></ul><p>则 $\boldsymbol{x}$ 应为要估计的量， $\boldsymbol{y}$ 为能直接测量的量。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230731130212268.png" alt="image-20230731130212268" style="zoom: 33%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230731130302869.png" alt="image-20230731130302869" style="zoom: 33%;"></p><p>令机身加速度 $\boldsymbol{a}_s$ 为系统输入量 $\boldsymbol{u}$ ，上式可变为标准形式：</p><script type="math/tex; mode=display">\dot{\boldsymbol{x}}=\begin{bmatrix}\boldsymbol{0}_{3\times3}&\boldsymbol{I}_3&\boldsymbol{0}_{3\times12}\\&\boldsymbol{0}_{3\times18}&\\&\boldsymbol{0}_{3\times18}&\end{bmatrix}\boldsymbol{x}+\begin{bmatrix}\boldsymbol{0}_{3\times3}\\\boldsymbol{I}_3\\\boldsymbol{0}_{3\times3}\end{bmatrix}\begin{bmatrix}\boldsymbol{R}_{sb}\boldsymbol{a}_{b}+\boldsymbol{g}\end{bmatrix}\tag{11}</script><p>对于可测量的输出变量 $\boldsymbol{y}$ ，前文通过IMU可测得 $\{s\}$ 坐标系下的机身姿态 $\boldsymbol{R}_{sb}$ ； $\{b\}$ 下的加速度 $\boldsymbol{a_b}$ 、角速度 $\boldsymbol{\omega}_b$ ；通过正向运动学，可以求出 $\{b\}$ 坐标系下足端相对于机身的位置 $\boldsymbol{p}_{bfB}$ ，转换到 $\{s\}$ 坐标系下，即 $\boldsymbol{p}_{sfB}=\boldsymbol{R}_{sb}\boldsymbol{p}_{bfB}$ (式12)，即可写出输出变量：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230802125435769.png" alt="image-20230802125435769" style="zoom:50%;"></p><p>将其写成式 $(10)$ 的标准形式：(式13)</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230802125521114.png" alt="image-20230802125521114" style="zoom:50%;"></p><h4 id="离散状态空间模型"><a href="#离散状态空间模型" class="headerlink" title="离散状态空间模型"></a>离散状态空间模型</h4><p>由于控制算法运行于计算机，需要对连续的状态空间模型离散化，使状态空间变量均为时间的函数。设采样时间间隔为 $\mathrm{d}t$ ，则：</p><script type="math/tex; mode=display">\dot{\boldsymbol{x}}(k-1)=\frac{\boldsymbol{x}(k)-\boldsymbol{x}(k-1)}{dt}\Rightarrow \boldsymbol{x}(k)=\boldsymbol{x}(k-1)+\mathrm{d}t\dot{\boldsymbol{x}}(k-1)</script><p>将式 $(10)$ 带入</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{x}(k)&=\boldsymbol{x}(k-1)+\mathrm{d}t\left(\boldsymbol{A}_{c}\boldsymbol{x}(k-1)+\boldsymbol{B}_{c}\boldsymbol{u}(k-1)\right)\\&=\underline{(\boldsymbol{I}+\mathrm{d}t\boldsymbol{A}_{c})}\boldsymbol{x}(k-1)+\underline{\mathrm{d}t\boldsymbol{B}_{c}}\boldsymbol{u}(k-1)\end{aligned}</script><p>则离散状态空间模型可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}\begin{cases}\boldsymbol{x}(k)=\boldsymbol{A}\boldsymbol{x}(k-1)+\boldsymbol{B}\boldsymbol{u}(k-1)\\\boldsymbol{y}(k)=\boldsymbol{C}\boldsymbol{x}(k)\end{cases}\quad\text{其中}\begin{cases}\boldsymbol{A}=\boldsymbol{I}+\mathrm{d}t\boldsymbol{A}_{c}\\\boldsymbol{B}=\mathrm{d}t\boldsymbol{B}_{c}\\\boldsymbol{C}=\boldsymbol{C}_{c}\end{cases}\end{aligned}</script><h3 id="最小二乘估计"><a href="#最小二乘估计" class="headerlink" title="最小二乘估计"></a>最小二乘估计</h3><p>输出向量 $\boldsymbol{y}$ 的测量值中含有噪声向量 $\boldsymbol{v}$ ，假设状态向量 $\boldsymbol{x}_k$ 为定值 $\boldsymbol{x}$ ，离散状态空间中的 $\boldsymbol{y}$ 变为 $\boldsymbol{y}_k=\boldsymbol{C}\boldsymbol{x}+\boldsymbol{v}_k$ 。假设测量噪声 $\boldsymbol{v}\sim(0,\boldsymbol{R})$ ，其中 $\boldsymbol{R}$ 为协方差矩阵， $\boldsymbol{R}=\mathrm{diag}(\sigma_{1}^{2},\sigma_{2}^{2},\ldots,\sigma_{n}^{2})$ 。需要在有噪声的情况下获得状态向量的最优估计值 $\hat{\boldsymbol{x}}$ 。</p><h4 id="加权最小二乘估计"><a href="#加权最小二乘估计" class="headerlink" title="加权最小二乘估计"></a>加权最小二乘估计</h4><p>定义测量残差 $\boldsymbol{\epsilon}_{y}=\boldsymbol{y}-\boldsymbol{C}\hat{\boldsymbol{x}}$ 。根据各个传感器的误差方差定义为权重，方差越小权重越大。定义代价函数：</p><script type="math/tex; mode=display">\begin{aligned}J&=\frac{\boldsymbol{\epsilon}_{y_{1}}^{2}}{\sigma_{1}^{2}}+\frac{\boldsymbol{\epsilon}_{y_{2}}^{2}}{\sigma_{2}^{2}}+\cdots+\frac{\boldsymbol{\epsilon}_{y_{n}}^{2}}{\sigma_{n}^{2}}=\boldsymbol{\epsilon}_{y}^{T}\boldsymbol{R}^{-1}\boldsymbol{\epsilon}_{y}\\&=(\boldsymbol{y}-\boldsymbol{C}\hat{\boldsymbol{x}})^{T}\boldsymbol{R}^{-1}(\boldsymbol{y}-\boldsymbol{C}\hat{\boldsymbol{x}})\\&=\boldsymbol{y}^{T}\boldsymbol{R}^{-1}\boldsymbol{y}-\boldsymbol{y}^{T}\boldsymbol{R}^{-1}\boldsymbol{C}\hat{\boldsymbol{x}}-\hat{\boldsymbol{x}}^{T}\boldsymbol{C}^{T}\boldsymbol{R}^{-1}\boldsymbol{y}+\hat{\boldsymbol{x}}^{T}\boldsymbol{C}^{T}\boldsymbol{R}^{-1}\boldsymbol{C}\hat{\boldsymbol{x}}\\\end{aligned}</script><p>求 $J$ 的偏导数 $\frac{\partial J}{\partial\hat{\boldsymbol{x}}}=-2\boldsymbol{y}^{T}\boldsymbol{R}^{-1}\boldsymbol{C}+2\hat{\boldsymbol{x}}^{T}\boldsymbol{C}^{T}\boldsymbol{R}^{-1}\boldsymbol{C}$ ，令其为 $0$ ，可以计算出 $\hat{\boldsymbol{x}}=(\boldsymbol{C}^{T}\boldsymbol{R}^{-1}\boldsymbol{C})^{-1}\boldsymbol{C}^{T}\boldsymbol{R}^{-1}\boldsymbol{y}$ 。</p><p>但此方法需要使用一段时间内所有的测量值 $\boldsymbol{y}$ ，其计算量及内存占用太大，故改用递推公式。</p><h4 id="递推最小二乘估计"><a href="#递推最小二乘估计" class="headerlink" title="递推最小二乘估计"></a>递推最小二乘估计</h4><p>定义 $\hat{\boldsymbol{x}}$ 的递推公式：（其中 $\boldsymbol{K}_k$ 为最优修正系数矩阵）</p><script type="math/tex; mode=display">\begin{cases}\boldsymbol{y}_{k}=\boldsymbol{C}\boldsymbol{x}+\boldsymbol{v}_{k}\\\hat{\boldsymbol{x}}_{k}=\hat{\boldsymbol{x}}_{k-1}+\boldsymbol{K}_{k}(\boldsymbol{y}_{k}-\boldsymbol{C}\hat{\boldsymbol{x}}_{k-1})\end{cases}\tag{13}</script><p>定义 $k$ 时刻的状态估计误差：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{\omega}_k&=\hat{\boldsymbol{x}}-\hat{\boldsymbol{x}}_k=\hat{\boldsymbol{x}}-\hat{\boldsymbol{x}}_{k-1}-\boldsymbol{K}_k(\boldsymbol{y}_k-\boldsymbol{C}\hat{\boldsymbol{x}}_{k-1})\\&=\boldsymbol{\omega}_{k-1}-\boldsymbol{K}_k\boldsymbol{C}(\boldsymbol{x}-\hat{\boldsymbol{x}}_{k-1})-\boldsymbol{K}_k\boldsymbol{v}_k\\&=(\boldsymbol{I}-\boldsymbol{K}_k\boldsymbol{C})\boldsymbol{\omega}_{k-1}-\boldsymbol{K}_k\boldsymbol{v}_k\end{aligned}\tag{14}</script><p>再次使用二次规划，令 $k$ 时刻各状态估计误差方差和最小，则 $k$ 时刻的代价函数 $J_k$ 为：</p><script type="math/tex; mode=display">\begin{aligned}J_{k}&=E\left(\omega_{k1}^{2}+\omega_{k2}^{2}+\cdots+\omega_{kn}^{2}\right)\\&=\sigma_{k1}^{2}+\sigma_{k2}^{2}+\cdots+\sigma_{kn}^{2}\\&=\mathrm{Tr}\left(\boldsymbol{P}_{k}\right)\end{aligned}</script><p>估计误差协方差 $\boldsymbol{P}_{k}=E(\boldsymbol{\omega}_{k}\boldsymbol{\omega}_{k}^{T})$ ，将式 $(14)$ 带入可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{P}_{k}&=E(\boldsymbol{\omega}_{k}\boldsymbol{\omega}_{k}^{T})\\&=(\boldsymbol{I}-\boldsymbol{K}_k\boldsymbol{C})\boldsymbol{P}_{k-1}(\boldsymbol{I}-\boldsymbol{K}_k\boldsymbol{C})^T+\boldsymbol{K}_k\boldsymbol{R}\boldsymbol{K}_k^T\end{aligned}\tag{15}</script><p>目的为使 $J$ 最小，对其求偏导：</p><script type="math/tex; mode=display">\frac{\partial J_k}{\partial \boldsymbol{K}_k}=2(\boldsymbol{I}-\boldsymbol{K}_k \boldsymbol{C})\boldsymbol{P}_{k-1}(-\boldsymbol{C}^T)+2\boldsymbol{K}_k \boldsymbol{R}=0</script><p>解得最优的 $\boldsymbol{K}_k$ 为：</p><script type="math/tex; mode=display">\boldsymbol{K}_{k}=\boldsymbol{P}_{k-1}\boldsymbol{C}^{T}(\boldsymbol{R}+\boldsymbol{C}\boldsymbol{P}_{k-1}\boldsymbol{C}^{T})^{-1}\tag{16}</script><h4 id="最小二乘估计流程总结"><a href="#最小二乘估计流程总结" class="headerlink" title="最小二乘估计流程总结"></a>最小二乘估计流程总结</h4><ol><li>确定初始状态的最优估计值 $\hat{\boldsymbol{x}}_0$ 和估计值的协方差 $\boldsymbol{P}_0$ 。如果对系统状态 $\boldsymbol{x}$ 完全不了解，则可以将 $\hat{\boldsymbol{x}}_0$ 设为任意值，同时令 $\boldsymbol{P}_0 = \infty \boldsymbol{I}$ ，表示无穷大的协方差，即完全不信任 $\hat{\boldsymbol{x}}_0$ 。</li><li>估计器运行开始，在 $k=1$ 时刻，机器人从各个传感器得到输出向量 $\boldsymbol{y}_1$ ，并根据式 $(16)$ 计算出当前时刻的最优修正系数矩阵 $\boldsymbol{K}_1=\boldsymbol{P}_0\boldsymbol{C}^{T}(\boldsymbol{R}+\boldsymbol{C}\boldsymbol{P}_0\boldsymbol{C}^{T})^{-1}$ 。根据式 $(13)$ 可以计算出当前时刻的最优估计值 $\hat{\boldsymbol{x}}_1=\hat{\boldsymbol{x}}_0+\boldsymbol{K}_1(\boldsymbol{y}_1-\boldsymbol{C}\hat{\boldsymbol{x}}_0)$ 。根据式 $(15)$ 可以计算出估计误差协方差 $\boldsymbol{P}_1=(\boldsymbol{I}-\boldsymbol{K}_1\boldsymbol{C})\boldsymbol{P}_0(\boldsymbol{I}-\boldsymbol{K}_1\boldsymbol{C})^T+\boldsymbol{K}_1\boldsymbol{R}\boldsymbol{K}_1^T$ 。 </li><li>当 $k=2,3,\cdots $ ，估计器重复第二步，估计值 $\hat{\boldsymbol{x}}$ 不断逼近真实状态 $\boldsymbol{x}$ 。</li></ol><h4 id="过程噪声"><a href="#过程噪声" class="headerlink" title="过程噪声"></a>过程噪声</h4><p>前文假设状态向量为定值。若状态向量是变化的，增加过程噪声 $\boldsymbol{w}$ ，且其期望为0。则离散状态空间模型变为：</p><script type="math/tex; mode=display">\boldsymbol{x}_k=\boldsymbol{A}\boldsymbol{x}_{k-1}+\boldsymbol{B}\boldsymbol{u}_{k-1}+\boldsymbol{w}</script><p>状态期望为：</p><script type="math/tex; mode=display">\begin{aligned}\overline{\boldsymbol{x}_{k}}&=E(\boldsymbol{x}_{k})=\boldsymbol{A}E(\boldsymbol{x}_{k-1})+\boldsymbol{B}E(\boldsymbol{u}_{k-1})+\underset{0}{\underline{E(\boldsymbol{w}_{k-1}}})\\&=\boldsymbol{A}\overline{\boldsymbol{x}}_{k-1}+\boldsymbol{B}\overline{\boldsymbol{u}}_{k-1}\end{aligned}</script><p>状态向量 $\boldsymbol{x}_k$ 的协方差为：（ $\boldsymbol{Q}=\boldsymbol{w}\boldsymbol{w}^T$ 为过程噪声协方差）</p><script type="math/tex; mode=display">\begin{aligned}P_k&=E\left[(\boldsymbol{x}_k-\overline{\boldsymbol{x}}_k)(\boldsymbol{x}_k-\overline{\boldsymbol{x}}_k)^T\right]=\boldsymbol{A}\boldsymbol{P}_{k-1}\boldsymbol{A}^T+\boldsymbol{w}_{k-1}\boldsymbol{w}_{k-1}^T\\&=\boldsymbol{A}\boldsymbol{P}_{k-1}\boldsymbol{A}^T+\underline{\boldsymbol{Q}}\end{aligned}</script><h3 id="扩展卡尔曼滤波器"><a href="#扩展卡尔曼滤波器" class="headerlink" title="扩展卡尔曼滤波器"></a>扩展卡尔曼滤波器</h3><p>最小二乘估计只能对固定状态 $\boldsymbol{x}$ 进行估计，而扩展卡尔曼滤波器可以对变化的状态 $\boldsymbol{x}_k$ 进行估计。</p><p>TODO </p><h2 id="步态轨迹规划"><a href="#步态轨迹规划" class="headerlink" title="步态轨迹规划"></a>步态轨迹规划</h2><h3 id="落脚点的选取"><a href="#落脚点的选取" class="headerlink" title="落脚点的选取"></a>落脚点的选取</h3><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>TODO 图</p><p>上图为四足机器人的一条腿从抬起到落下的过程，分区看图中的几个过程：</p><ol><li>➂为中性落脚点</li><li>➀~➁阶段为摆动相，机器人速度为 $v_x$ ，摆动时间为 $T_{swing}$ ，则 $d_{12}=v_x T_{swing}$ 。</li><li>➁~➃阶段为支撑相，机器人速度为 $v_x$ ，触底时间为 $T_{stance}$ ，则 $d_{23}=\Delta x=\frac{1}{2} v_x T_{stance}$ 。</li></ol><p>图中落脚点 $x_{f}=x_{b}+d_{12}+d_{23}=x_{b}+v_x T_{swing}+\frac{1}{2}v_x T_{stance}$ </p><p>设相位 $p_{t}=\frac{t-t_{0}}{t_{1}-t_{0}}$ ，则落脚点变为 $x_f=x_{p}(p)+v_x(1-p)T_{swing}+\frac{1}{2}v_xT_{stance}$ </p><p>若落脚点位于中性落脚点左侧，重力会对落脚点产生顺时针的力矩从而向右加速，所以若 $v_x &lt; v_{xd}$ ，则需左移落脚点。</p><script type="math/tex; mode=display">\begin{cases}x_{f}=x_{p}(p)+v_{x}(1-p)T_{swing}+\frac{1}{2}v_{x}T_{stance}+k_{x}(v_{x}-v_{xd}) \\y_{f}=y_{p}(p)+v_{y}(1-p)T_{swing}+\frac12v_{y}T_{stance}+k_{y}(v_{y}-v_{yd})\end{cases}</script><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><script type="math/tex; mode=display">\theta_f=\theta_p+\theta_0+\omega(1-p)T_{swing}+\frac{1}{2}\omega T_{stance}+k_\omega(\omega-\omega_d)</script><p>则世界坐标系下的落脚点为</p><script type="math/tex; mode=display">\begin{cases}x_{f}=R\cos\theta_{f} \\y_{f}=R\sin\theta_{f}\end{cases}</script><p>结合平移与旋转，落脚点坐标为：</p><script type="math/tex; mode=display">\begin{cases}x_i=x_b+R\cos\theta_f+v_x(1-p)T_{swing}+\frac{1}{2}v_xT_{stance}+k_x(v_x-v_{xd})\\y_i=y_b+R\sin\theta_f+v_y(1-p)T_{swing}+\frac{1}{2}v_yT_{stance}+k_y(v_y-v_{yd})\end{cases}</script><h2 id="MPC控制器"><a href="#MPC控制器" class="headerlink" title="MPC控制器"></a>MPC控制器</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>通过MPC可以得到：</p><ol><li>质心位置、速度、加速度、旋转角度、角速度</li><li>足底力</li><li>足端位置、速度、加速度</li></ol><p>让机器狗质心跟踪最新的参考轨迹，计算未来一段时间内的足底力</p><h3 id="简化单刚体动力学"><a href="#简化单刚体动力学" class="headerlink" title="简化单刚体动力学"></a>简化单刚体动力学</h3><p>下面考虑单刚体动力学：</p><script type="math/tex; mode=display">\begin{aligned}\ddot{\boldsymbol{p}}=\frac{\sum_{i=1}^n\boldsymbol{f}_i}{m}-\boldsymbol{g}\\\frac{d}{dt}(\boldsymbol{I}\boldsymbol{\omega})=\sum_{i=1}^n\boldsymbol{r}_i\times \boldsymbol{f}_i\end{aligned}</script><p>对上式其进行简化</p><ol><li><p>$\frac{d}{dt}(\boldsymbol{I}\boldsymbol{\omega})=\boldsymbol{I}\boldsymbol{\omega}+\boldsymbol{\omega}\times(\boldsymbol{I}\boldsymbol{\omega})\approx \boldsymbol{I}\dot{\boldsymbol{\omega}}$ ，其中 $\boldsymbol{I}=\boldsymbol{R}\boldsymbol{I}_b\boldsymbol{R}^T\approx \boldsymbol{R}_z(\psi)\boldsymbol{I}_b\boldsymbol{R}_z^T(\psi)$ </p></li><li><p>简化pitch和row</p><p>IMU获得的角速度为身体坐标系：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{\omega}_{s}&=\boldsymbol{R}_{z}(\psi)\boldsymbol{R}_{y}(\theta)\boldsymbol{R}_{x}(\phi)\boldsymbol{\omega}_{b}\\\boldsymbol{\omega}_{b}&=\left[\boldsymbol{R}_{z}(\psi)\boldsymbol{R}_{y}(\theta)\boldsymbol{R}_{x}(\phi)\right]^{-1}\boldsymbol{\omega}_{s}\\\left[\begin{matrix}{\dot{\phi}}\\{\dot{\theta}}\\{\dot{\psi}}\\\end{matrix}\right]&=\left[\begin{matrix}{\cos(\psi)/\cos(\theta)}&{\sin(\psi)/\cos(\theta)}&{0}\\{-\sin(\psi)}&{\cos(\psi)}&{0}\\{\cos(\psi)\tan(\theta)}&{\sin(\psi)\tan(\theta)}&{1}\\\end{matrix}\right]\boldsymbol{\omega}\end{aligned}</script><p>在运动过程中机器人的pitch和row均接近于0，故可以忽略</p><script type="math/tex; mode=display">\begin{aligned}\begin{bmatrix}\dot{\phi}\\\dot{\theta}\\\dot{\psi}\end{bmatrix}&=\begin{bmatrix}\cos(\psi)&\sin(\psi)&0\\-\sin(\psi)&\cos(\psi)&0\\0&0&1\end{bmatrix}\boldsymbol{\omega}\\&=\boldsymbol{R}_z^T(\psi)\boldsymbol{\omega}\end{aligned}</script></li></ol><h3 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h3><p>下面写出状态方程：</p><ol><li><p>状态变量</p><p>位置 $\boldsymbol{p}=\begin{bmatrix}x\\y\\z\end{bmatrix}$ ，速度 $\dot{\boldsymbol{p}}=\begin{bmatrix}\dot{x}\\\dot{y}\\\dot{z}\end{bmatrix}$ ，姿态角 $\boldsymbol{\Theta}=\begin{bmatrix}\theta\\\phi\\\psi\end{bmatrix}$ ，姿态角速度 $\boldsymbol{\omega}=\begin{bmatrix}\dot{\theta}\\\dot{\phi}\\\dot{\psi}\end{bmatrix}$ ，重力加速度 $\boldsymbol{g}=\begin{bmatrix}{0}\\{0}\\{-9.8}\\\end{bmatrix}$ 。状态变量则为13维变量： $\boldsymbol{x}=\begin{bmatrix}\boldsymbol{\theta}\\\boldsymbol{p}\\\boldsymbol{w}\\\dot{\boldsymbol{p}}\\g(3)\end{bmatrix}$ 。</p></li><li><p>控制变量</p><p>控制变量为12维变量： $\boldsymbol{u}=\begin{bmatrix}\boldsymbol{f}_1\\\boldsymbol{f}_2\\\boldsymbol{f}_3\\\boldsymbol{f}_4\end{bmatrix}$ 。其中 $\boldsymbol{f}_i$ 为足底力。</p></li><li><p>状态方程</p><script type="math/tex; mode=display">\begin{cases}\dot{\boldsymbol{x}}=\boldsymbol{A}\boldsymbol{x}+\boldsymbol{B}\boldsymbol{u}\\\boldsymbol{y}=\boldsymbol{C}\boldsymbol{x}+\boldsymbol{D}\boldsymbol{u}\end{cases}</script><p>将各个已知量带入：</p><script type="math/tex; mode=display">\frac{d}{dt}\begin{bmatrix}\boldsymbol{\theta}\\\boldsymbol{p}\\\boldsymbol{\omega}\\\dot{\boldsymbol{p}}\\g(3)\end{bmatrix}=\begin{bmatrix}\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{R}_{z}^{T}(\psi)&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times1}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{I}_{3}&\boldsymbol{0}_{3\times1}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times1}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\left[\begin{smallmatrix}0\\0\\1\end{smallmatrix}\right]\\\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&1\end{bmatrix}\begin{bmatrix}\boldsymbol{\theta}\\\boldsymbol{p}\\\boldsymbol{\omega}\\\dot{\boldsymbol{p}}\\g(3)\end{bmatrix}+\begin{bmatrix}\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}\\\boldsymbol{I}^{-1}[\boldsymbol{r}_1]_\times&\boldsymbol{I}^{-1}[\boldsymbol{r}_2]_\times&\boldsymbol{I}^{-1}[\boldsymbol{r}_3]_\times&\boldsymbol{I}^{-1}[\boldsymbol{r}_4]_\times\\\boldsymbol{I}_3/m&\boldsymbol{I}_3/m&\boldsymbol{I}_3/m&\boldsymbol{I}_3/m\\\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}\end{bmatrix}\begin{bmatrix}\boldsymbol{f}_1\\\boldsymbol{f}_2\\\boldsymbol{f}_3\\\boldsymbol{f}_4\end{bmatrix}</script><p>要想写成代码，需要对其离散化。使用前向欧拉法离散化状态方程：</p><script type="math/tex; mode=display">\begin{aligned}\dot{\boldsymbol{x}}&=\frac{\boldsymbol{x}_{k+1}-\boldsymbol{x}_k}{\Delta t}=\boldsymbol{A}\boldsymbol{x}_k+\boldsymbol{B}\boldsymbol{u}_k\\\boldsymbol{x}_{k+1}&=\underline{(\boldsymbol{I}+\Delta t\boldsymbol{A})}+\underline{\Delta t\boldsymbol{B}}u_k\\&=\overline{\boldsymbol{A}}\boldsymbol{x}_k+\overline{\boldsymbol{B}}\boldsymbol{u}_k\end{aligned}</script><p>其中的 $\overline{\boldsymbol{A}}$ 和 $\overline{\boldsymbol{B}}$ 表示为：</p><script type="math/tex; mode=display">\begin{aligned}\overline{\boldsymbol{A}}&=\begin{bmatrix}\boldsymbol{I}_3&\boldsymbol{0}_{3\times3}&\boldsymbol{R}_{z}^{T}(d\psi^k)\Delta T&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times1}\\\boldsymbol{0}_{3\times3}&\boldsymbol{I}_3&\boldsymbol{0}_{3\times3}&\boldsymbol{I}_{3}\Delta T&\boldsymbol{0}_{3\times1}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{I}_3&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times1}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{I}_3&\left[\begin{smallmatrix}0\\0\\1\end{smallmatrix}\right]\Delta T\\\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&1\end{bmatrix}\\\overline{\boldsymbol{B}}&=\begin{bmatrix}\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}\\\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}&\boldsymbol{0}_{3\times3}\\\boldsymbol{I}_k^{-1}[\boldsymbol{r}_1^k]_\times\Delta T&\boldsymbol{I}_k^{-1}[\boldsymbol{r}_2^k]_\times\Delta T&\boldsymbol{I}_k^{-1}[\boldsymbol{r}_3^k]_\times\Delta T&\boldsymbol{I}_k^{-1}[\boldsymbol{r}_4^k]_\times\Delta T\\\boldsymbol{I}_3\Delta T/m&\boldsymbol{I}_3\Delta T/m&\boldsymbol{I}_3\Delta T/m&\boldsymbol{I}_3\Delta T/m\\\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}&\boldsymbol{0}_{1\times3}\end{bmatrix}\end{aligned}</script></li></ol><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>MPC最大的优势就是可以对输入量和状态变量进行约束，所以可以对输入进行约束。输入约束可以分为以下两个约束条件：</p><ol><li><p>足底反力</p><p>摆动时足底力为0，state=0， $\boldsymbol{f}_i=\boldsymbol{0}_{3\times1}$ </p><p>触地时最大足底力为 $f_{max}$ ，state=1， $f_i^z \le  f_{max}$ </p></li><li><p>摩擦锥</p><p>为保证足底与地面不滑动，足底反力的水平分量不能大于竖直分量 $\times \mu$ ，即</p><script type="math/tex; mode=display">\begin{aligned}|f_i^x|&\le\mu f_i^z\\|f_i^y|&\le\mu f_i^z\\f_i^z&>0\end{aligned}</script></li></ol><p>结合以上两个约束，可以得到总的输入约束：</p><script type="math/tex; mode=display">\begin{bmatrix}0\\0\\0\\0\\0\end{bmatrix}\leq\begin{bmatrix}-1&0&\mu\\0&-1&\mu\\1&0&\mu\\0&1&\mu\\0&0&1\end{bmatrix}\begin{bmatrix}{f_i}^x\\{f_i}^y\\{f_i}^z\end{bmatrix}\leq\begin{bmatrix}+\infty\\+\infty\\+\infty\\+\infty\\f_{\max}\end{bmatrix}</script><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><p>首先建立代价函数（式中 $Q$ 、 $R$ 为对角正定/半正定矩阵，需要对其进行调参）</p><script type="math/tex; mode=display">\min_{x,u}\sum_{i=0}^{K-1}\underset{误差加权和}{\underline{\|x_{i+1}-x_{i+i,ref}\|Q_{i}}}+\underset{输入加权和}{\underline{\|u_{i}\|R_{i}}}</script><p>使其满足：</p><script type="math/tex; mode=display">\begin{cases}x_{i+1}=A_{i}x_{i}+B_{i}u_{i}&,i=0\cdots k-1\\\underline{c_{i}}\leq C_iu_i\leq\overline{c_{i}}&,i=0\cdots k-1(\text{支撑相})\\D_{i}u_{i}=0&,i=0\cdots k-1(\text{摆动相})&\end{cases}</script><p>对其进行二次规划，化为qpOASES标准形式：</p><script type="math/tex; mode=display">\boxed{\begin{aligned}\min_{x}\quad&\frac12x^THx+x^Tg(w_0)\\s.t.\quad&lbA(\omega_0)\leq Ax\leq ubA(\omega_0)\\&lb(\omega_0)\leq x\leq ub(\omega_0)\end{aligned}}</script><p>预测步长为 $n$ ，状态量 $X_k=\begin{bmatrix}x_k^{k+1}\\x_k^{k+2}\\\vdots\\x_k^{k+n}\end{bmatrix}$ ，输入量 $U_{k}=\begin{bmatrix}u_{k}^{k}\\u_{k}^{k+1}\\\vdots\\u_{k}^{k+n-1}\end{bmatrix}$ ，则</p><script type="math/tex; mode=display">X_{k}=\begin{bmatrix}\overline{A}\\\overline{A}^{2}\\\vdots\\\overline{A}^{N}\end{bmatrix}x_{k}+\begin{bmatrix}\overline{B}&0&\cdots&0\\\overline{A}\overline{B}&\overline{B}&\cdots&\vdots\\\vdots&\vdots&\ddots&\vdots\\\overline{A}^{N-1}\overline{B}&\overline{A}^{N-2}\overline{B}&\cdots&\overline{B}\end{bmatrix}U_{k}</script><p>上式可以记为 $X=A_{qp}x_0+B_{qp}U$ 。对于目标值 $X^{\mathrm{ref}}=\begin{bmatrix}x^{k+1}\\x^{k+2}\\\vdots\\x^{k+n}\end{bmatrix}$ ，优化问题可以转化为：</p><script type="math/tex; mode=display">\begin{aligned}\min_U\quad J(U)&=\| X-X^{\mathrm{ref}}\| L+\| U\| K\\&=(X-X^{ref})^{T}L(X-X^{ref})+U^{T}KU\\&=(A_{qp}x_0+B_{qp}U-y)^T L(A_{qp}x_0+B_{qp}U-y)+U^TKU\\&=(x_0^TA^T_{qp}+U^TB_{qp}^T-y^T)L(A_{qp}x_0+B_{qp}U-y)+U^TkU\\&=U^T(B^T_{qp}LB_{qp}+K)U+U^TB_{qp}^TL(A_{qp}x_0-y)+(A_{qp}x_0-y)^TLB_{qp}U+(A_{qp}x_0-y)^TL(A_{qp}x_0-y)\\&=U^T(B_{qp}^TLB_{qp}+K)U+U^TB_{qp}^TL(A_{qp}x_0-y)+[U^TB_{qp}^TL(A_{qp}x_0-y)]^T+(A_{qp}x_0-y)^TL(A_{qp}x_0-y)\end{aligned}</script><p>观察上式，第二第三项L左右均为向量且L为对角阵，故两者相同；第四项中的 $A_{qp}x_0-y$ 无控制量的影响，仅为状态量的变化，为常数项，可以省略。故上式可以整理为：</p><script type="math/tex; mode=display">\begin{aligned}\min_U\quad J(U)&=U^T(B_{qp}^TLB_{qp}+K)U+2U^TB_{qp}^TL(A_{qp}x_0-y)\end{aligned}</script><p>即可以整理为：</p><script type="math/tex; mode=display">\begin{aligned}\min_U \quad& \frac12U^THU+U^Tg\\s.t. \quad& \underline{c}\leq CU\leq\overline{c}\end{aligned}</script><p>其中：（维度中的 $n$ 为足数4， $k$ 为单次MPC的迭代次数）</p><script type="math/tex; mode=display">\begin{aligned}H&=2(B_{qp}^TLB_{qp}+K)\in\mathbb{R}^{3nk\times3nk}\\g&=2B_{qp}^TL(A_{qp}x_{0}-y)\in\mathbb{R}^{3nk\times1}\\\end{aligned}</script><p>至此可得机器狗跟踪质心轨迹的一组最优足端支撑力， $u_0=\begin{bmatrix}f_1\\f_2\\f_3\\f_4\end{bmatrix}$ </p><h2 id="WBC控制器"><a href="#WBC控制器" class="headerlink" title="WBC控制器"></a>WBC控制器</h2><h3 id="计算关节位置、速度、加速度"><a href="#计算关节位置、速度、加速度" class="headerlink" title="计算关节位置、速度、加速度"></a>计算关节位置、速度、加速度</h3><h4 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h4><p>通过MPC可得到最优足端力 $\boldsymbol{u}_0$ ，可通过 $\boldsymbol{\tau}=\boldsymbol{J}(\boldsymbol{\theta})^T\boldsymbol{F}$ 计算关节力矩，但只适用于低速场景。在高速场景下，足端与地面的接触时间非常短，无法进行优化，此时动态性能较差，故需要使用WBC控制器，其输入参数为接触状态、支撑力、足端轨迹、质心轨迹。且其控制频率比MPC快。</p><p>当机器人高速运动时，四条腿触地时间很短，机器人大部分时间处于欠驱动状态，与无人机欠驱动系统不同，四足机器人与地面的频繁接触变成了干扰项。此时机器人相当于与一个虚拟浮动基座相连。此虚拟浮动基座有6个自由度（冗余），此时机器人的状态变得不确定。</p><p>将需要控制的变量进行优先级划分，使用零空间理论：</p><div class="table-container"><table><thead><tr><th>级别</th><th>内容</th><th>约束</th></tr></thead><tbody><tr><td>0级</td><td>足端接触力</td><td>高级别</td></tr><tr><td>1级</td><td>机器人姿态</td><td>不能翻</td></tr><tr><td>2级</td><td>机器人位置</td><td>可适量浮动</td></tr><tr><td>3级</td><td>摆动退轨迹</td><td>低级别</td></tr></tbody></table></div><h5 id="冗余自由度机器人的优化"><a href="#冗余自由度机器人的优化" class="headerlink" title="冗余自由度机器人的优化"></a>冗余自由度机器人的优化</h5><p> $\boldsymbol{A}$ 的零空间是 $\boldsymbol{A}\boldsymbol{x}=\boldsymbol{0}$ 的所有解 $\boldsymbol{x}$ 的集合，也就是 $\boldsymbol{x}$ 固定，无论 $\boldsymbol{A}$ 取何值，结果均为0。类比串联机械臂，末端固定而其他关节转动时，所有能转动的位形构成零空间。</p><p>前文推导了末端速度与关节角速度之间的关系：$\dot{\boldsymbol{x}}=\boldsymbol{J}(\boldsymbol{\theta})\dot{\boldsymbol{\theta}}$ ，若 $\boldsymbol{J}(\boldsymbol{\theta})$ 可逆，可以得到 $\dot{\boldsymbol{\theta}}=\boldsymbol{J}^{-1}(\boldsymbol{\theta})\dot{\boldsymbol{x}}$ 。</p><p>若对于机械臂，遇到奇异位形，或关节数大于末端坐标数，此时 $\boldsymbol{J}(\boldsymbol{\theta})$ 不可逆。故引入伪逆， $\boldsymbol{J}(\boldsymbol{\theta})$ 的伪逆表示为 $\boldsymbol{J}^{\dagger}(\boldsymbol{\theta})$ ，无论 $\boldsymbol{J}(\boldsymbol{\theta})$ 是否可逆，关节角速度均可表示为 $\dot{\boldsymbol{\theta}}=\boldsymbol{J}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{x}}$ 。</p><p>伪逆的计算可以分两种情况</p><ol><li>欠约束，关节数n＜末端坐标数m， $\boldsymbol{J}^{\dagger}\boldsymbol{J}=\boldsymbol{I},\boldsymbol{J}^{\dagger}=(\boldsymbol{J}^{T}\boldsymbol{J})^{-1}$ ，此时方程可能无解，用代价函数使结果逼近设定值。</li><li>冗余约束，关节数n＞末端坐标数m， $\boldsymbol{J}\boldsymbol{J}^{\dagger}=\boldsymbol{I},\boldsymbol{J}^{\dagger}=\boldsymbol{J}^T(\boldsymbol{J}\boldsymbol{J}^{T})^{-1}$ ，此时方程有无数解，设定关节约束得到最优结果。</li></ol><p>对于冗余约束机械臂，若想在保持末端位姿不变的前提下控制其他关节的状态，则需利用零空间。</p><p> $\dot{\boldsymbol{\theta}}=\boldsymbol{J}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{x}}$ 是一个特解，其通解为 $\dot{\boldsymbol{\theta}}=\boldsymbol{J}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{x}}+(\boldsymbol{I-}\boldsymbol{J}^{\dagger}(\boldsymbol{\theta})\boldsymbol{J}(\boldsymbol{\theta}))\boldsymbol{z}$  TODO原理</p><p>将 $\dot{\boldsymbol{x}}$ 称为任务空间， $\dot{\boldsymbol{\theta}}$ 称为控制空间， $\boldsymbol{z}$ 称为零空间。 $\dot{\boldsymbol{x}}$ 中为高优先级的任务， $\boldsymbol{z}$ 中为低优先级的任务。</p><h5 id="两个任务"><a href="#两个任务" class="headerlink" title="两个任务"></a>两个任务</h5><p>对于两个任务，高优先级任务为 $\dot{\boldsymbol{w}}_1$ ，低优先级任务为 $\dot{\boldsymbol{w}}_2$ </p><script type="math/tex; mode=display">\begin{aligned}\dot{\boldsymbol{w}}_{1}=\boldsymbol{J}_1(\boldsymbol{\theta})\dot{\boldsymbol{\theta}}\\\dot{\boldsymbol{w}}_{2}=\boldsymbol{J}_{2}(\boldsymbol{\theta})\dot{\boldsymbol{\theta}}\\\end{aligned}</script><p>对于第一个高优先级任务的式子，其冗余控制方程为：</p><script type="math/tex; mode=display">\dot{\boldsymbol{\theta}}=\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{w}}_{1}+(\boldsymbol{I}-\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\boldsymbol{J}_{1}(\boldsymbol{\theta}))\boldsymbol{z}</script><p>将其带入第二个式子，得到：</p><script type="math/tex; mode=display">\dot{\boldsymbol{w}}_{2}=\boldsymbol{J}_{2}(\boldsymbol{\theta})(\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{w}}_{1}+(\boldsymbol{I}-\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\boldsymbol{J}_{1}(\boldsymbol{\theta}))\boldsymbol{z})</script><p>整理得：</p><script type="math/tex; mode=display">\boldsymbol{J}_{2}(\boldsymbol{\theta})(\boldsymbol{I}-\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\boldsymbol{J}_{1}(\boldsymbol{\theta}))\boldsymbol{z}=\dot{\boldsymbol{w}}_{2}-\boldsymbol{J}_{2}(\boldsymbol{\theta})\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{w}}_1</script><p>此时结果可能不唯一，使用最小二乘法优化代价函数。同样需要分为以下两种情况：</p><ol><li>欠约束， $\min |\boldsymbol{z}|_2$ </li><li>冗余约束， $\min |\boldsymbol{J}_{2}(\boldsymbol{\theta})(\boldsymbol{I}-\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\boldsymbol{J}_{1}(\boldsymbol{\theta}))\boldsymbol{z}-\dot{\boldsymbol{w}}_{2}+\boldsymbol{J}_{2}(\boldsymbol{\theta})\boldsymbol{J}_{1}^{\dagger}(\boldsymbol{\theta})\dot{\boldsymbol{w}}_1|_2$ </li></ol><h5 id="多个任务"><a href="#多个任务" class="headerlink" title="多个任务"></a>多个任务</h5><p>推广到一般形式，对于n个任务，符合任务优先级的关节速度为：</p><script type="math/tex; mode=display">\begin{aligned}\dot{\boldsymbol{q}}&=\sum_{i=1}^{n}\boldsymbol{N}_{i}\dot{\boldsymbol{q}}_{i}\\\dot{\boldsymbol{q}}_{i}&=(\boldsymbol{J}_{i}\overline{\boldsymbol{N}_{i}})^{\dagger}(\dot{\boldsymbol{x}}_{i}^{*}-\boldsymbol{J}_{i}\sum_{n=1}^{n-1}\boldsymbol{N}_{k}\dot{\boldsymbol{q}}_{k})\end{aligned}</script><p>式中 $\dot{\boldsymbol{x}}_{i}^{*}$ 为最优解， $\overline{\boldsymbol{N}_{i}}$ 为组合雅可比矩阵 $\overline{\boldsymbol{J}_{i}}$ 的零空间投影矩阵， $\overline{\boldsymbol{J}_i}=\begin{bmatrix}\boldsymbol{J}_1\\\boldsymbol{J}_2\\\vdots\\\boldsymbol{J}_{i-1}\end{bmatrix}$ 为所有任务优先级高于 $i$ 的任务的雅可比矩阵的组合。</p><p>写成迭代形式：</p><script type="math/tex; mode=display">\dot{\boldsymbol{q}}_{i}=\dot{\boldsymbol{q}}_{i-1}+(\boldsymbol{J}_{i}\boldsymbol{N}_{i-1})^{\dagger}(\dot{\boldsymbol{x}}_{i}^{*}-\boldsymbol{J}_{i}\dot{\boldsymbol{q}}_{i-1})</script><h4 id="关节位置"><a href="#关节位置" class="headerlink" title="关节位置"></a>关节位置</h4><p>根据上文的推导，可以得到关节位置的迭代形式：</p><script type="math/tex; mode=display">\begin{aligned}\Delta\boldsymbol{q}_{1} &=\boldsymbol{J}_1^\dagger(\boldsymbol{x}_1^{des}-\boldsymbol{x}_1)\\\Delta\boldsymbol{q}_{2} &=\Delta\boldsymbol{q}_1+\boldsymbol{J}_{2|pre}^\dagger(\boldsymbol{x}_2^\mathrm{des}-\boldsymbol{x}_2-\boldsymbol{J}_2\Delta\boldsymbol{q}_1)\\&\vdots \\\Delta\boldsymbol{q}_{i} &=\Delta\boldsymbol{q}_{i-1}+\boldsymbol{J}_{i|pre}^{\dagger}(\boldsymbol{x}_{i}^{\mathrm{des}}-\boldsymbol{x}_{i}-\boldsymbol{J}_{i}\Delta\boldsymbol{q}_{i-1})\end{aligned}</script><p>其中：</p><script type="math/tex; mode=display">\begin{aligned}&\boldsymbol{J}_{i|pre}=\boldsymbol{J}_{i}\boldsymbol{N}_{i-1}, \\&\boldsymbol{N}_{i-1}=\boldsymbol{N}_{0}\boldsymbol{N}_{1|0}\cdots\boldsymbol{N}_{i-1|i-2}, \\&\boldsymbol{N}_{0}=\boldsymbol{I}-\boldsymbol{J}_{c}^{\dagger}\boldsymbol{J}_{c}, \\&\boldsymbol{N}_{i|i-1}=\boldsymbol{I}-\boldsymbol{J}_{i|i-1}{}^{\dagger}\boldsymbol{J}_{i|i-1}.\end{aligned}</script><p>其中 $\boldsymbol{J}_i$ 为第 $i$ 项任务雅可比矩阵； $\boldsymbol{x}_{i}^{\mathrm{des}}$ 为第 $i$ 项任务的期望位置； $\Delta\boldsymbol{q}_{i}$ 为根据第 $i$ 项任务迭代计算出的关节位置增量； $\boldsymbol{J}_{i|pre}$ 为第 $i$ 项任务到先前任务的零空间投影； $\boldsymbol{J}_c$ 为接触约束雅可比矩阵；</p><h4 id="关节速度与加速度"><a href="#关节速度与加速度" class="headerlink" title="关节速度与加速度"></a>关节速度与加速度</h4><p>同理可以得到关节速度与加速度（ $\text{dyn}$ 代表动态一致伪逆： $\overline{\boldsymbol{J}^{\mathrm{dyn}}}=\boldsymbol{A}^{-1}\boldsymbol{J}^T\left(\boldsymbol{J}\boldsymbol{A}^{-1}\boldsymbol{J}^T\right)^{-1}$ ）：</p><script type="math/tex; mode=display">\begin{aligned}\dot{\boldsymbol{q}}_i^{\mathrm{cmd}}&=\dot{\boldsymbol{q}}_{i-1}^{\mathrm{cmd}}+\boldsymbol{J}_{i|pre}^{\dagger}\left(\dot{\boldsymbol{x}}_i^{\mathrm{des}}-\boldsymbol{J}_i\dot{\boldsymbol{q}}_{i-1}^{\mathrm{cmd}}\right),\\\ddot{\boldsymbol{q}}_i^{\mathrm{cmd}}&=\ddot{\boldsymbol{q}}_{i-1}^{\mathrm{cmd}}+\overline{\boldsymbol{J}_{i|pre}^{\mathrm{dyn}}}\left(\ddot{\boldsymbol{x}}_i^{\mathrm{cmd}}-\dot{\boldsymbol{J}}_i\dot{\boldsymbol{q}}-\boldsymbol{J}_i\ddot{\boldsymbol{q}}_{i-1}^{\mathrm{cmd}}\right)\end{aligned}</script><p>其中（ $\boldsymbol{K}_p$ 和 $\boldsymbol{K}_d$ 分别是位置和速度反馈增益，cmd代表控制命令）：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{q}_i^{\mathrm{cmd}}&=\boldsymbol{q}_i+\Delta\boldsymbol{q}_i\\\ddot{\boldsymbol{x}}_i^\mathrm{cmd}&=\ddot{\boldsymbol{x}}^\mathrm{des}+\boldsymbol{K}_p\left(\boldsymbol{x}_i^\mathrm{des}-\boldsymbol{x}_i\right)+\boldsymbol{K}_d\left(\dot{\boldsymbol{x}}^\mathrm{des}-\dot{\boldsymbol{x}}\right)\end{aligned}</script><p>计算出的 $\boldsymbol{q}_i^{\mathrm{cmd}}$ 和 $\dot{\boldsymbol{q}}_i^{\mathrm{cmd}}$ 发送到关节PD控制器、 $\ddot{\boldsymbol{q}}_i^{\mathrm{cmd}}$ 发送到QP规划器计算扭矩命令</p><h3 id="计算关节力矩"><a href="#计算关节力矩" class="headerlink" title="计算关节力矩"></a>计算关节力矩</h3><h4 id="浮动基动力学模型"><a href="#浮动基动力学模型" class="headerlink" title="浮动基动力学模型"></a>浮动基动力学模型</h4><p>对于固定机械臂这种基坐标系固定的机器人，只需知道每个关节的角度即可知道机器人的姿态。但对于四足机器人来说基座是不固定的，故需要在世界系与浮动基座机器人本体系之间建立一个没有实体的 6 自由度关节，其关节空间向量为 $\boldsymbol{q}={\begin{bmatrix}\boldsymbol{q}_f\\\boldsymbol{q}_j\end{bmatrix}}$ ，其中 $\boldsymbol{q}_f$ 代表身体浮动基的6个自由度， $\boldsymbol{q}_j$ 代表关节的12个自由度。浮动基动力学方程为：</p><script type="math/tex; mode=display">\boldsymbol{A}\ddot{\boldsymbol{q}}+\boldsymbol{b}+\boldsymbol{g}=\boldsymbol{S}_j^T\boldsymbol{\tau}+\boldsymbol{J}_{int}^T\boldsymbol{f}_{int}-\boldsymbol{J}_c^T\boldsymbol{f}_i</script><p>上式中 $\boldsymbol{A}$ 为质量（惯量）矩阵； $\boldsymbol{b}$ 为可科氏力与离心力项； $\boldsymbol{g}$ 为重力项； $\boldsymbol{S}_j$ 为驱动关节选择矩阵，将驱动关节的扭矩映射到整个配置空间； $\boldsymbol{f}_{int}$ 为内力； $\boldsymbol{f}_i$ 为足底力； $\boldsymbol{J}$ 为约束雅可比矩阵，其中 $int$ 代表内部约束； $c$ 代表接触约束， $\boldsymbol{J}$ 满足下式：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{0}&=\boldsymbol{J}\dot{\boldsymbol{q}}\\\boldsymbol{0}&=\boldsymbol{J}\ddot{\boldsymbol{q}}+\dot{\boldsymbol{J}}\dot{\boldsymbol{q}}\end{aligned}</script><h4 id="松弛优化"><a href="#松弛优化" class="headerlink" title="松弛优化"></a>松弛优化</h4><p>在机器人的运动过程中需要遵循动力学方程以及满足一些不等式约束来保证机器人的稳定，故使用QP优化。引入松弛变量 $\boldsymbol{\delta}_{f_{r}}$ 、 $\boldsymbol{\delta}_{f}$ ，允许机器人基座与期望状态之间存在偏差，这使得机械狗在一些不可控制的姿态条件下，仍能计算出相应的控制信号，更有利于机器人的高速运动。</p><script type="math/tex; mode=display">\begin{aligned}\mathrm{min} \quad& \boldsymbol{\delta}_{f_r}^T\boldsymbol{Q}_1\boldsymbol{\delta}_{f_r}+\boldsymbol{\delta}_f^T\boldsymbol{Q}_2\boldsymbol{\delta}_f\\\mathrm{s.t} \quad& \boldsymbol{S}_f (\boldsymbol{A}\ddot{\boldsymbol{q}}+\boldsymbol{b}+\boldsymbol{g})=\boldsymbol{S}_f \boldsymbol{J}_c^T\boldsymbol{f}_r\quad&\text{(浮动基动力学方程)}\\&\ddot{\boldsymbol{q}}=\ddot{\boldsymbol{q}}^{\mathrm{cmd}}+\begin{bmatrix}\boldsymbol{\delta}_f\\\boldsymbol{o}_{nj}\end{bmatrix}\quad&\text{(加速度)}\\&\boldsymbol{f}_r=\boldsymbol{f}_r^{\mathrm{MPC}}+\boldsymbol{\delta}_{f_r}\quad&\text{(足端接触反力)}\\&\boldsymbol{W}\boldsymbol{f}_{r}\geq \boldsymbol{0} \quad&\text{(足端摩擦约束)}\end{aligned}</script><p>其中， $\boldsymbol{f}_r^{\mathrm{MPC}}$ 为MPC计算的支撑腿的反作用力； $\boldsymbol{S}_f$ 为选择矩阵； $\boldsymbol{W}$ 为权重矩阵；</p><p>将优化出的地面反力、关节加速度及前文计算得到的关节位置、速度带到动力学方程里，可以求出支撑腿、摆动腿的关节力矩（对于摆动腿来说 $\boldsymbol{f}_r=0$ ）：</p><script type="math/tex; mode=display">\begin{bmatrix}\boldsymbol{\tau}_f\\\boldsymbol{\tau}_j\end{bmatrix}=\boldsymbol{A}\ddot{\boldsymbol{q}}+\boldsymbol{b}+\boldsymbol{g}-\boldsymbol{J}_c\boldsymbol{f}_r</script><h3 id="向电机发送控制力矩"><a href="#向电机发送控制力矩" class="headerlink" title="向电机发送控制力矩"></a>向电机发送控制力矩</h3><p>之后使用求得的关节力矩做为前馈，再加上关节位置、速度的PD控制，对机器人的支撑腿、摆动腿进行控制。</p><script type="math/tex; mode=display">\boldsymbol{\tau}_{i}=\boldsymbol{\tau}^\mathrm{cmd}+\boldsymbol{K}_{p}\left(\boldsymbol{q}_{i}^\mathrm{cmd}-\boldsymbol{q}_{i}\right)+\boldsymbol{K}_{d}\left(\dot{\boldsymbol{q}}_{i}^\mathrm{cmd}-\dot{\boldsymbol{q}}_{i}\right)</script><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><h3 id="足式机器人"><a href="#足式机器人" class="headerlink" title="足式机器人"></a>足式机器人</h3><p><a href="https://detail.tmall.com/item.htm?spm=a212k0.12153887.0.0.5487687dBgiovR&amp;id=704510718152">四足机器人控制算法—建模、控制与实践</a></p><p>基于稳定性的仿生四足机器人控制系统设计（于宪元）</p><p>Legged Robots That Balance</p><p>Quadrupedal Locomotion : An Introduction to the Control of Four-legged Robots</p><h3 id="状态估计器-1"><a href="#状态估计器-1" class="headerlink" title="状态估计器"></a>状态估计器</h3><p><a href="https://zhuanlan.zhihu.com/p/644393000">【干货|开源MIT Min cheetah机械狗设计(十)】|状态估计控制器设计</a></p><p><a href="https://www.cnblogs.com/pinking/p/9201405.html">卡尔曼滤波（kalman）相关理论以及与HMM、最小二乘法关系</a></p><h3 id="MPC部分"><a href="#MPC部分" class="headerlink" title="MPC部分"></a>MPC部分</h3><p>Dynamic Locomotion in the MIT Cheetah 3 Through Convex Model-Predictive Control</p><p><a href="https://zhuanlan.zhihu.com/p/190044338">MIT四足机器人Cheetah 3控制方案理解笔记（2）——Convex Mpc身体姿态控制</a></p><p><a href="https://zhuanlan.zhihu.com/p/640057159">【干货|开源MIT Min cheetah机械狗设计(七)】|MPC控制器之状态方程建立</a></p><p><a href="https://zhuanlan.zhihu.com/p/640296839">【干货|开源MIT Min cheetah机械狗设计(八)】|MPC控制器设计</a></p><p><a href="https://blog.csdn.net/Kalenee/article/details/126440918">Cheetah-Software方案分析</a></p><p><a href="https://zhuanlan.zhihu.com/p/268880700">四足机器人学习笔记（3）cheetah3 convexMPC论文学习笔记</a></p><h3 id="WBC部分"><a href="#WBC部分" class="headerlink" title="WBC部分"></a>WBC部分</h3><p>Highly Dynamic Quadruped Locomotion via Whole-Body Impulse Control and Model Predictive Control</p><p><a href="https://zhuanlan.zhihu.com/p/190049065">MIT四足机器人控制方案理解笔记（3）——Mini Cheetah 19年的MPC+WBC控制方案</a></p><p><a href="https://zhuanlan.zhihu.com/p/641297823">【干货|开源MIT Min cheetah机械狗设计(九)】|WBC控制器设计</a></p><p><a href="https://blog.csdn.net/qq_46304090/article/details/126603897">机器人冗余自由度优化过程中的零空间概念</a></p><p><a href="https://blog.csdn.net/weixin_42235171/article/details/126447926">ETH机器人动力学讲义：基于零空间方法的全身运动控制（WBC）-1</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Computationally-Robust and Efficient Prioritized Whole-Body Controller with Contact Constraints</p><h3 id="机器人学相关书籍"><a href="#机器人学相关书籍" class="headerlink" title="机器人学相关书籍"></a>机器人学相关书籍</h3><p>Robot Modeling and Control（机器人建模和控制）</p><p>Robotics, Vision and Control Fundamental Algorithms In MATLAB（机器人学 机器视觉与控制 MATLAB算法基础）</p><p>Introduction to Robotics Mechanics and Control（机器人学导论）</p><p>Modern Robotic Mechanics, Planning, and Control（现代机器人学：机构、规划与控制）</p><p>Control of Robot Manipulators in Joint Space</p><p>Rigid-Body Dynamics Algorithms</p><p>Springer Handbook of Robotics（机器人手册）</p><p>Theory of applied robotics: kinematics, dynamics, and control.（应用机器人学：运动学、动力学与控制技术）</p><p>Robot Dynamics Lecture Notes（机器人动力学课程笔记）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://www.robotsfan.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="机器人" scheme="https://www.robotsfan.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>ETH机器人学生奖学金</title>
    <link href="https://www.robotsfan.com/posts/ffad622d.html"/>
    <id>https://www.robotsfan.com/posts/ffad622d.html</id>
    <published>2024-02-01T11:00:00.000Z</published>
    <updated>2024-07-17T03:05:20.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ETH机器人学生奖学金"><a href="#ETH机器人学生奖学金" class="headerlink" title="ETH机器人学生奖学金"></a>ETH机器人学生奖学金</h1><p>官网：<a href="https://center-for-robotics.ethz.ch/education/robotics-student-fellowship.html">https://center-for-robotics.ethz.ch/education/robotics-student-fellowship.html</a></p><p>机器人学已经成为全球教育和研究领域中影响深远的一个重要领域，对社会和经济产生了强大的影响。苏黎世联邦理工学院（ETH）机器人学生奖学金（ETH RSF）计划为研究生提供了在他们选择的机器人学特定主题上与专家一起研究的机会。该奖学金主要在夏季（7月 - 8月）进行，对全球所有学生开放。苏黎世ETH大学的RobotX倡议致力于培养和促进多样性和平等文化。</p><h2 id="申请周期："><a href="#申请周期：" class="headerlink" title="申请周期："></a>申请周期：</h2><p>2024年1月15日至2月29日午夜（中欧时间）。</p><h2 id="计划日期："><a href="#计划日期：" class="headerlink" title="计划日期："></a>计划日期：</h2><p>该计划将于2024年7月3日至8月31日期间进行。</p><h2 id="资格："><a href="#资格：" class="headerlink" title="资格："></a>资格：</h2><p>所有满足以下条件的申请人均有资格参加该计划：</p><ul><li>您可以在7月3日至8月31日期间参加整个奖学金期。</li><li>您目前正注册在硕士课程中，预计毕业日期最早为奖学金后的春季（在一所顶尖学校表现出色的大四学生也有资格）。</li></ul><h1 id="计划结构"><a href="#计划结构" class="headerlink" title="计划结构"></a>计划结构</h1><p>苏黎世ETH RobotX倡议的机器人学生奖学金计划致力于在计划相关实验室之一进行研究。</p><ul><li><strong>时间范围：7月1日至8月31日。</strong> 请注意，奖学金的时间和持续时间是固定的，没有例外。</li><li><strong>资格。</strong> 预计在2个月奖学金后最早在春季学期毕业的全球硕士生（在一所顶尖学校表现出色的大四学生也有资格）。</li><li><strong>研究经验。</strong> 奖学金获得者将作为RobotX倡议研究小组的一部分，开展与其兴趣相关的研究项目。这包括与小组成员互动和合作。</li><li><strong>社交与交往。</strong> 将举办一系列现场社交活动，帮助奖学金获得者与他们所在研究小组以外的人建立联系，包括ETH本科和研究生水平的学生。</li><li><strong>经济奖励。</strong> 奖学金获得者将获得4000瑞士法郎的津贴，用于支付住房和生活费用。</li><li><strong>旅行费用。</strong> 将支付旅行和签证费用。学生可以在计划开始时根据票据申请旅行费用，海外航班最高为1200瑞士法郎，短途航班最高为500瑞士法郎。只有经济舱（带一个托运行李）和二等火车票才有资格获得报销。最终金额将根据具体情况确定。</li><li><strong>住宿。</strong> 该计划提供所有奖学金获得者的住宿，并事先从奖学金中支付。</li></ul><h1 id="如何申请"><a href="#如何申请" class="headerlink" title="如何申请"></a>如何申请</h1><p><strong>在在线提交申请之前，请仔细阅读以下信息并准备所有所需文件。</strong></p><h2 id="资格"><a href="#资格" class="headerlink" title="资格"></a>资格</h2><p>如果您满足以下条件，则符合机器人学生奖学金的资格：</p><ul><li>您已注册在机器人学或相关领域（例如电气工程，机械工程）的硕士学习计划中。在一所顶尖学校表现出色的大四学生也有资格。</li><li>您的预计毕业日期为2025年1月或之后。</li><li>您可以参加从7月3日到8月31日期间的整个奖学金期。</li></ul><p><strong>录取流程：</strong><br>将根据提供的文件评估您的申请。申请过程的最后一步可能包括与入选候选人进行的面试。</p><h2 id="语言要求"><a href="#语言要求" class="headerlink" title="语言要求"></a>语言要求</h2><p>该计划完全以英语进行。不需要正式证明。但是，奖学金需要对英语具有良好的工作知识。您的语言能力可能会在面试过程中进行评估。</p><h2 id="准备申请"><a href="#准备申请" class="headerlink" title="准备申请"></a>准备申请</h2><p>请首先探索参与主办实验室的教职成员及其研究主题。</p><p>在您的申请中，将要求您指定三个实验室以进行研究（按优先顺序）。这将帮助计划协调最佳的实验室安置。</p><p><strong>备注：请不要直接联系教职成员。</strong></p><p>在申请之前，请准备所有所需文件（以英语为PDF文件，每个文件最大10MB）：</p><ul><li>您的简历。请使用 <a href="https://europass.cedefop.europa.eu/documents/curriculum-vitae">外部链接Europass格式</a>。</li><li>您所在大学的官方学术成绩单</li><li>动机信/个人陈述（最多1页）。用您自己的语言描述为何选择了您提出的科学研究领域。解释您希望通过来到ETH实现什么目标，以及它将如何支持您的学术生涯并为从事研究工作做好准备。良好的个人</li></ul><p>陈述可以在半页纸上写出，您应该努力不超过一整页A4。请注意整理得使其易于阅读。</p><ul><li><p>两位学术推荐人。</p><p>在在线申请中，您应提供这两位学术推荐人的联系方式。您应能够为每位学术推荐人提供以下信息：i）姓名，ii）职称，iii）职务，iv）网站/谷歌学者，v）大学/公司，vi）电子邮件。以下是被接受的“学术推荐人”的例子：</p><ul><li>硕士/学士论文导师</li><li>硕士/学士导师</li><li>硕士/学士项目协调员</li><li>您已参加过的项目课程的负责教授</li></ul></li><li><p>推荐信，由您的学术推荐人之一提交（每位推荐人一个）至 <a href="mailto:robotics-student-fellowship@ethz.ch">robotics-student-fellowship@ethz.ch</a>，主题为 <strong>{学生名}-{学生姓}-reference-letter-{推荐人姓}</strong>。推荐人应使用 <a href="https://ethz.ch/content/dam/ethz/special-interest/dual/robotics-dam/documents/Forms/ETH-RSF_RecommendationLetter-Form.pdf">下载相关表格（PDF，438 KB）</a>。他们可以使用电子签名签署推荐，或者打印，签署，并扫描表格。这两封信必须在申请周期结束之前提交。</p></li></ul><p><strong>只有具有所有必需文件的完整申请才能被考虑录取。</strong></p><h2 id="在线申请"><a href="#在线申请" class="headerlink" title="在线申请"></a>在线申请</h2><p>在申请之前，请确保您已阅读 <a href>准备申请</a>，并将所有所需文件准备为PDF文件。</p><ol><li><p>首先，您需要 <a href="https://sirop.org/app/register">外部链接在SiROP注册</a></p><p>在注册时，搜索您的本校大学并选择列表中的学校，或使用电子邮件地址创建帐户。注册后，SiROP将邀请您与您自己的机构合作。<strong>如果您想申请，创建这种关联并不是必需的步骤。</strong></p></li><li><p>完成SiROP注册后，请按照此链接操作：</p><p><a href="https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl">https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl</a> </p><p>申请链接：</p><p><a href="https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl">https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl</a></p><p>申请截止日期为2024年2月29日午夜（中欧时间）。</p></li><li><p>单击链接SiROP机会顶部的“立即申请”按钮。</p><p><strong>只有具有所有必需文件的完整申请才能被考虑录取。</strong></p></li></ol><h1 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h1><p>如果您有任何问题，未在如何申请部分或我们的常见问题解答中找到答案，请发送电子邮件至计划管理人员 <a href="mailto:robotics-student-fellowship@ethz.ch">robotics-student-fellowship@ethz.ch</a>。</p><ul><li><p>项目在开始/结束日期方面有多大的灵活性？</p><p>很遗憾，没有灵活性。</p></li><li><p>在计划期间是否可以短时间离开？</p><p>不，这是不可能的。请注意，对您的最大承诺是期望的。如果您无法履行，请给其他学生提供机会。</p></li><li><p>是否需要成为特定国家的公民才能申请？</p><p>不，该计划对所有国籍的学生开放。</p></li><li><p>如果适用，是否需要获得适当的签证参与该计划？</p><p>是的，获得必要签证是您的责任。ETH学生交流办公室将协助奖学金获得者进行此过程。</p></li><li><p>什么是官方学术成绩单？</p><p>官方学术成绩单是总结学生迄今为止的学术进展和表现的文件，应包括大学和学位课程标题，以及每门课程模块的成绩。</p><p>您可能需要向您的大学提出请求，他们可能需要一段时间来生成。</p></li><li><p>我需要自己安排住房吗？</p><p>不，住宿将会被组织好。我们为所有奖学金获得者提供在同一学生宿舍的住宿。住房费用将从奖学金中扣除。</p></li><li><p>奖学金津贴是否包括苏黎世的生活费？</p><p>是的，奖学金足够在苏黎世作为学生舒适地生活。</p></li><li><p>我担心在苏黎世生活，因为我不会说德语。苏黎世的生活是什么样子？</p><p>不会说德语也没关系。苏黎世非常国际化（超过30%为外国人），大多数人讲英语并能理解英语。此外，英语是ETH的通用语言。</p></li><li><p>苏黎世的通勤时间有多长？</p><p>住宿地点相当靠近，通勤时间约为半小时。公共交通可靠，清洁，安全且易于使用。</p></li></ul><h1 id="ETH-Robotics-Student-Fellowship"><a href="#ETH-Robotics-Student-Fellowship" class="headerlink" title="ETH Robotics Student Fellowship"></a>ETH Robotics Student Fellowship</h1><p>Robotics has become one of the biggest fields of education and research worldwide with strong societal and economic impact. The ETH Robotics Student Fellowship (ETH RSF) program offers graduate students the opportunity to research alongside experts on the specific topic of robotics of their choice. This fellowship takes place mainly during summer (July - August) and is open to all students worldwide. The RobotX initiative at ETH Zurich is committed to fostering and cultivating a culture of diversity and equality. </p><h2 id="Application-period"><a href="#Application-period" class="headerlink" title="Application period:"></a>Application period:</h2><p>15 January to 29 February 2024 at midnight (Central European Time).</p><h2 id="Program-dates"><a href="#Program-dates" class="headerlink" title="Program dates:"></a>Program dates:</h2><p>The program will take place from 03 July to 31 August 2024</p><h2 id="Eligibility"><a href="#Eligibility" class="headerlink" title="Eligibility:"></a>Eligibility:</h2><p>All applicants fulfilling the following conditions are eligible for the program:</p><ul><li>You can attend the entire fellowship period from July 3rd to August 31st. (Note that this time is fixed and cannot be changed)</li><li>You are currently enrolled in a master program and your expected graduation date is earliest in spring the year after the fellowship (Last-year undergrad students with outstanding performance at a top school are also eligible).</li></ul><h1 id="Program-structure"><a href="#Program-structure" class="headerlink" title="Program structure"></a>Program structure</h1><p>The Robotics Student Fellowship program at ETH RobotX initiative is devoted to carrying out research in one of the labs associated to the program.</p><ul><li><strong>Time frame: 01 July – 31 August.</strong> Please note that the time and duration of the fellowship is fixed and there are not exceptions.</li><li><strong>Eligibility.</strong> Master’s students worldwide with an expected graduation date earliest during the spring semester the year after the 2-month fellowship (Last-year undergrad students with outstanding performance at a top school are also eligible).</li><li><strong>Research experience.</strong> Fellows will pursue a research project that aligns with a chosen lab of their interest as part of a research group within the RobotX initiative. This includes interacting and collaborating with group members.</li><li><strong>Networking and socializing.</strong> A number of on-site socializing events will help fellows to get to know people outside their respective research groups, including current ETH students at both undergraduate and graduate levels.</li><li><strong>Financial award.</strong> Fellows will receive a stipend of CHF 4,000 to cover housing and living expenses. </li><li><strong>Travel costs.</strong> Travel and visa expenses will be covered. Students can claim the travel costs against receipts at the beginning of the program up to CHF 1,200 for overseas flights and CHF 500 for shorter distances. Only Economic class (with one checked baggage) and 2nd class train tickets are eligible for reimbursement. The final amount is determined on a per case basis.</li><li><strong>Accommodation.</strong> The program provides accommodation for all fellows and paid for out of the stipends beforehand.</li></ul><h1 id="How-to-apply"><a href="#How-to-apply" class="headerlink" title="How to apply"></a>How to apply</h1><p><strong>Please read the information below carefully and prepare all required documents before submitting your application online.</strong></p><h2 id="Eligibility-1"><a href="#Eligibility-1" class="headerlink" title="Eligibility"></a>Eligibility</h2><p>You are eligible for the Robotics Student Fellowship if you satisfy the following conditions:</p><ul><li>You are enrolled in a Master’s study program in Robotics or a closely related field (e.g., electrical engineering, mechanical engineering). Last-year undergrad students with outstanding performance at a top school are also eligible.</li><li>Your expected graduation date is January 2025 or later.</li><li>You can attend the entire fellowship period from July 3rd to August 31st.</li></ul><p><strong>Admission process:</strong><br> Your application will be evaluated on the basis of the documents provided. The last step of the application process may include an interview conducted with the shortlisted candidates.</p><h2 id="Language-requirements"><a href="#Language-requirements" class="headerlink" title="Language requirements"></a>Language requirements</h2><p>The program is fully conducted in English. Formal evidence is not required. However, the fellowship requires a good working knowledge of English. Your language ability may be assessed during an interview.</p><h2 id="Preparing-your-application"><a href="#Preparing-your-application" class="headerlink" title="Preparing your application"></a>Preparing your application</h2><p>Please begin by exploring the faculty members in the participating hosting labs and their research topics.</p><p>You will be asked in your application to indicate three labs to conduct your research (with a preferential order). This will help the program to coordinate optimal lab placements.</p><p><strong>Remark: Please do not contact faculty members directly.</strong></p><p>Before applying please prepare all required documents (in English) as PDF files (max 10mb per file):</p><ul><li><p>Your CV. Please use the <a href="https://europass.cedefop.europa.eu/documents/curriculum-vitae">external pageEuropass format</a>.</p></li><li><p>Official academic transcript from your home university</p></li><li><p>Letter of motivation/Personal statement (max 1 page). Describe in your own words why you have chosen your proposed scientific area of research. Explain what you hope to accomplish by coming to ETH and how it will support your academic career and prepare you for a career in research. A good personal statement can be written in half a page and you should aim not to write more than a full A4 page. Lay it out carefully to make it easy to read.</p></li><li><p>Two academic referees. </p><p>During the online application you should provide the contact details of these two academic referees. You should be able to provide the following information for each academic referee: i) Name, ii) Title, iii) Position, iv) Website/Google Scholar, v) University/Company, and  vi) e-mail. The following are examples of accepted “academic referees”:</p><ul><li>Master/Bachelor thesis supervisor</li><li>Master/Bachelor tutor</li><li>Master/Bachelor program coordinator</li><li>Professor in charge of a project-based course you have taken</li></ul></li><li><p>Letter of recommendation to be submitted by your academic referees (one per referee) to <a href="mailto:robotics-student-fellowship@ethz.ch">robotics-student-fellowship@ethz.ch</a> with the subject <strong>{student firstname}-{student lastname}-reference-letter-{referee lastname}</strong>. Referees should use the <a href="https://ethz.ch/content/dam/ethz/special-interest/dual/robotics-dam/documents/Forms/ETH-RSF_RecommendationLetter-Form.pdf">Downloadrespective form (PDF, 438 KB)</a>. They can sign the recommendation using an electronic signature, or they can print, sign, and scan the form. These two letters have to be submitted before the end of the application period.  </p></li></ul><p><strong>Only complete applications with all the required documents can be considered for admission.</strong></p><h2 id="Apply-online"><a href="#Apply-online" class="headerlink" title="Apply online"></a>Apply online</h2><p>Before applying make sure you have read <a href>Preparing your application</a> and prepared all required documents as PDF files.</p><ol><li><p>First you need to <a href="https://sirop.org/app/register">external pageregister with SiROP</a></p><p> To register search for your home university in the list provided or create an account using an email address. After your registration SiROP offers you to affiliate with your own institution. <strong>To create such an affiliation is NOT a required step if you want to apply.</strong></p></li><li><p>After completing your SiROP registration follow this link: </p><p> <a href="https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl">https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl</a> </p><p> Link to application:</p><p> <a href="https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl">https://sirop.org/app/b9f5d562-79b2-484c-b65d-2442bdb78181?_k=VbFjQh9Bqj07ApIl</a></p><p> Application ends at 29 February 2024 at midnight (Central European Time).</p></li><li><p>Click the «Apply now» button at the top of the linked SiROP opportunity</p><p> <strong>Only complete applications with all the required documents can be considered for admission.</strong></p></li></ol><h1 id="Frequently-asked-questions"><a href="#Frequently-asked-questions" class="headerlink" title="Frequently asked questions"></a>Frequently asked questions</h1><p>Should you have a question, not answered by the how to apply section or by our FAQs, please send an e-mail to the program administration at <a href="mailto:robotics-student-fellowship@ethz.ch">robotics-student-fellowship@ethz.ch</a>.</p><ul><li><p>How flexible is the program when it comes to the start/end date?</p><p>  Unfortunately, there is no flexibility.</p></li><li><p>Is it possible to be absent for a short period of time during the program?</p><p>  No, this is not possible. Note that the utmost commitment is expected from your side. Please give the room to another student if you are not able to do so.</p></li><li><p>Do I need to be a citizen of a specific country to be eligible for application?</p><p>  No, this program is open to students of all nationalities.</p></li><li><p>If applicable, am I required to obtain the appropriate visa to participate in the program?</p><p>  Yes, it is your responsibility to acquire the necessary visa. The ETH Student Exchange office will help fellows with the process. </p></li><li><p>What is an official academic transcript?</p><p>  An official academic transcript is a document that summarises a student’s academic progress and performance to date, and should include the University and degree programme title, and grades for each course module taken.</p><p>You will probably need to ask your university to provide you with one and it may take a while to produce.</p></li><li><p>Do I need to organize housing by myself?</p><p>  No, accommodation will be organized. We provide accomodation for all fellows in the same student house. Housing expenses will be deducted from the scholarship.</p></li><li><p>Does the fellowship allowance cover living expenses in Zurich?</p><p>  Yes, the allowance is enough to live comfortably as student in Zurich.</p></li><li><p>I worry about living in Zurich since I do not speak any German. What is life in Zurich like?</p><p>  Not speaking German is fine. Zurich is very international (more than 30% are foreigners) and the majority of people speak and understand English. Furthermore, English is the common language at ETH.</p></li><li><p>How long are the commute times in Zurich?</p><p>  The accommodations are quite close with a commute time of about half an hour. Public transportation is reliable, clean, safe, and easy to use.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其他" scheme="https://www.robotsfan.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="机器人" scheme="https://www.robotsfan.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>DreamWaQ论文分析</title>
    <link href="https://www.robotsfan.com/posts/4b2e8826.html"/>
    <id>https://www.robotsfan.com/posts/4b2e8826.html</id>
    <published>2024-01-07T05:00:00.000Z</published>
    <updated>2024-01-07T05:19:16.850Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DreamWaQ论文分析"><a href="#DreamWaQ论文分析" class="headerlink" title="DreamWaQ论文分析"></a>DreamWaQ论文分析</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>环境建模为POMDP，定义为</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{M}&=(\mathcal{S},\mathcal{O},\mathcal{A},d_0,p,r,\gamma)\end{aligned}</script><p>其中完整状态、部分观测、动作都是连续的</p><script type="math/tex; mode=display">\mathbf{s}\in\mathcal{S},\mathbf{o}\in\mathcal{O},\mathbf{a}\in\mathcal{A}</script><p>环境从初始状态分布 $\begin{aligned}d_0(\mathbf{s}_0)\end{aligned}$ 开始，以下述状态转移概率进行</p><script type="math/tex; mode=display">p(\mathbf{s}_{t+1}|\mathbf{s}_t,\mathbf{a}_t)</script><p>每次transition获得下述奖励函数定义的奖励</p><script type="math/tex; mode=display">r:\mathcal{S}\times\mathcal{A}\to\mathcal{R}</script><p>折扣因子定义为</p><script type="math/tex; mode=display">\gamma\in[0,1)</script><p>将t时刻的过去H次测量值的时间观测值定义为</p><script type="math/tex; mode=display">\mathbf{o}_t^H=\begin{bmatrix}\mathbf{o}_t&\mathbf{o}_{t-1}\ldots\mathbf{o}_{t-H}\end{bmatrix}^T</script><p>同时定义一个上下文向量 $\mathbf{z}_{t}$ ，其中包含了描述环境状态的隐含表示（高程信息）</p><h2 id="隐式的地形想象"><a href="#隐式的地形想象" class="headerlink" title="隐式的地形想象"></a>隐式的地形想象</h2><p>其他工作利用了teacher-student训练方法，这种”行为克隆“将学生政策的表现与教师政策限制在一起，且顺序训练教师和学生网络的数据效率低下。学生策略可能无法探索教师策略在早期RL阶段学到的失败状态，因为在行为克隆期间学生策略仅受到教师策略的良好行动监督。<br>为了学习隐式的地形想象，采用不对称的actor-critic架构。actor-critic中的策略和价值网络之间的相互作用可以训练一种策略，这种策略可以在给定部分时间观测的情况下隐式地“想象”特权观察。<br>策略（actor）接收部分时间观测 $\mathbf{o}_t^H$ 作为输入，价值网络（critic）接收完整状态 $\mathbf{s}_t$ ，如下图所示，定义H=5<br><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/20240106220514.png" alt><br>由于只需要⼀个训练阶段，训练期间的数据效率显著提⾼。此外，该策略可以在训练期间探索所有可能的轨迹，通过泛化提⾼其稳健性。使用PPO算法优化策略。</p><h3 id="策略网络"><a href="#策略网络" class="headerlink" title="策略网络"></a>策略网络</h3><p>策略 $\pi_\phi(\mathbf{a}_t|\mathbf{o}_t,\mathbf{v}_t,\mathbf{z}_t)$ 是在本体感知观测 $\mathbf{o}_t$ 、机身线速度 $\mathbf{v}_t$ 、隐含状态 $\mathbf{z}_t$ 的情况下，采取动作 $\mathbf{a}_t$ 时由 $\phi$ 参数化的神经网络。<br> $\mathbf{o}_t$ 是一个 $n \times 1$ 的向量，直接从关节编码器和IMU中测量得到，表示为</p><script type="math/tex; mode=display">\mathbf{o}_t=\begin{bmatrix}\omega_t&\mathbf{g}_t&\mathbf{c}_t&\theta_t&\dot{\theta}_t&\mathbf{a}_{t-1}\end{bmatrix}^T</script><p>其中：</p><ul><li>$\omega_t$ ：机身角速度</li><li>$\mathbf{g}_t$ ：机身坐标系下的重力向量</li><li>$\mathbf{c}_t$ ：机身速度指令</li><li>$\theta_t$ ：关节角度</li><li>$\dot{\theta}_t$ ：关节角速度</li><li>$\mathbf{a}_{t-1}$ ：之前的动作<br>$\mathbf{v}_t$ 和 $\mathbf{z}_t$ 由上下文辅助估计网络context-aided estimator network（CENet）估计，下文会讲到。<h3 id="价值网络"><a href="#价值网络" class="headerlink" title="价值网络"></a>价值网络</h3>价值网络经过训练输出状态值 $V(\mathbf{s}_{t})$ 的估计。与策略网络不同的是，价值网络接收特权观测 $\mathbf{s}_t$ ，定义为：<script type="math/tex; mode=display">\mathbf{s}_t=\begin{bmatrix}\mathbf{o}_t&\mathbf{v}_t&\mathbf{d}_t&\mathbf{h}_t\end{bmatrix}^T</script>其中：</li><li>$\mathbf{o}_t$ ：前文提到的本体感知观测</li><li>$\mathbf{v}_t$ ：前文提到的机身线速度</li><li>$\mathbf{d}_t$ ：随机施加在机身上的⼲扰⼒</li><li>$\mathbf{h}_t$ ：机器⼈周围环境的高程图，作为价值⽹络感受外界的输入<br>策略网络经过训练可以从本体感知隐式地推断 $\mathbf{d}_t$ 和 $\mathbf{h}_t$ <h3 id="动作空间"><a href="#动作空间" class="headerlink" title="动作空间"></a>动作空间</h3>动作空间 $\mathbf{a}_t$ 是一个 $12 \times 1$ 的向量，对应机器人12个关节的角度。为了使学习更加容易，策略的输出为机器人当前姿态与静止姿态对应关节角度的差值，即为<script type="math/tex; mode=display">\mathbf{\theta}_{\mathrm{des}}=\mathbf{\theta}_{\mathrm{stand}}+\mathbf{a}_t</script>然后使用PD控制器跟踪期望的关节角度。<h3 id="奖励函数"><a href="#奖励函数" class="headerlink" title="奖励函数"></a>奖励函数</h3>奖励函数与其他工作相同，不做过多的修改，以突出DreamWaQ的效果，定义如下：<br><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/20240106224109.png" alt><br>其中：</li><li>exp为指数运算，var为方差运算；</li><li>des为期望值，cmd为命令值；</li><li>xyz定义在机器人坐标系中，x为前方，z为上方；</li><li>$\mathbf{g}$ ：重力向量在机身坐标系上的投影</li><li>$\mathbf{v}_{xy}$ ：xy平面上的线速度</li><li>$\omega_{\mathrm{yaw}}$ ：yaw轴角加速度</li><li>$h$ ：机身相对地面的高度</li><li>$p_{f,z,k}$ ：足端高度</li><li>$v_{f,xy,k}$ ：足端横向速度</li><li>$\mathrm{\tau}$ ：关节扭矩<br>奖励函数包括跟踪命令速度的任务奖励和稳定性奖励。在每个状态采取动作的策略的总奖励定义为<script type="math/tex; mode=display">r_t(\mathbf{s}_t,\mathbf{a}_t)=\sum r_iw_i</script>对最后一项Power奖励函数的解释：用于学习运动策略的复杂奖励函数通常包括电机功率最小化项。然而这种奖励在不考虑每个电机的功率平衡的情况下最大限度地减少了总功率。 因此从长远来看某些电机可能会比其他电机更快过热。因此引入功率分配奖励，通过惩罚机器人上使用的所有电机的高方差电机功率来减少现实世界中的电机过热。<h3 id="课程学习"><a href="#课程学习" class="headerlink" title="课程学习"></a>课程学习</h3>在困难地形上进行渐进的运动策略学习。地形由光滑、粗糙、离散和阶梯地形组成，倾斜度在0°-22°范围内有十级的变化。利用网格自适应课程进行低速运动可以实现更好、更稳定的转弯，从而防止足端绊倒。<h2 id="下文辅助估计网络（CENet）"><a href="#下文辅助估计网络（CENet）" class="headerlink" title="下文辅助估计网络（CENet）"></a>下文辅助估计网络（CENet）</h2>上面的训练方法需要机身线速度 $\mathbf{v}_t$ 、隐含状态 $\mathbf{z}_t$ 作为输入，可以通过本体感知进行估计。（？）其他工作将 $\mathbf{z}_t$ 视为地形隐含变量。此外通过学习网络估计 $\mathbf{v}_t$ 通过消除累计的估计漂移，显著提高运动策略的鲁棒性。<br>通过这些先前的工作可以发现，地形和身体状态估计之间的相互作用显着提高了身体状态估计的准确性。因此提出了上下文辅助估计网络（CENet）架构来共同学习估计和推断的隐含环境信息，而不是仅仅显式估计机器人的状态。 CENet的优点是：</li></ul><ol><li>由于共享编码器架构，网络架构显著简化并在推理过程中同步运行；</li><li>编码器网络可以通过自动编码机制来联合学习机器人的前向和后向动力学，从而提高其精度。<br>CENet由单编码器和多部分解码器组成，如下图所示。CENet的架构由机身速度估计模型和共享统一编码器的自动编码器模型组成。共享编码器经过训练可以联合提供鲁棒的身体状态和上下文估计。<br><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/20240107122725.png" alt><br>编码器网络将 $\mathbf{o}_t^H$ 编码为 $\mathbf{v}_t$ 和 $\mathbf{z}_t$ 。 第一部分估计 $\mathbf{v}_t$ ，第二部分重建  $\mathbf{o}_{t+1}$ 。 我们利用β-变分自动编码器（β-VAE）作为自动编码器架构。 CENet 使用混合损失函数进行优化，定义如下：<script type="math/tex; mode=display">\mathcal{L}_{\mathrm{CE}}=\mathcal{L}_{\mathrm{est}}+\mathcal{L}_{\mathrm{VAE}}</script>其中 $\mathcal{L}_{\mathrm{est}}$ 是身体速度估计， $\mathcal{L}_{\mathrm{VAE}}$ 是VAE损失。对于显式状态估计，估计的物体速度 $\tilde{\mathbf{v}}_t$ 和来自模拟器实际的 $\mathbf{v}_{t}$ 之间采用了均方误差 (MSE) 损失，如下所示：<script type="math/tex; mode=display">\mathcal{L}_{\mathrm{est}}=MSE(\tilde{\mathbf{v}}_t,\mathbf{v}_t)</script>VAE网络使用标准 β-VAE 损失进行训练，其中包括重建损失和隐含损失。使用 MSE 作为重建损失，使用 Kullback-Leibler (KL) 散度作为潜在损失。VAE 损失的公式为：<script type="math/tex; mode=display">\begin{aligned}\mathcal{L}_{\text{VAE}} = M S E ( \tilde { \mathbf{o}}_{t+1},\mathbf{o}_{t+1})+\beta D_{\text{KL}}(q(\mathbf{z}_t|\mathbf{o}_t^H)\parallel p(\mathbf{z}_t))\end{aligned}</script>其中：</li></ol><ul><li>$\tilde { \mathbf{o}}_{t+1}$ 为重建的下一个观测值</li><li>$q(\mathbf{z}_t|\mathbf{o}_t^H)$ 为给定 $\mathbf{o}_t^H$ 时 $\mathbf{z}_t$ 的后验分布</li><li>$p(\mathbf{z}_t)$ 为由高斯分布参数化的上下文先验分布<br>选择标准正态分布作为先验分布，因为所有观测值均已标准化为零均值和单位方差。<br>此外，在策略网络训练期间从估计器网络引导（bootstrap）可以提高学习策略的sim-to-real鲁棒性。然而由于学习早期阶段的学习噪声较大，引导也可能会损害策略的性能。 因此提出一种自适应引导（AdaBoot）方法，可以在训练期间自适应地调整引导概率。 AdaBoot 由变异系数（CV）控制，即m个经过随机化的环境中的情景奖励的标准差与平均值的比率。 关键思想是，当m个agent的奖励的CV较小时，需要进行引导，以使策略对不准确的估计更加稳健。 但是当agent学习得不够好时不应该引导，用奖励中的较大CV值表示。 将每次学习迭代的引导概率定义如下：<script type="math/tex; mode=display">p_{\mathrm{boot}}=1-\tanh(CV(\mathbf{R}))</script>其中：</li><li>$p_{\mathrm{boot}}\in[0,1]$ 是引导概率</li><li>$\mathbf{R}$ 是来自m个进过随机化的环境的情景奖励的 $m\times1$ 向量</li><li>CV为变异系数运算</li><li>tanh为双曲正切运算，用于将 $CV(\mathbf{R})$ 的上限平滑地变为1<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2>使用isaac gym同步训练policy、value、CENet网络。训练参数如下：</li><li>agents：4096</li><li>iterations：1000</li><li>策略网络：PPO，其clip范围设置为0.2，⼴义优势估计因⼦设置为0.95，折扣因⼦设置为0.99</li><li>隐含层的激活函数：指数线性单元（ELU）</li><li>使⽤ Adam 优化器优化⽹络，学习率为 $10^{-3}$ </li><li>环境参数随机化见下表<br><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/20240107125948.png" alt><h2 id="迁移到实物"><a href="#迁移到实物" class="headerlink" title="迁移到实物"></a>迁移到实物</h2>迁移到Unitree A1四足机器人上，策略与CENet以50Hz的频率同步运⾏。使⽤200Hz的PD控制器跟踪所需的关节⻆度，Kp=28、Kd=0.7。<br>在楼梯环境中，CENet可以准确估计⾝体速度，使机器⼈能安全爬楼梯。假设这由两个因素实现：</li><li>前向-后向动态学习在所有地形中提供更准确的估计</li><li>使⽤ DreamWaQ，联合训练编码器来预测地形属性<br>因此，可以隐式推断地形属性，有助于调节显式估计。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="RL" scheme="https://www.robotsfan.com/categories/RL/"/>
    
    
    <category term="RL" scheme="https://www.robotsfan.com/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>C++获取当前工作空间下某文件的路径</title>
    <link href="https://www.robotsfan.com/posts/efbbd14c.html"/>
    <id>https://www.robotsfan.com/posts/efbbd14c.html</id>
    <published>2023-09-11T12:30:00.000Z</published>
    <updated>2023-11-30T14:13:42.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-获取当前工作空间下某文件的路径"><a href="#C-获取当前工作空间下某文件的路径" class="headerlink" title="C++获取当前工作空间下某文件的路径"></a>C++获取当前工作空间下某文件的路径</h1><h2 id="使用Cmake编译"><a href="#使用Cmake编译" class="headerlink" title="使用Cmake编译"></a>使用Cmake编译</h2><p>在CmakeLists.txt中定义预处理宏</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(-DCMAKE_CURRENT_SOURCE_DIR=<span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>在源文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YOUR_FILE_PATH CMAKE_CURRENT_SOURCE_DIR <span class="meta-string">&quot;/xxx/YOUR_FILE_NAME.xxx&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="使用ROS环境"><a href="#使用ROS环境" class="headerlink" title="使用ROS环境"></a>使用ROS环境</h2><p>直接在源文件中写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string package_path = ros::package::<span class="built_in">getPath</span>(<span class="string">&quot;YOUR_PACKAGE_NAME&quot;</span>);</span><br><span class="line">std::string file_path = package_path + <span class="string">&quot;/xxx/YOUR_FILE_NAME.xxx&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>显卡bug解决思路 Failed to initialize NVML Driver/library version mismatch</title>
    <link href="https://www.robotsfan.com/posts/2038292b.html"/>
    <id>https://www.robotsfan.com/posts/2038292b.html</id>
    <published>2023-07-08T02:44:00.000Z</published>
    <updated>2024-07-17T03:04:00.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="显卡bug解决思路：Failed-to-initialize-NVML-Driver-library-version-mismatch"><a href="#显卡bug解决思路：Failed-to-initialize-NVML-Driver-library-version-mismatch" class="headerlink" title="显卡bug解决思路：Failed to initialize NVML: Driver/library version mismatch"></a>显卡bug解决思路：Failed to initialize NVML: Driver/library version mismatch</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在终端输入<a href="https://so.csdn.net/so/search?q=nvidia-smi&amp;spm=1001.2101.3001.7020">nvidia-smi</a>出现以下错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to initialize NVML: Driver/library version mismatch</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>NVIDIA内核驱动版本与系统内核版本不一致</p><p>查看更新日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/dpkg.log | grep nvidia</span><br></pre></td></tr></table></figure><p>若有更新会显示：<code>upgrade nvidia-driver-515:amd64 515,86,01-0ubuntug,20.04,1 525,125.06-0ubuntuo.20.04.3</code>，可以看出内核驱动版本从515自动升级成了525</p><p>查看显卡驱动内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/driver/nvidia/version</span><br></pre></td></tr></table></figure><p>会显示：<code>NVRM version: NVIDIA UNIX X86 64 Kernel ModuleGcc version:515.86.01Wed 0ct 26 99:12:38 UTC 2022</code>，可以发现显卡驱动内核版本还是525。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>第一种：重启服务器</p><p>第二种：<a href="https://huaweicloud.csdn.net/63560f1dd3efff3090b5939c.html?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~activity-4-122349627-blog-118105194.pc_relevant_aa2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~activity-4-122349627-blog-118105194.pc_relevant_aa2&amp;utm_relevant_index=4">不用重启的方案</a></p><p>第三种：<a href="https://cloud.tencent.com/developer/article/2066902">重新安装显卡驱动</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其他" scheme="https://www.robotsfan.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="NVIDIA" scheme="https://www.robotsfan.com/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>在c++中使用yaml-cpp动态调参</title>
    <link href="https://www.robotsfan.com/posts/534bf7d1.html"/>
    <id>https://www.robotsfan.com/posts/534bf7d1.html</id>
    <published>2023-06-20T06:46:00.000Z</published>
    <updated>2024-07-17T03:02:57.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="在c-中使用yaml-cpp动态调参"><a href="#在c-中使用yaml-cpp动态调参" class="headerlink" title="在c++中使用yaml-cpp动态调参"></a>在c++中使用yaml-cpp动态调参</h1><p>使用yaml-cpp可以进行动态调参，无需重新编译，节省调试时间。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装yaml-cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jbeder/yaml-cpp.git</span><br><span class="line"><span class="built_in">cd</span> yaml-cpp &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DYAML_BUILD_SHARED_LIBS=on ..</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>头文件在/usr/local/include，库文件在/usr/local/lib</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>CmakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(yaml-cpp REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;YAML_CPP_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_file_name yaml-cpp)</span><br></pre></td></tr></table></figure></li><li><p>yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kp:</span></span><br><span class="line">  <span class="attr">a:</span> <span class="number">500</span></span><br><span class="line">  <span class="attr">b:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">c:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">kd:</span></span><br><span class="line">  <span class="attr">a:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">b:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">c:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>源文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;yaml-cpp/yaml.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YAML_PATH <span class="meta-string">&quot;xxx.yaml&quot;</span></span></span><br><span class="line"></span><br><span class="line">Mat3 _Kp, _Kd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_yaml</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">YAML::Node config;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">config = YAML::<span class="built_in">LoadFile</span>(YAML_PATH);</span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span>(YAML::BadFile &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;read error, please change YAML_PATH in file State_Towr.cpp&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Kp = <span class="built_in">Vec3</span>(config[<span class="string">&quot;kp&quot;</span>][<span class="string">&quot;a&quot;</span>].as&lt;<span class="keyword">int</span>&gt;(), config[<span class="string">&quot;kp&quot;</span>][<span class="string">&quot;b&quot;</span>].as&lt;<span class="keyword">int</span>&gt;(), config[<span class="string">&quot;kp&quot;</span>][<span class="string">&quot;c&quot;</span>].as&lt;<span class="keyword">int</span>&gt;()).<span class="built_in">asDiagonal</span>();</span><br><span class="line">_Kd = <span class="built_in">Vec3</span>(config[<span class="string">&quot;kd&quot;</span>][<span class="string">&quot;a&quot;</span>].as&lt;<span class="keyword">int</span>&gt;(), config[<span class="string">&quot;kd&quot;</span>][<span class="string">&quot;b&quot;</span>].as&lt;<span class="keyword">int</span>&gt;(), config[<span class="string">&quot;kd&quot;</span>][<span class="string">&quot;c&quot;</span>].as&lt;<span class="keyword">int</span>&gt;()).<span class="built_in">asDiagonal</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Change kp to [&quot;</span></span><br><span class="line">          &lt;&lt; config[<span class="string">&quot;kp&quot;</span>][<span class="string">&quot;a&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; config[<span class="string">&quot;kp&quot;</span>][<span class="string">&quot;b&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; config[<span class="string">&quot;kp&quot;</span>][<span class="string">&quot;c&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Change kd to [&quot;</span></span><br><span class="line">          &lt;&lt; config[<span class="string">&quot;kd&quot;</span>][<span class="string">&quot;a&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; config[<span class="string">&quot;kd&quot;</span>][<span class="string">&quot;b&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; config[<span class="string">&quot;kd&quot;</span>][<span class="string">&quot;c&quot;</span>].as&lt;<span class="keyword">int</span>&gt;() &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read_yaml</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>管理git的submodule</title>
    <link href="https://www.robotsfan.com/posts/95374dd8.html"/>
    <id>https://www.robotsfan.com/posts/95374dd8.html</id>
    <published>2023-04-25T04:37:00.000Z</published>
    <updated>2024-07-17T03:04:24.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="管理git的submodule"><a href="#管理git的submodule" class="headerlink" title="管理git的submodule"></a>管理git的submodule</h1><h2 id="添加子仓库"><a href="#添加子仓库" class="headerlink" title="添加子仓库"></a>添加子仓库</h2><p>在主仓库需要添加submodule的地方新建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/xxx/sub_xxx.git</span><br></pre></td></tr></table></figure><p>注：<code>-b your_branch</code>可选</p><p>更新主仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;add submodule&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="自动更新主仓库"><a href="#自动更新主仓库" class="headerlink" title="自动更新主仓库"></a>自动更新主仓库</h2><p>打开github，创建新token</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230425114629665.png" alt="image-20230425114629665"></p><p>记录下这个token，只会显示一遍</p><p>在需要自动更新的submodule中点击</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230425114446598.png" alt="image-20230425114446598"></p><p>添加secret</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230425114520685.png" alt="image-20230425114520685"></p><p>回到仓库的Action，点击<code>set up a workflow yourself -&gt;</code>，随意起名，粘贴下述代码中的repository和branches：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Send</span> <span class="string">submodule</span> <span class="string">updates</span> <span class="string">to</span> <span class="string">parent</span> <span class="string">repo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">update:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span> </span><br><span class="line">          <span class="attr">repository:</span> <span class="string">xxx/parent_xxx</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PRIVATE_TOKEN_GITHUB</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Pull</span> <span class="string">&amp;</span> <span class="string">update</span> <span class="string">submodules</span> <span class="string">recursively</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git submodule update --init --recursive</span></span><br><span class="line"><span class="string">          git submodule update --recursive --remote</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Commit</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git config user.email &quot;actions@github.com&quot;</span></span><br><span class="line"><span class="string">          git config user.name &quot;GitHub Actions - update submodules&quot;</span></span><br><span class="line"><span class="string">          git add --all</span></span><br><span class="line"><span class="string">          git commit -m &quot;Update submodules&quot; || echo &quot;No changes to commit&quot;</span></span><br><span class="line"><span class="string">          git push</span></span><br></pre></td></tr></table></figure><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20230425115003220.png" alt="image-20230425115003220"></p><h2 id="使用主仓库"><a href="#使用主仓库" class="headerlink" title="使用主仓库"></a>使用主仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/xxx/parent_xxx</span><br></pre></td></tr></table></figure><p>若子仓库有更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取对应的分支</span></span><br><span class="line">git pull</span><br><span class="line"><span class="comment"># 更新对应代码</span></span><br><span class="line">git submodule update --remote --recursive</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Git" scheme="https://www.robotsfan.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.robotsfan.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>解决Github的Contribution没有增加的问题</title>
    <link href="https://www.robotsfan.com/posts/e5b94435.html"/>
    <id>https://www.robotsfan.com/posts/e5b94435.html</id>
    <published>2023-04-17T07:44:00.000Z</published>
    <updated>2024-07-17T03:04:29.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解决Github的Contribution没有增加的问题"><a href="#解决Github的Contribution没有增加的问题" class="headerlink" title="解决Github的Contribution没有增加的问题"></a>解决Github的Contribution没有增加的问题</h1><blockquote><p>转载于<a href="https://blog.csdn.net/Liven_Zhu/article/details/80800162">https://blog.csdn.net/Liven_Zhu/article/details/80800162</a></p></blockquote><p>最近在看自己的Github时，偶然间发现，自己的许多Conmmit都没有计算在Contribution内，然后看自己库中的Commit记录时，发现没有被记录在Contribution Graph中的Commit并不显示自己的头像，同时显示的用户名和自己创建Github账号时填的用户名也不一样。于是在网上找了一些资料，其中Github官方给出了一个官方文件，告诉我们什么样的Commit可以被记入Contribution，请点击此处查看。</p><p>在官方的帮助文档中，有一条是Commit被记入Contribution中必须满足用于Commit的邮件地址必须与Github账户相关联。其实，这也是为什么我的Commit没有被记入Contribution和不显示头像的原因，也是大多数人也是这个原因。</p><p>原因就是，当我们在电脑中下载了Git客户端后，我们会用本地git命令行配置一个用户名和邮箱地址，这个用户名和邮箱地址只有与创建Github时的邮箱和地址相同时，每次往Github上commit时，Github就会识别出commit的就是你本人，此时这次commit才会被记入Contribution。好了知道原因了，我们来具体看一下，如何操作：</p><p>首先，你需要知道，在你安装git客户端时，你配置的用户名和邮箱地址是什么，用下面的命令，可以显示出每次commit时的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit <span class="built_in">log</span></span><br></pre></td></tr></table></figure></p><p>在日志上可以看到每次commit时，你是用的用户名和邮箱地址，如果与Github上的不一致，那么问题就在于此了。</p><p>下面我们要把commit时的用户名和邮箱地址改为与Github注册时的一致，我们可以通过下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &lt;your username <span class="keyword">for</span> Github&gt;</span><br><span class="line">git config --global user.email &lt;your email address <span class="keyword">for</span> Github&gt;</span><br></pre></td></tr></table></figure><p>修改后，你以后再向Github提交代码时，就会看到commit被记入Contribution了。</p><p>同时，我们有一种补救方法，可以将以前与没有被记入Contribution的commits关联的邮箱修改为新的邮箱，那么，以前没有记入Contribution的commits，也会重新被记入Contribution。具体步骤如下：</p><ol><li><p>将要修改的repo克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --bare &lt;the repo address&gt;</span><br></pre></td></tr></table></figure></li><li><p>将命令行的当前目录切换到新克隆的库下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;the repo path&gt;</span><br></pre></td></tr></table></figure></li><li><p>根据你的信息修改以下变量，复制粘贴回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --env-filter <span class="string">&#x27;</span></span><br><span class="line"><span class="string">OLD_EMAIL=&lt;旧邮箱地址&gt;</span></span><br><span class="line"><span class="string">CORRECT_NAME=&lt;正确用户名&gt;</span></span><br><span class="line"><span class="string">CORRECT_EMAIL=&lt;正确邮箱地址&gt;</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span></span><br><span class="line"><span class="string">fi&#x27;</span> --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure></li><li><p>用<code>git log</code>查看用户名和邮箱地址有没有改过来</p></li><li><p>把正确历史push到Github上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force --tags origin <span class="string">&#x27;refs/heads/*&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Git" scheme="https://www.robotsfan.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.robotsfan.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Windows+Opencv+Clion的配置</title>
    <link href="https://www.robotsfan.com/posts/69395e08.html"/>
    <id>https://www.robotsfan.com/posts/69395e08.html</id>
    <published>2022-09-18T08:30:00.000Z</published>
    <updated>2024-07-17T03:00:26.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows-Opencv-Clion的配置"><a href="#Windows-Opencv-Clion的配置" class="headerlink" title="Windows+Opencv+Clion的配置"></a>Windows+Opencv+Clion的配置</h1><h2 id="下载OpenCV源码"><a href="#下载OpenCV源码" class="headerlink" title="下载OpenCV源码"></a>下载OpenCV源码</h2><p><a href="https://opencv.org/releases/">https://opencv.org/releases/</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918154832306.png" alt="image-20220918154832306" style="zoom:50%;"></p><p>解压到喜欢的位置，在<code>opencv</code> 根目录下新建<code>mingw_build</code>文件夹</p><h2 id="下载MinGW-W64"><a href="#下载MinGW-W64" class="headerlink" title="下载MinGW-W64"></a>下载MinGW-W64</h2><p><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/</a></p><p>注意一定要下载<code>x86_64-posix-sehMinGW</code>版本 的MinGW，否则后面编译会出错</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918155015462.png" alt="image-20220918155015462" style="zoom:50%;"></p><p>解压到喜欢的位置</p><h2 id="下载Cmake"><a href="#下载Cmake" class="headerlink" title="下载Cmake"></a>下载Cmake</h2><p><a href="https://cmake.org/download/">https://cmake.org/download/</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918155143589.png" alt="image-20220918155143589" style="zoom:50%;"></p><p>安装时选择为所有用户添加环境变量</p><h2 id="生成opencv的makefile文件"><a href="#生成opencv的makefile文件" class="headerlink" title="生成opencv的makefile文件"></a>生成opencv的makefile文件</h2><p>打开<code>cmake-gui</code></p><p>点击<code>Browse Source</code>选择选择 <code>opencv</code> 下的 <code>sources</code>文件夹</p><p>点击<code>Browse Build</code>选择选择 <code>opencv</code> 下的 <code>mingw_build</code>文件夹</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918155621342.png" alt="image-20220918155621342" style="zoom:50%;"></p><p>点击Configure，指定编译器</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918155658087.png" alt="image-20220918155658087" style="zoom:50%;"></p><p>分别选择刚刚下载的posix版本MinGW-W64下的gcc和g++</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918155721214.png" alt="image-20220918155721214" style="zoom:50%;"></p><p>点击Finish，等待完成</p><p>如遇到一下问题，请打开下面的文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918155936331.png" alt="image-20220918155936331" style="zoom:50%;"></p><p>按照日志里的下载地址分别下载这三个文件并放入<code>/source/.cache/ffmpeg</code>中，使用<code>certutil -hashfile 文件名 MD5</code>获取每个文件的MD5，以<code>MD5-文件名</code>重新命名这三个文件。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918160038962.png" alt="image-20220918160038962" style="zoom:50%;"></p><p>回到cmake-gui，重新点击Configure，若无其他报错则点击Generate生成Makefile文件。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>打开命令行进入<code>mingw-build</code>文件夹，使用<code>mingw32-make -j8</code>编译（8为核心数，请自行调整），编译速度大概10分钟左右。</p><p>编译成功后，使用<code>mingw32-make install</code>命令将编译生成的文件整合到<code>opencv/mingw_build/install</code>目录中</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>配置环境变量，将<code>opencv/mingw_build/install/x64/mingw/bin</code>加入环境变量中的path中。</p><h2 id="在clion项目中使用opencv"><a href="#在clion项目中使用opencv" class="headerlink" title="在clion项目中使用opencv"></a>在clion项目中使用opencv</h2><p>新建项目，编辑<code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenCV_Test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(OpenCV_Test main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置OpenCV目录</span></span><br><span class="line"><span class="keyword">set</span>(OpenCV_DIR E:/<span class="keyword">Install</span>/Tools/opencv/mingw_build/<span class="keyword">install</span>)</span><br><span class="line"><span class="comment"># 搜索OpenCV目录</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="comment"># 链接OpenCV库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(OpenCV_Test <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>编辑<code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;test&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;test&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220918162039679.png" alt="image-20220918162039679" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你电机FOC控制</title>
    <link href="https://www.robotsfan.com/posts/d99d1c1a.html"/>
    <id>https://www.robotsfan.com/posts/d99d1c1a.html</id>
    <published>2022-09-15T16:30:00.000Z</published>
    <updated>2024-07-17T03:20:07.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手把手教你电机FOC控制"><a href="#手把手教你电机FOC控制" class="headerlink" title="手把手教你电机FOC控制"></a>手把手教你电机FOC控制</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p><strong>2024.07.17 作者已很久没做过电机了，此文停更</strong></p><p>2022.09.16 完善图片内容与代码，更新到速度闭环</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220916003234988.png" alt="image-20220916003234988" style="zoom: 25%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220916003249372.png" alt="image-20220916003249372" style="zoom: 25%;"></p><h2 id="FOC框架引入"><a href="#FOC框架引入" class="headerlink" title="FOC框架引入"></a>FOC框架引入</h2><p>三向电机，分别为UVW三向，角度互差120度。若使用BLDC控制方法，如下图每次换向增加60度，转子只能到达六个位置，所以六步换向时会有振动。使用FOC控制方法可以使转子到达任意角度，所以运行起来会更加平滑。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ED2759D27293A18F51A49E35A2A46EB0.png" alt="ED2759D27293A18F51A49E35A2A46EB0" style="zoom:50%;"></p><p>如果想到达40度的位置，只需要在0度方向通电一段时间，在60度方向通电一段时间，再在空矢量的状态下通电一段时间（全桥000或111的位置为空矢量，空矢量的时长用来调节扭矩。后面会讲到），三段时间组成一个周期，以这个周期循环产生PWM，即可锁定至40度。若想到达其他角度，只需改变0度和60度的通电时长比例。</p><p>要想使磁场旋转起来，就需要输入正弦电压，但我们输入的是直流电，我们马上想到可以使用PWM波。通过不断改变<strong>PWM脉宽</strong>就可以模拟正弦电压，体现在电流上则为正弦电流。</p><p>下图为一个完整的FOC流程图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220418110757084.png" alt="image-20220418110757084" style="zoom: 80%;"></p><p>我们先来看正向通路：输入 $I_{d_ref}$ 和 $I_{q_ref}$ 与下文反馈通路采样得到的电流 $I_d$ 和 $I_q$ 进行PID控制输出 $U_d$ 和 $U_q$ （输入的 $I_{d_ref}$ 通常为0， $I_{q_ref}$ 前通常还需要接入一个速度PID构成速度环），再通过反Park变换转换成 $U_\alpha$ 和 $U_\beta$ ，通过SVPWM模块控制定时器产生六路互补的PWM信号，最后使用PWM信号控制全桥MOS管的通断，产生三向电压使电机转动。</p><p>再来看反馈通路：通过采样电阻采集任意两相电流，根据基尔霍夫电流定律可以算出第三相电流，将三向电流通过Clark变换转化成 $I_\alpha$ 和 $I_\beta$ ，再通过Park变换转换成 $I_d$ 和 $I_q$ ，作为反馈传入PID控制器构成电流环。</p><p>上图中的Park变换和反Park变换需要当前的角度作为输入；速度PID需要速度作为反馈。所以需要获得电机的速度与角度。角度和速度的获取方法分为有感和无感。有感方式使用霍尔元件（Hall Sensor），安装在电机上就可以检测电机磁铁的位置。无感使用观测器（observer）获得角度速度信息，本文将使用扩展卡尔曼滤波观测器（EKF），输入为  $U_\alpha$ 、 $U_\beta$ 、 $I_\alpha$ 、 $I_\beta$ 。使用无感方式不需要霍尔传感器，可以减少连接线的数量，也可以减小成本。</p><h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>为什么要使用坐标变换？电机控制大多是在控制速度/转矩，需要用PID闭环控制正弦交流电压的幅值和角度，不是很容易实现，所以通过坐标变化把正弦交流信息分解成角度信息（Q轴控制转矩）和幅值信息（D轴控制磁场）单独控制。</p><p><strong>FOC的变换中要满足等幅值变换，即变换前后幅值不变。</strong></p><p>坐标变换都分为正向变换和反向变换，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。</p><p>下面的变换均采用联立和矩阵两种形式表示，以方便使用。</p><h3 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h3><p>Clark变换实现了三向坐标系 $(a,b,c)$ 与直角坐标系 $(\alpha,\beta)$ 间的转换。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/7C602099D7A9549EDA9C24D13AB98072.png" alt="7C602099D7A9549EDA9C24D13AB98072" style="zoom: 67%;"></p><h4 id="正向Clark变换"><a href="#正向Clark变换" class="headerlink" title="正向Clark变换"></a>正向Clark变换</h4><p>Clark变换将三相信号转换为两相信号。已知三相坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    \begin{aligned}    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c    \end{aligned} \\    \begin{aligned}    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c    \end{aligned}\end{array}\right.</script><p>表示为矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{ccc}    1 & -\frac{1}{2}       & -\frac{1}{2} \\    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]</script><p>我们一般在电路中只采集两相电流，第三相电流可以使用基尔霍夫电流定律得出（ $I_a+I_b+I_c=0$ ），故上式也可整理为以下形式：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=\frac{3}{2}I_a \\    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}    \frac{3}{2} & 0\\    \frac{\sqrt{3}}{2} & \sqrt{3}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \end{array}\right]</script><p>由于变换前后 $I_a$ 和 $I_\alpha$ 幅值要相同，所以要进行等幅值变换，变换系数为 $\frac{2}{3}$ ，即变为</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=I_a \\    I_\beta=\frac{1}{\sqrt3}(I_a+2I_b)\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}    1 & 0\\    \frac{1}{\sqrt{3}} & \frac{2}{\sqrt{3}}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \end{array}\right]</script><p>（这里的系数在后文SVPWM里相电压的幅值与电压空间矢量之间有一个 $\frac{3}{2}$ 的系数相抵消）</p><p>MATLAB实现为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103933845.png" alt="image-20220330103933845" style="zoom: 80%;"></p><h4 id="反向Clark变换"><a href="#反向Clark变换" class="headerlink" title="反向Clark变换"></a>反向Clark变换</h4><p>Clark反变换则将两相信号转换为三相信号。根据图可以写出：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{a} =  U_{\alpha} \\U_{b} = -\frac{1}{2}U_{\alpha} + \frac{\sqrt3}{2}U_{\beta}\\U_{c} = -\frac{1}{2}U_{\alpha} - \frac{\sqrt3}{2}U_{\beta}\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    U_{a} \\    U_{b} \\    U_{c}\end{array}\right]=\left[\begin{array}{ccc}    1  & 0       \\    -\frac{1}{2} & \frac{\sqrt{3}}{2} \\    -\frac{1}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    U_{\alpha} \\    U_{\beta}\end{array}\right]</script><p>MATLAB实现为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103915885.png" alt="image-20220330103915885" style="zoom:80%;"></p><h3 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h3><p>Park变换实现了两相坐标系 $(\alpha,\beta)$ 与转子坐标系 $(d,q)$ 间的转换，此变换可以将正弦变量线性化。其中 $d$ 指向转子中心， $q$ 指向切线方向， $\theta$ 是转子当前的角度，也就是说 $d-q$ 坐标系始终跟着转子同步旋转。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/A20BC4DCAD2986A86187F746C2EDE88A.png" alt="A20BC4DCAD2986A86187F746C2EDE88A" style="zoom: 67%;"></p><h4 id="正向Park变换"><a href="#正向Park变换" class="headerlink" title="正向Park变换"></a>正向Park变换</h4><p>则根据上图可以写出</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos\theta+I_{\beta} \sin\theta \\I_{q}=-I_{\alpha} \sin\theta+I_{\beta} \cos\theta\end{array}\right.</script><p>很明显上述变换可以用旋转矩阵来表示，使用矩阵形式可以很方便地写出：</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & \sin \theta \\    -\sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>（如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。）</p><p>MATLAB实现为</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104003922.png" alt="image-20220330104003922" style="zoom:80%;"></p><h4 id="反Park变换"><a href="#反Park变换" class="headerlink" title="反Park变换"></a>反Park变换</h4><p>根据上面的推导可以求得反Park变换</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{\alpha}=U_{d} \cos\theta-U_{q} \sin\theta \\U_{\beta}= U_{d} \sin\theta+U_{q} \cos\theta\end{array}\right.</script><p>同理，使用旋转矩阵可以求出反变换的系数矩阵：</p><script type="math/tex; mode=display">\left[\begin{array}{l}    U_{\alpha} \\    U_{\beta}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & -\sin \theta \\     \sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    U_{d} \\    U_{q}\end{array}\right]</script><p>MATLAB实现为</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103857619.png" alt="image-20220330103857619" style="zoom:80%;"></p><h3 id="MATLAB仿真"><a href="#MATLAB仿真" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h3><p>为了更清楚地仿真，这里不用矩阵形式表示，如需矩阵形式可以看我写的另一篇文章。</p><p>请注意，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。但是在这节的仿真中，把正变换和反变换连在一起，这样做没有实际意义，只是为了验证变化算法。</p><p>输入Vd为0，Vq为1，角度为由0到2pi的连续值。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103716603.png" alt="image-20220330103716603" style="zoom: 80%;"></p><p>再来看子模块内部，输入经过两个逆变换，再经过两个正变换。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103816443.png" alt="image-20220330103816443" style="zoom:80%;"></p><p>运行查看波形（新版本MATLAB常值输入为一个圆圈）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104412589.png" alt="image-20220330104412589" style="zoom:50%;"></p><h2 id="SVPWM"><a href="#SVPWM" class="headerlink" title="SVPWM"></a>SVPWM</h2><p>根据BLDC的六步换向，可以将一圈分为六个扇区，前文FOC引入章节已经讲过，只需要控制每个状态通电的时间就可以控制转子到达任意角度。这就是SVPWM。</p><p>SVPWM的输入为 $U_{\alpha}$ 和 $U_{\beta}$ ，输出为三向计数器的比较值。所以应该首先判断用哪两个相邻矢量，然后计算两个相邻矢量的作用时长，然后将作用时长转化成计数器的比较数值送入定时器。下面对这三个步骤进行讲解。</p><h3 id="扇区判断"><a href="#扇区判断" class="headerlink" title="扇区判断"></a>扇区判断</h3><p>三相电压可以表示为（ $U_{m}$ 为电压幅值）：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{m}cos\theta \\U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\U_c = U_{m}cos(\theta+\frac{2}{3}\pi)\end{array}</script><p>将其转换为 $\alpha-\beta$ 坐标系，可以算出</p><script type="math/tex; mode=display">\begin{array}{l}U_{\alpha} = U_{m}cos\theta \\U_{\beta} = U_{m}sin\theta\end{array}</script><p>从这个式子发现，可以从中算出角度信息从而可以判断在哪个扇区</p><script type="math/tex; mode=display">\theta = arctan(\frac{U_{\beta}}{U_{\alpha}})</script><p>由于除法和反三角函数对于MCU来说计算量比较大。我们来找一个简便算法。</p><p> $U_{\alpha}$ 是关于cos的三角函数， $U_{\beta}$ 是关于sin的三角函数，可以得到：</p><script type="math/tex; mode=display">\begin{array}{l}扇区1:& U_{\alpha} > 0&,& U_{\beta} > 0\\扇区2:& U_{\alpha} >or< 0&,& U_{\beta} > 0\\扇区3:& U_{\alpha} < 0&,& U_{\beta} > 0\\扇区4:& U_{\alpha} < 0&,& U_{\beta} < 0\\扇区5:& U_{\alpha} >or< 0&,& U_{\beta} < 0\\扇区6:& U_{\alpha} > 0&,& U_{\beta} < 0\end{array}</script><p>可以看到，通过 $U_{\beta}$ 的正负可以判断出是1/2/3扇区还是4/5/6扇区。</p><p>这个条件只将扇区分为两个部分，我们还需要几个条件来更细致地分。将每个扇区的反三角函数范围计算出来：</p><script type="math/tex; mode=display">\begin{aligned}扇区1:& tan0^{\circ} >   \frac{U_{\beta}}{U_{\alpha}} > tan60^{\circ} &\Rightarrow& 0 &>&        \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\扇区2:& tan60^{\circ} >  \frac{U_{\beta}}{U_{\alpha}} > tan120^{\circ} &\Rightarrow& \sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\扇区3:& tan120^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan180^{\circ} &\Rightarrow&-\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0        \\扇区4:& tan180^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan240^{\circ} &\Rightarrow&0        &>& \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\扇区5:& tan240^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan300^{\circ} &\Rightarrow&\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\扇区6:& tan300^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan360^{\circ} &\Rightarrow& -\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0\end{aligned}</script><p>观察这个结论， $U_{\beta}$ 和 $\sqrt{3}U_{\alpha}$ 似乎有关系，回顾反Clark变换， $U_{b}$ 和 $U_{c}$ 的式子就是这种关系。所以可以把上面的结论往反Clark变换上凑。看一下反Clark变换的图像，注意我们需要的关系里的 $\sqrt{3}$ 是乘在 $U_{\alpha}$ 上的，所以我们把 $U_{\beta}$ 和 $U_{\alpha}$ 反一下，对应的公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{a} =  U_{\beta} \\U_{b} = -\frac{1}{2}U_{\beta} + \frac{\sqrt3}{2}U_{\alpha}\\U_{c} = -\frac{1}{2}U_{\beta} - \frac{\sqrt3}{2}U_{\alpha}\end{array}\right.</script><p>生成上述公式的图像，其中黄色的线为 $U_{a}$ 为 $U_{\beta}$ ，蓝色的线 $U_{b}$ 为 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，红色的线 $U_{c}$ 为 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330145027064.png" alt="image-20220330145027064" style="zoom:50%;"></p><p>可以看到在每个扇区内总有一向大于0，两向小于0，所以 $U_{b}$ 和 $U_{c}$ 的正负可以当做判断条件之一。我们顺便还又一次得到了 $U_{\beta}$ 这个判断条件。整理一下上面的式子</p><script type="math/tex; mode=display">\begin{aligned}扇区1:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\扇区2:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\扇区3:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区4:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区5:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区6:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\end{aligned}</script><p>所以通过计算 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 的正负可以判断出是1/6扇区，3/4扇区，2扇区，5扇区的哪一组。</p><p>综上，我们的判断条件有： $U_{\beta}$ 、 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 。我们分别定义：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{\beta} \\U_b = \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\\U_c = -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\end{array}</script><p>综合这三个条件就可以判断是在哪个扇区 。那么有没有一种算法可以将这一堆判断数值化并转换成1~6的数字呢？可以用下面的公式：</p><script type="math/tex; mode=display">N=A+2B+4C</script><p>式中A代表 $U_a$ 的正负，B代表 $U_b$ 的正负，C代表 $U_c$ 的正负，大于0为1，小于0为0。最后转换出来的的N即为1~6的数字：</p><script type="math/tex; mode=display">\begin{array}{c}扇区 & 1 & 2 & 3 & 4 & 5 & 6 & \\N   & 3 & 1 & 5 & 4 & 6 & 2 &\end{array}</script><p>至此，我们成功完成了扇区判断。</p><h3 id="计算相邻矢量作用时长"><a href="#计算相邻矢量作用时长" class="headerlink" title="计算相邻矢量作用时长"></a>计算相邻矢量作用时长</h3><p>控制相邻矢量作用时长就可以控制转子到达任意方向，下面进行分析。</p><h4 id="六个矢量的大小"><a href="#六个矢量的大小" class="headerlink" title="六个矢量的大小"></a>六个矢量的大小</h4><p>六个MOS管可以产生8种状态</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152650462.png" alt="image-20220330152650462" style="zoom:50%;"></p><p>设上开下合为0（电流从O往对应的向流），上合下开为1（电流从对应的向往O流），表示其中的六个矢量。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152634407.png" alt="image-20220330152634407" style="zoom:50%;"></p><p>放在一张图中即为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152741018.png" alt="image-20220330152741018" style="zoom:50%;"></p><p>还有两个零矢量（000和111），无电流，不产生磁场。</p><p>对于100的状态，可以等效为下面的电路图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330154344462.png" alt="image-20220330154344462" style="zoom: 25%;"></p><p>可以计算出电机中三个相电压（每相相对于电机中间连接点的电压）</p><script type="math/tex; mode=display">\begin{aligned}U_{AN} &=U_{A}-U_{N}=\frac{2}{3} U_{d c} \\U_{BN} &=U_{B}-U_{N}=-\frac{1}{3} U_{d c} \\U_{CN} &=U_{C}-U_{N}=-\frac{1}{3} U_{d c}\end{aligned}</script><p>同理可以计算其他所有方向矢量的相电压，可以看出，六个矢量的大小均为 $\frac{2}{3} U_{d c}$ ，即<strong>SVPWM相电压幅值为 $\frac{2}{3} U_{d c}$</strong> </p><h4 id="电压利用率"><a href="#电压利用率" class="headerlink" title="电压利用率"></a>电压利用率</h4><p>电压利用率等于合成矢量的电压除以母线电压。下面在复平面计算合成矢量的电压 $U_{out}$ ：</p><script type="math/tex; mode=display">U_{out} = U_a +U_{b}\cdot e^{j\cdot \frac{2}{3}\pi}+U_{c}\cdot e^{j\cdot (-\frac{2}{3}\pi)}</script><p>根据欧拉公式可以推导出：</p><script type="math/tex; mode=display">e^{jx}=cosx+jsinx</script><p>又因为三相电压与相电压幅值之间的关系：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{m}cos\theta \\U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\U_c = U_{m}cos(\theta+\frac{2}{3}\pi)\end{array}</script><p>带入可以计算出 $U_{out}$ ：</p><script type="math/tex; mode=display">U_{out}=\frac{3}{2}U_m\cdot e^{j\theta}</script><p>合成矢量的电压是相电压幅值的 $\frac{3}{2}$ 倍，而SVPWM相电压幅值 $U_m$ 为 $\frac{2}{3} U_{d c}$ ，所以</p><script type="math/tex; mode=display">U_{out}=U_{dc}</script><p>即<strong>合成矢量的电压等于母线电压</strong>。所以<strong>SVPWM的电压利用率是100%</strong>。</p><h4 id="SVPWM输出电压是马鞍波"><a href="#SVPWM输出电压是马鞍波" class="headerlink" title="SVPWM输出电压是马鞍波"></a>SVPWM输出电压是马鞍波</h4><p>由于中间连接点N的点位 是浮动的，为三角波，而相电压是每相相对于电机中间连接点N的电压，所以相电压不是一个正弦波，而是一个正弦波与一个三角波叠加而成的，即为马鞍波。网图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/d94c427b1d664ffe9b585d58e60482f6.jpg" alt="d94c427b1d664ffe9b585d58e60482f6" style="zoom:50%;"></p><h4 id="矢量作用时长"><a href="#矢量作用时长" class="headerlink" title="矢量作用时长"></a>矢量作用时长</h4><p>合成矢量的电压是所在扇区两个矢量与空矢量不同时长的组合，其中 $T_N$ 为空矢量作用时长：</p><script type="math/tex; mode=display">U_{out}=U_x\frac{T_x}{T_s}+U_y\frac{T_y}{T_s}+U_N\frac{T_N}{T_s}</script><p>由于SVPWM的输入是 $U_{\alpha}$ 和 $U_{\beta}$ ，但是要控制 $T_x$ 和 $T_y$ ，所以要找到他们的对应关系。</p><p>对于第一个扇区，将 $U_{out}$ 在 $\alpha-\beta$ 坐标系中表示：</p><script type="math/tex; mode=display">\begin{array}{l}U_\alpha=|U_x|\frac{T_x}{T_s}+|U_y|\frac{T_y}{T_s}cos60^{\circ}\\U_\beta=|U_y|\frac{T_y}{T_s}sin60^{\circ}\end{array}</script><p>其中 $|U_x|$ 和 $|U_y|$ 根据前面的计算均为 $\frac{2}{3} U_{d c}$ ，可以解出：</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\end{array}</script><p>同理，可以计算出所有六个扇区：</p><p>第二扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\end{array}</script><p>第三扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\end{array}</script><p>第四扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\end{array}</script><p>第五扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\end{array}</script><p>第六扇区 </p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\end{array}</script><p>六个扇区中都有相同的项，其中包含前文判断扇区所用的 $U_1$ 、 $U_2$ 、 $U_3$ 。直接把前面已经计算过的变量拿过来使用，大大减少了计算量。式中的 $\frac{\sqrt{3}T_S}{U_{dc}}$ 为调制比，定义：</p><script type="math/tex; mode=display">\begin{array}{l}U_{mr} = \frac{\sqrt{3}T_S}{U_{dc}} \\X= \frac{\sqrt{3}T_S}{U_{dc}}U_\beta=U_{mr}U_1\\Y= \frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_2\\Z= \frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_3\end{array}</script><p>可以将六个扇区表示为：</p><script type="math/tex; mode=display">\begin{array}{c}& T_x & T_y  \\扇区1&  Y  &  X  \\扇区2& -Y  & -Z  \\扇区3&  X  &  Z  \\扇区4& -X  & -Y  \\扇区5&  Z  &  Y  \\扇区6& -Z  & -X  \\\end{array}</script><p>注意：当非零矢量作用时间 $Tx+Ty&gt;Ts$ ，需要进行过饱和处理：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}T_{x}=\frac{T_{x}}{T_{x}+T_{y}} T_{s} \\T_{y}=\frac{T_{y}}{T_{x}+T_{y}} T_{s}\end{array}\right.</script><h3 id="定时器比较值计算"><a href="#定时器比较值计算" class="headerlink" title="定时器比较值计算"></a>定时器比较值计算</h3><p>我们前文算出来的 $T_x$ 和 $T_y$ 以秒为单位，在单片机中使用定时器控制MOS管的通断需要配置比较值，所以需要把 $T_x$ 和 $T_y$ 转换为三个互补的定时器比较值 $T_1$ 、 $T_2$ 和 $T_3$ 。</p><p>定时器应设置为中心对齐模式，若为向上计数，计数器会从0开始计数到最大值，再反向从最大值计数到0；向下计数反之。故只需要控制前半个周期的比较值就可以产生相对中心对称的PWM波。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/CB0D861C81399F86BFB03E925F9AF8AC.png" alt="CB0D861C81399F86BFB03E925F9AF8AC" style="zoom:50%;"></p><p>为了减少MOS管的开关损耗，提高其使用寿命，应尽量减少MOS管的开关次数。在一个扇区内切换状态的时候，合理使用零矢量可以保证每次切换只改变一个MOS管。</p><p>先来看第一扇区，以每次只改变一个MOS管为原则，则切换顺序为：</p><script type="math/tex; mode=display">000 \to 100 \to 110 \to 111 \to 110 \to 100 \to 000</script><p>可以看到，切换顺序构成了一个环路。在一个周期内我们需要控制三段作用时长：</p><script type="math/tex; mode=display">T_s=T_x+T_y+T_N</script><p>六个MOS需要产生六路PWM来控制他们的状态。由于上下半桥是互补的，所以只需要生成三个PWM：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331151522966.png" alt="image-20220331151522966" style="zoom:50%;"></p><p>由于是中心对齐模式，所以只需要控制半个周期的时长 $\frac{T_x}{2}$ 和 $\frac{T_y}{2}$ 。在半个周期内 $T_N$ 出现了两次，分别为000和111，在半个周期内将这两段时间平均分配。即为 $\frac{T_S-T_x-T_y}{4}$ 。</p><p>这样就可以计算三个定时器的比较值 $T_1$ 、 $T_2$ 和 $T_3$ ：</p><script type="math/tex; mode=display">\begin{array}{l}T_1= \frac{T_S-T_x-T_y}{4}\\T_2=T_1+\frac{T_x}{2}\\T_3=T_2+\frac{T_y}{2}\end{array}</script><p>同理，可以计算出全部六个扇区的切换顺序，这里计算过程不再赘述。由图像和计算结果可以分析出，无论在哪个扇区中，三个定时器切换的图像都是由上图中三个方波构成，三个图像排列组合也正好就是六个扇区的组合方式。故为了方便程序运行，将六个扇区的定时器比较值归纳如下：</p><p>设</p><script type="math/tex; mode=display">\begin{array}{l}T_a= \frac{T_S-T_x-T_y}{4}\\T_b=T_a+\frac{T_x}{2}\\T_c=T_b+\frac{T_y}{2}\end{array}</script><p>此时六个扇区可以表示为：</p><script type="math/tex; mode=display">\begin{array}{c}  & 扇区1 & 扇区2 & 扇区3 & 扇区4 & 扇区5 & 扇区6 & \\T1& T_a & T_b & T_c & T_c & T_b & T_a &\\T2& T_b & T_a & T_a & T_b & T_c & T_c &\\T3& T_c & T_c & T_b & T_a & T_a & T_b &\end{array}</script><p>也就是说编程时只需要计算 $T_a$ 、 $T_b$ 和 $T_c$ ，通过判断就可以得到对应扇区的比较值。</p><p>至此，SVPWM输出比较值 $T_1$ 、 $T_2$ 、 $T_3$ ，互补得到六个比较值，输入到定时器，输出三路PWM。</p><h4 id="MATLAB仿真-1"><a href="#MATLAB仿真-1" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h4><p>假设需要产生10Khz的PWM波，则一个周期为0.0001秒。若单片机主频为180Mhz，预分频系数为100-1，由下面计算公式：（其中 $ARR$ 是计数值， $PSC$ 是预分频值）</p><script type="math/tex; mode=display">Fpwm(Hz) = \frac{主频(M)}{(ARR+1)*(PSC+1)}</script><p>180,000,000/(18,000*100)=10,000Hz，则定时器的计数值应设置为18000-1。</p><p>在模型中设定 $Udc$ 为24， $Tpwm$ 为18000。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163919487.png" alt="image-20220331163919487" style="zoom:50%;"></p><p>在foc子模块中，将park反变换的输出输入到SVPWM模块：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163836635.png" alt="image-20220331163836635" style="zoom: 67%;"></p><p>SVPWM模块代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[T1,T2,T3,sector]</span> = <span class="title">fcn</span><span class="params">(Ualpha,Ubeta,Udc,Tpwm)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">sector = single(<span class="number">0</span>);</span><br><span class="line">T1 = single(<span class="number">0</span>);</span><br><span class="line">T2 = single(<span class="number">0</span>);</span><br><span class="line">T3 = single(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一步：扇区判断</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ua = Ubeta;</span><br><span class="line">Ub = (<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line">Uc = (-<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% 计算判断扇区所用的ABC的值</span></span><br><span class="line">A=single(<span class="number">0</span>);B=single(<span class="number">0</span>);C=single(<span class="number">0</span>);N=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(Ua&gt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ua&lt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Ub&gt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ub&lt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Uc&gt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Uc&lt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算判断扇区所用的N的值</span></span><br><span class="line">N = A + <span class="number">2</span>*B + <span class="number">4</span>*C;</span><br><span class="line"><span class="comment">% 扇区判断</span></span><br><span class="line"><span class="keyword">switch</span> (N)   </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        sector = single(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        sector = single(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        sector = single(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        sector = single(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        sector = single(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        sector = single(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：计算相邻矢量作用时长</span></span><br><span class="line"><span class="comment">% 计算调制比</span></span><br><span class="line">Umr = <span class="built_in">sqrt</span>(<span class="number">3</span>)*Tpwm/Udc;</span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">X = Umr * Ua;</span><br><span class="line">Y = Umr * Ub;</span><br><span class="line">Z = Umr * Uc;</span><br><span class="line"><span class="comment">% 分扇区计算Tx和Ty的值</span></span><br><span class="line">Tx=single(<span class="number">0</span>);Ty=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        Tx = Y; Ty = X;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        Tx = -Y; Ty = -Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        Tx = X; Ty = Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        Tx = -X; Ty = -Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        Tx = Z; Ty = Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        Tx = -Z; Ty = -X;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：定时器比较值计算</span></span><br><span class="line"><span class="comment">% 干啥用的？</span></span><br><span class="line"><span class="keyword">if</span> Tx+Ty &gt; Tpwm</span><br><span class="line">    Tx = Tx/(Tx+Ty);</span><br><span class="line">    Ty = Ty/(Tx+Ty);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Tx = Tx;</span><br><span class="line">    Ty = Ty;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ta = (Tpwm-Tx-Ty)/<span class="number">4.0</span>;</span><br><span class="line">Tb = Ta+Tx/<span class="number">2.0</span>;</span><br><span class="line">Tc = Tb+Ty/<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">% 分扇区计算定时器比较值T1、T2和T3的值</span></span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        T1 = Ta; T2 = Tb; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        T1 = Tb; T2 = Ta; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        T1 = Tc; T2 = Ta; T3 = Tb;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        T1 = Tc; T2 = Tb; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        T1 = Tb; T2 = Tc; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        T1 = Ta; T2 = Tc; T3 = Tb;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到，定时器比较值为马鞍波</p><p><img src="/posts/Users\fanziqi\AppData\Roaming\Typora\typora-user-images\image-20220331165323898.png" alt="image-20220331165323898" style="zoom: 50%;"></p><p>扇区为从1到6的循环</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331165348883.png" alt="image-20220331165348883" style="zoom:50%;"></p><h2 id="电流闭环"><a href="#电流闭环" class="headerlink" title="电流闭环"></a>电流闭环</h2><p>经过前文的反Park变换、SVPWM、定时器与全桥，输入的 $U_{d}$ 和 $U_{q}$ 最终转换为三相电压输出到电机。如果需要让电机以设定的电流值运行，就需要使用PI控制器闭环控制电流。但三相交流电流是不太容易实现闭环控制的，所以我们选择对直流电流 $I_{d}$ 和 $I_{q}$ 进行闭环控制。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220418111545651.png" alt="image-20220418111545651" style="zoom: 67%;"></p><p>PI控制器输入目标参考电流 $I_{d_{ref}}$ 和 $I_{q_{ref}}$ ，输出 $U_{d}$ 和 $U_{q}$ ，现在还缺少反馈量 $I_{d}$ 和 $I_{q}$ ，这就需要用到前文讲到的Park与Clark正变换。安装采样电阻，用单片机的ADC采集全桥上任意两相的电流，通过基尔霍夫电流定律可计算第三相的电流，通过Clark变换计算出 $I_{\alpha}$ 和 $I_{\beta}$ ，再通过Park变换计算出反馈量 $I_{d}$ 和 $I_{q}$ 。</p><p>对于PI控制器参数的设定，以下为一个参考值（但还是需要自行调整）：</p><script type="math/tex; mode=display">\begin{array}{c}  & P & I &\\d& K_{pd}=\alpha L_d & K_{Id}=\alpha R\\q& K_{pq}=\alpha L_q & K_{Iq}=\alpha R\end{array}</script><p>其中 $\alpha$ 的取值为：（其中 $\tau$ 为电机的时间常数）</p><script type="math/tex; mode=display">\alpha = \frac{2\pi}{\tau} \\\tau = min\left\{\frac{L_d}{R},\frac{L_q}{R}\right\}</script><p>电机分为表贴电机和内嵌式电机，表贴式电机的永磁体贴在转子表面，内嵌式电机的永磁体安装在转子内。我们常用的电机都是表贴电机，对于表贴电机， $L_d=L_q=L$ ，则可以得到PI控制器的参考参数：</p><script type="math/tex; mode=display">K_{p}=2\pi R \\K_{I}=2\pi \frac{R^2}{L}</script><h2 id="角度和速度的获取"><a href="#角度和速度的获取" class="headerlink" title="角度和速度的获取"></a>角度和速度的获取</h2><h3 id="有感（HALL）"><a href="#有感（HALL）" class="headerlink" title="有感（HALL）"></a>有感（HALL）</h3><p>霍尔传感器分为60度和120度</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/1C13C24117669CA4C27767785618F5F9.png" alt="1C13C24117669CA4C27767785618F5F9" style="zoom:50%;"></p><p>画一下转一圈三个霍尔传感器的波形</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/C18D380D267A0837CAFBC98D96941EA6.png" alt="C18D380D267A0837CAFBC98D96941EA6" style="zoom:50%;"></p><p>可以看到，这两种排列方式除了组合方式不同，其他都一样。</p><p>单片机通过输入捕获采集三路高低电平的跳变，通过对三路信号进行异或，则转一圈可以进6次中断，进入中断后检测IO电平就可以知道电机对应角度。但现在一圈只能获取到6个固定的角度值，无法获取到如80度这个角度。这时可以对速度进行积分得到角度，速度的获取可以通过查询60-120之间定时器的计数值来获得。但是转到80度的时候没办法获取到120度时候的定时器计数值就无法获取当前段的速度，这时可以用前一段的速度近似为当前段的速度。</p><h3 id="无感（EKF）"><a href="#无感（EKF）" class="headerlink" title="无感（EKF）"></a>无感（EKF）</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>前面的有感部分，是在电机上安装霍尔传感器，引出三根线到单片机通过输入捕获算出当前角度，再与预设角度完成角度闭环。</p><p>而无感控制则不需要霍尔传感器，只需要三根UVW线输出到电机即可，去掉了霍尔传感器和三根线，节省了成本；有些使用场合无法使用霍尔传感器，则需要使用无感，比如空调压缩机，内部充满了润滑油，无法安装霍尔传感器；有些时候有感算法或硬件出现问题也可以切换至无感，防止系统闸机，比如汽车运行中霍尔传感器突然坏了，为了使整个系统正常运行，就可以临时切换到无感。上述这些都是无感控制的优点。无感控制现在已经越来越普及，空调、洗衣机、高端风扇、汽车都在用无感控制。</p><h4 id="状态观测器"><a href="#状态观测器" class="headerlink" title="状态观测器"></a>状态观测器</h4><p>观测器有很多种，扩展卡尔曼滤波观测器、滑膜观测器、龙伯格观测器、自适应观测器、磁链观测器等。其中扩展卡尔曼滤波观测器的低速性能比较好，所以本文重点讨论EKF。</p><p>状态观测器实质上就是用数学方法建立一个可以模拟真实被控对象的模型，用这个模型来得知一些无法通过测量得到的状态量。对于电机系统来说，如果没有传感器去测量电机的转速和转子位置，那么就可以通过搭建状态观测器来估算电机的转子和转子位置，这就是基于状态观测器的电机的无传感器控制。</p><p>但是使用这种方法建立的观测器有着诸多问题：</p><ol><li>抗干扰能力差：加入扰动或负载，此时的状态观测器很难保持正确的响应而导致输出错误或者系统崩溃；</li><li>存在误差：误差主要存在与系统误差和测量误差<ol><li>系统误差：在建模的时候电机的参数不可能完全精确，在建模的时候造成误差。</li><li>测量误差：观测器需要电流作为输入，而电流的采集就会存在误差。</li></ol></li></ol><p>所以为了解决以上问题，需要给状态观测器增加反馈，通过反馈来修正状态观测器的输出，让观测器尽可能的去贴近真实的电机。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/017fc22e045b4488a08db81c18a6590f.png" alt="在这里插入图片描述"></p><h5 id="状态空间表示"><a href="#状态空间表示" class="headerlink" title="状态空间表示"></a>状态空间表示</h5><p>线性系统的状态空间方程为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\dot x = Ax+Bu\\y=Hx\end{array}\right.</script><p>永磁同步电机的方程：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_\alpha = Ri_\alpha + L_s \frac{di_\alpha}{dt} - \omega_e \psi_f sin\theta\\U_\beta = Ri_\beta + L_s \frac{di_\beta}{dt} + \omega_e \psi_f cos\theta\end{array}\right.</script><p>上述方程的含义为：将每一相抽象为一个电阻，一个电感和一个反电动势的串联，则每一相的电压为前面三项压降之和（反电动势为速度乘磁链）。方程中的电阻R、电感L、和磁链flux为电机的固有参数，电流可以通过采样电阻得到，只剩下了角度和转速，将电机方程转化为状态空间表达：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\frac{d i_\alpha}{dt} = -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta + \frac{1}{L_s}U_\alpha \\\frac{d i_\beta}{dt} = -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta + \frac{1}{L_s}U_\beta \\\frac{d \omega_e}{dt} = 0 \\\frac{d \theta}{dt} = \omega_e\end{array}\right.</script><h5 id="矩阵化表示"><a href="#矩阵化表示" class="headerlink" title="矩阵化表示"></a>矩阵化表示</h5><p>接下来我们将上面的式子整理成矩阵形式，首先确认状态变量分别为 $ \dot{i_\alpha},\dot{i_\beta},\dot{\omega_e},\dot{\theta}$ ，则有：</p><script type="math/tex; mode=display">\begin{aligned}\dot{x}=\begin{bmatrix} \dot{i_\alpha} \\ \dot{i_\beta} \\ \dot{\omega_e} \\ \dot{\theta} \\\end{bmatrix}\quadx=\begin{bmatrix} i_\alpha \\ i_\beta \\ \omega_e \\ \theta \\\end{bmatrix}\end{aligned}</script><p>输入 $u$ ，对于电机来说就是电压，我们选择 $\alpha-\beta$ 坐标系：</p><script type="math/tex; mode=display">\begin{aligned}u=\begin{bmatrix} U_\alpha \\ U_\beta \\\end{bmatrix}\end{aligned}</script><p>输出矩阵 $y$ 为通过采样电阻测得的电流：</p><script type="math/tex; mode=display">\begin{aligned}y=\begin{bmatrix} i_\alpha \\ i_\beta \\\end{bmatrix}\end{aligned}</script><p>则 $H$ 和 $B$ 矩阵就可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}H=\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\\end{bmatrix}\quadB=\begin{bmatrix} \frac{1}{L_s} & 0 \\ 0 & \frac{1}{L_s} \\ 0 & 0 \\ 0 & 0 \\\end{bmatrix}\end{aligned}</script><p>此时矩阵形式的表示为：</p><script type="math/tex; mode=display">\begin{aligned}\begin{bmatrix}i_{\alpha} \\\dot{i}_{\beta} \\\dot{\omega} \\\dot{\theta}\end{bmatrix} & = \begin{bmatrix}-\frac{R}{L_{S}} i_{\alpha}+\frac{1}{L_{s}} \omega_{e} \psi_{f} \sin \theta \\-\frac{R}{L_{S}} i_{\beta}-\frac{1}{L_{s}} \omega_{e} \psi_{f} \cos \theta \\0 \\\omega_{e}\end{bmatrix}+\begin{bmatrix}\frac{1}{L_{s}} & 0 \\0 & \frac{1}{L_{s}} \\0 & 0 \\0 & 0\end{bmatrix}\begin{bmatrix}u_{\alpha} \\u_{\beta}\end{bmatrix}\\\begin{bmatrix}i_{\alpha} \\i_{\beta}\end{bmatrix} & = \begin{bmatrix}1 & 0 & 0 & 0 \\0 & 1 & 0 & 0\end{bmatrix}\begin{bmatrix}i_{\alpha} \\i_{\beta} \\\omega_{e} \\\theta\end{bmatrix}\end{aligned}</script><p>对比状态空间表示，无法显式地表示出线性的 $Ax$ ，因为电机系统不是线性的，所以用 $f(x)$ 这一非线性项替代这一项。 $f(x)$ 定义为：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=\begin{bmatrix} -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta \\ -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta \\ 0 \\ \omega_e \\\end{bmatrix}\end{aligned}</script><p>则此时的状态空间方程变为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\dot x = f(x)+Bu\\y=Hx\end{array}\right.</script><h4 id="扩展卡尔曼滤波器"><a href="#扩展卡尔曼滤波器" class="headerlink" title="扩展卡尔曼滤波器"></a>扩展卡尔曼滤波器</h4><p>关于卡尔曼滤波器的知识请看这篇文章：<a href="https://www.robotsfan.com/posts/b4727fbe.html">手撕卡尔曼滤波器</a></p><p>扩展卡尔曼滤波器（Extend Kalman Filter），简称EKF。带“扩展”二字，是因为卡尔曼滤波器只能处理线性系统，而电机是一个非线性，强耦合的系统，使用扩展卡尔曼滤波器可以处理这种非线性系统。</p><p>前文的状态空间方程中 $f(x)$ 是非线性的，如果想对非线性系统进行卡尔曼滤波，需要对其线性化（Linearization），泰勒级数展开是将非线性系统线性化的一种方法。将 $f(x)$ 泰勒级数展开并取前两项：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=f(x_0)+\frac{\partial f(x)}{\partial x}(x-x_0)\end{aligned}</script><p>对 $f(x)$ 求偏导：</p><script type="math/tex; mode=display">\begin{aligned}F = \frac{\partial f(x)}{\partial x}=\begin{bmatrix}-\frac{R}{L_{S}} & 0 & \frac{\psi_{f} \sin \theta}{L_{S}} & \frac{\omega_{e} \psi_{f} \cos \theta}{L_{S}} \\0 & -\frac{R}{L_{S}} & -\frac{\psi_{f} \cos \theta}{L_{S}} & \frac{\omega_{e} \psi_{f} \sin \theta}{L_{S}} \\0 & 0 & 0 & 0 \\0 & 0 & 1 & 0\end{bmatrix}\end{aligned}</script><p>此时状态空间方程变为：</p><script type="math/tex; mode=display">\dot{x}=f(x_{0})+F(x-x_{0})+B u</script><p>状态方程是建立在连续系统的基础上，需要将其转化成离散化系统后，才能在微控制器中实现卡尔曼滤波状态观测器。在离散化系统中， $\dot{x}=\frac{x_{k}-x_{k-1}}{\Delta t}$ ，则状态空间方程表示为：</p><script type="math/tex; mode=display">\begin{aligned}\frac{x_{k}-x_{k-1}}{\Delta t}  &= f(x_{k-1})+B u_{k-1}\\x_{k}&=x_{k-1}+(f(x_{k-1})+B u_{k-1}) \Delta t\\&=(I+F\Delta t)x_{k-1}+B u_{k-1}\Delta t\end{aligned}</script><p>令 $A=(I+F\Delta t)$ ，扩展卡尔曼滤波器的流程为以下五步：</p><ul><li><p>预测</p><ol><li><p>计算预估值</p><p>$\hat{x}_k^-=\hat{x}_{k-1}+(f(x_{k-1})+B u_{k-1}) \Delta t$</p></li><li><p>计算误差协方差</p><p>$P_k^-=(I+F\Delta t)P_{k-1}(I+F\Delta t)^T+Q$</p></li></ol></li><li><p>校正</p><ol><li><p>计算卡尔曼增益</p><p>$K_k=P_k^-H^T(HP_k^-H^T+R)^{-1}$</p></li><li><p>修正预估值</p><p>$\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)$ </p></li></ol></li></ul><ol><li><p>更新误差协方差，用于下一次计算</p><p>$P_k=(I-K_kH)P_k^-$ </p></li></ol><p>上面的五个方程中， $\Delta t$ 为采样时间， $Q$ 为模型误差， $R$ 为测量误差</p><p>在MATLAB中建立EKF观测器，需要建立全局变量x和P用于保存每一次迭代的值给下一次迭代使用：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x_posteriori</span>  = <span class="title">fcn</span><span class="params">(Ialpha,Ibeta,Ualpha,Ubeta,Ls,Rs,Flux)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> x;</span><br><span class="line"><span class="keyword">global</span> P;</span><br><span class="line"></span><br><span class="line">R=[<span class="number">0.02</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.02</span>];</span><br><span class="line">Q=[<span class="number">0.01</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.01</span>];</span><br><span class="line">Time=<span class="number">0.0001</span>;</span><br><span class="line"></span><br><span class="line">u=[Ualpha;Ubeta];</span><br><span class="line">y=[Ialpha;Ibeta];</span><br><span class="line">H=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">B=[<span class="number">1</span>/Ls,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>/Ls;<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">F=[-Rs/Ls,<span class="number">0</span>,Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls,x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>,-Rs/Ls,-Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls,x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">f=[-Rs*Ialpha/Ls+x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;-Rs*Ibeta/Ls-x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>;x(<span class="number">3</span>,<span class="number">1</span>)];</span><br><span class="line"><span class="comment">% 计算预估值</span></span><br><span class="line">x_prior=x+(f+B*u)*Time;</span><br><span class="line"><span class="comment">% 计算误差协方差</span></span><br><span class="line">A=(<span class="built_in">eye</span>(<span class="number">4</span>)+F*Time);</span><br><span class="line">P_prior=A*P*A&#x27;+Q;</span><br><span class="line"><span class="comment">% 计算卡尔曼增益</span></span><br><span class="line">K=(P_prior*H&#x27;)/(H*P_prior*H&#x27;+R);</span><br><span class="line"><span class="comment">% 修正预估值</span></span><br><span class="line">x_posteriori=x_prior+K*(y-H*x_prior);</span><br><span class="line"><span class="comment">% 更新误差协方差</span></span><br><span class="line">P_posteriori=(<span class="built_in">eye</span>(<span class="number">4</span>)-K*H)*P_prior;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x_posteriori(<span class="number">4</span>,<span class="number">1</span>)&gt;(<span class="number">2</span>*<span class="built_in">pi</span>)</span><br><span class="line">    x_posteriori(<span class="number">4</span>,<span class="number">1</span>)=x_posteriori(<span class="number">4</span>,<span class="number">1</span>)-(<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x=x_posteriori;</span><br><span class="line">P=P_posteriori;</span><br></pre></td></tr></table></figure><p>调整R矩阵和Q矩阵至最优，查看观测器效果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220416201249667.png" alt="image-20220416201249667" style="zoom:50%;"></p><p>蓝色为观测角度，黄色为真实角度。可以看到经过很短时间的迭代，观测器就已经可以很好地预测电机角度，至此完成了EKF无感算法。</p><h2 id="速度闭环"><a href="#速度闭环" class="headerlink" title="速度闭环"></a>速度闭环</h2><p>前文电流闭环精准地控制了电机电流从而控制转矩，但要想精确地控制电机的速度就需要进行速度闭环。速度闭环是在电流闭环的外环，控制Id=0，通过前面有感或无感获取到的速度与速度参考作比较，通过PID控制Iq的值。</p><p>对于速度闭环PID，一班只是用PD控制。 $K_p$ 和 $K_d$ 的理论计算值为：</p><script type="math/tex; mode=display">K_P=\frac{\beta J}{1.5P\psi_f}\\K_I=\beta K_P</script><p>其中 $\beta$ 是速度环的带宽，一般为50rad/s； $J$ 为电机转动惯量，是电机的固有参数； $P$ 是电机的极对数； $\psi_f$ 是电机的磁链。</p><p>由于有观测器的存在，观测器的参数对速度环参数也会有影响，所以以上计算只是理论值，实际参数需要在理论值的基础上通过观察点击运行效果进行调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="https://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="https://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>使用Clion开发Qt</title>
    <link href="https://www.robotsfan.com/posts/113f8d22.html"/>
    <id>https://www.robotsfan.com/posts/113f8d22.html</id>
    <published>2022-09-08T05:00:00.000Z</published>
    <updated>2024-07-17T03:04:32.086Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用Clion开发Qt"><a href="#使用Clion开发Qt" class="headerlink" title="使用Clion开发Qt"></a>使用Clion开发Qt</h1><h2 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h2><p>参照下图勾选</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908111317127.png" alt="image-20220908111317127" style="zoom:50%;"></p><h2 id="配置Clion"><a href="#配置Clion" class="headerlink" title="配置Clion"></a>配置Clion</h2><p>新建Qt项目，并选择Qt CMake路径</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908120325486.png" alt="image-20220908120325486" style="zoom:50%;"></p><p>配置工具链</p><p>新建一个工具链并重命名，选择工具集，选择与下图一样的调试器</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908120845598.png" alt="image-20220908120845598" style="zoom:50%;"></p><p>添加Qt Designer工具，用于打开<code>*.ui</code>文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908121211672.png" alt="image-20220908121211672" style="zoom:50%;"></p><p>添加UIC工具，用于生成<code>ui_qwmainwind.h</code>文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908121628482.png" alt="image-20220908121628482" style="zoom:50%;"></p><p>添加环境变量</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908123829879.png" alt="image-20220908123829879" style="zoom:50%;"></p><p>运行</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124126507.png" alt="image-20220908124126507"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>创建UI类</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124511476.png" alt="image-20220908124511476" style="zoom:50%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124618160.png" alt="image-20220908124618160" style="zoom:50%;"></p><p>此时打开<code>mainwind.cpp</code>看到头文件<code>#include &quot;ui_MainWind.h&quot;</code>报错，这是因为需要使用UIC工具生成这个文件。</p><p>右键使用Qt Designer打开<code>mainwind.ui</code>就可以进行可视化设计</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124824449.png" alt="image-20220908124824449" style="zoom:50%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908125226609.png" alt="image-20220908125226609" style="zoom:50%;"></p><p>右键使用Qt UIC打开<code>mainwind.ui</code>生成代码</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908125126022.png" alt="image-20220908125126022" style="zoom:50%;"></p><p>可以看到已成功生成<code>ui_MainWind.h</code>，且<code>mainwind.cpp</code>中不再报错。</p><p>在<code>main.cpp</code>中添加以下代码进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">MainWindow mainWindow;</span><br><span class="line">mainWindow.<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> QApplication::<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功输出</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908125153526.png" alt="image-20220908125153526" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其他" scheme="https://www.robotsfan.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Qt" scheme="https://www.robotsfan.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>使用CLion开发STM32</title>
    <link href="https://www.robotsfan.com/posts/ea0a6855.html"/>
    <id>https://www.robotsfan.com/posts/ea0a6855.html</id>
    <published>2022-06-15T10:00:00.000Z</published>
    <updated>2024-07-17T03:04:34.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用CLion开发STM32"><a href="#使用CLion开发STM32" class="headerlink" title="使用CLion开发STM32"></a>使用CLion开发STM32</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h3><p>正常安装即可。<a href="https://www.st.com/en/development-tools/stm32cubemx.html">下载链接</a></p><h3 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h3><p>点击下载安装器。<a href="https://osdn.net/projects/mingw/releases/">下载链接</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165444739.png" alt="image-20220615165444739" style="zoom:50%;"></p><p>选择安装</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165549003.png" alt="image-20220615165549003" style="zoom:50%;"></p><p>改变一下路径</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165640045.png" alt="image-20220615165640045" style="zoom:50%;"></p><p>等待下载完成后点击<code>Continue</code>进入下一步，勾选<code>Basic Setup</code>里的全部组件，点击<code>Apply Changes</code>下载。过程会很漫长，请耐心等待。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170342076.png" alt="image-20220615170342076" style="zoom:50%;"></p><p>配置环境变量，在Path里添加<code>MinGW</code>的<code>bin</code>文件夹：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165848575.png" alt="image-20220615165848575" style="zoom:50%;"></p><p>打开命令行，输入<code>gcc -v</code>，出现类似下图信息即为安装成功</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170030477.png" alt="image-20220615170030477" style="zoom:50%;"></p><h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>下载最新版本。<a href="http://gnutoolchains.com/arm-eabi/openocd/">下载链接</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165310091.png" alt="image-20220615165310091" style="zoom:50%;"></p><p>下载后解压，将文件夹改名为<code>OpenOCD</code>并放置到一个目录，这个目录将在下文中Clion中配置。</p><h3 id="arm-none-eabi-gcc"><a href="#arm-none-eabi-gcc" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h3><p>下载zip格式的。<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">下载链接</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170148180.png" alt="image-20220615170148180" style="zoom:50%;"></p><p>下载后解压，放置到一个目录，这个目录将在下文中Clion中配置。</p><p>配置环境变量，在Path里添加所在文件夹的<code>bin</code>文件夹：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170758145.png" alt="image-20220615170758145" style="zoom:50%;"></p><p>打开命令行，输入<code>arm-none-eabi-gcc -v</code>，出现类似下图信息即为安装成功</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170651597.png" alt="image-20220615170651597" style="zoom:50%;"></p><h3 id="Clion"><a href="#Clion" class="headerlink" title="Clion"></a>Clion</h3><p>Clion可以去Jetbrain下载，学生可以免费使用。下载安装好之后配置工具链，添加如下图的路径</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171359479.png" alt="image-20220615171359479" style="zoom:50%;"></p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>新建STM32CubeMX项目</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171646399.png" alt="image-20220615171646399" style="zoom:50%;"></p><p>选择用CubeMX打开</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171831417.png" alt="image-20220615171831417" style="zoom:50%;"></p><p>更换芯片型号</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171943646.png" alt="image-20220615171943646" style="zoom:50%;"></p><p>将项目名改成前文Clion创建的工程名，将IDE改成<code>STM32CubeIDE</code>，然后点击生成代码，弹出是否overwrite选择yes</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615172307277.png" alt="image-20220615172307277" style="zoom:50%;"></p><p>代码生成好之后点击Close，回到Clion，会弹出来这个对话框，这里先选择取消，后面再添加。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615172412994.png" alt="image-20220615172412994" style="zoom:50%;"></p><p>打开设置，确定一下cmake为以下配置：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171523025.png" alt="image-20220615171523025" style="zoom:50%;"></p><p>点击锤子按钮编译，如以上配置无误即可生成<code>hex</code>及<code>bin</code></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615172739473.png" alt="image-20220615172739473" style="zoom:50%;"></p><p>对于一个项目，不可避免地会用到第三方库或者自己创建的<code>.c/.h</code>文件，也就是需要修改<code>CmakeList</code>文件。但这里的<code>CMakelist</code>开头写明了<code>#此文件从模板自动生成! 请勿更改!</code>，其原因为在每一次使用CubeMX生成代码时此文件会被覆盖，用户的代码将不会被保存。所以需要修改模板文件<code>CMakeLists_template.txt</code>。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/CMakeLists_template.png" alt="CMakeLists_template" style="zoom:50%;"></p><p>如上图所示，需要增加头文件及编译文件。对于我们新增的编译文件，可以新增一个<code>MY_SOURCE</code>并在<code>add_executable</code>中添加<code>$&#123;MY_SOURCES&#125;</code>，可以避免修改原模板。</p><p>file里的<code>GLOB_RECURSE</code>意思是对该目录下的所有子文件进行递归添加。而<code>GLOB</code>则不进行递归，只在当前文件夹下查找。可以根据需求选择用哪种。<code>*.*</code>为通配符，意为添加文件夹下的所有文件。</p><h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h2><p>如使用STlink进行烧录，需要添加配置文件。在项目根目录下新建一个<code>stlink.cfg</code>，添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source [find interface/stlink-v2.cfg]</span><br><span class="line">transport select hla_swd</span><br><span class="line">source [find target/stm32f1x.cfg]</span><br><span class="line">adapter speed 10000</span><br></pre></td></tr></table></figure><p>若使用的不是STM32F1或者不是STlink仿真器，可以到OpenOCD安装目录的<code>share\openocd\scripts</code>下寻找对应的配置。芯片在<code>target</code>文件下，仿真器在<code>interface</code>文件夹下。</p><p>然后点击编辑配置</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615174236352.png" alt="image-20220615174236352"></p><p>添加刚刚的配置文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615174323763.png" alt="image-20220615174323763" style="zoom:50%;"></p><p>然后点击三角形烧录固件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615174411604.png" alt="image-20220615174411604"></p><h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><p>调试的时候点击寄存器，没加载svd文件是看不到的，这个文件在keil中可以找到</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220616104531509.png" alt="image-20220616104531509" style="zoom:50%;"></p><p>路径如下：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220616104707730.png" alt="image-20220616104707730" style="zoom:50%;"></p><p>然后全选即可显示。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>实测默认的代码优化会造成许多问题。修改模板文件<code>CMakeLists_template.txt</code>，优化等级均改为<code>-O0</code>：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220616113849054.png" alt="image-20220616113849054" style="zoom:50%;"></p><p>然后在Cubemx中重新生成代码以刷新Cmakelist文件。</p><h2 id="重定向printf"><a href="#重定向printf" class="headerlink" title="重定向printf"></a>重定向printf</h2><p>与在keil5中重定义<code>fputs()</code>函数不一样，在GCC编译器中需要重定义的是<code>__io_putchar(int ch)</code>。</p><p>在main中添加如下代码并引入头文件<code>#include &lt;stdio.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1 , (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后即可使用<code>printf</code>函数。且此段代码在Keil和Clion中均可正常编译运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其他" scheme="https://www.robotsfan.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="STM32" scheme="https://www.robotsfan.com/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>MPC——模型预测控制</title>
    <link href="https://www.robotsfan.com/posts/fe8d7b17.html"/>
    <id>https://www.robotsfan.com/posts/fe8d7b17.html</id>
    <published>2022-06-01T13:00:00.000Z</published>
    <updated>2024-07-17T03:05:00.333Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m1.jpg" alt="m1"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m2.jpg" alt="m2"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m3.jpg" alt="m3"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m4.jpg" alt="m4"></p><p>代码：</p><p><code>MPC_Test.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 清屏</span></span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">% 第一步，定义状态空间矩阵</span></span><br><span class="line"><span class="comment">% 定义状态矩阵 A, n*n 矩阵</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">0.1</span>; <span class="number">-1</span> <span class="number">2</span>];</span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义输入矩阵 B, n*p 矩阵</span></span><br><span class="line">B = [<span class="number">0.2</span> <span class="number">1</span>;<span class="number">0.5</span> <span class="number">2</span>];</span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% 定义Q矩阵，n*n 矩阵</span></span><br><span class="line">Q = [<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 定义F矩阵，n*n 矩阵</span></span><br><span class="line">F = [<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 定义R矩阵，p*p 矩阵</span></span><br><span class="line">R = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0.1</span>];</span><br><span class="line"><span class="comment">% 定义step数量k</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义矩阵 X_K， n*k 矩 阵</span></span><br><span class="line">X_K = <span class="built_in">zeros</span>(n,k_steps);</span><br><span class="line"><span class="comment">% 初始状态变量值， n*1 向量</span></span><br><span class="line">X_K(:,<span class="number">1</span>) = [<span class="number">20</span>;<span class="number">-20</span>];</span><br><span class="line"><span class="comment">% 定义输入矩阵 U_K， p*k 矩阵</span></span><br><span class="line">U_K = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 定义预测区间K</span></span><br><span class="line">N = <span class="number">5</span>;</span><br><span class="line"><span class="comment">% Call MPC_Matrices 函数 求得 E,H矩阵</span></span><br><span class="line">[E,H] = MPC_Matrices(A,B,Q,R,F,N);</span><br><span class="line"><span class="comment">% 计算每一步的状态变量的值</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 求得U_K(:,k)</span></span><br><span class="line">    U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);</span><br><span class="line">    <span class="comment">% 计算第k+1步时状态变量的值</span></span><br><span class="line">    X_K(:,k+<span class="number">1</span>) = (A*X_K(:,k) + B*U_K(:,k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 绘制状态变量和输入的变化</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(X_K,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(X_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>)</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(U_K,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(U_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>MPC_Matrices.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[E,H]</span> = <span class="title">MPC_Matrices</span><span class="params">(A,B,Q,R,F,N)</span></span></span><br><span class="line">    n=<span class="built_in">size</span>(A,<span class="number">1</span>); <span class="comment">% A是n*n矩阵,得到n</span></span><br><span class="line">    p=<span class="built_in">size</span>(B,<span class="number">2</span>); <span class="comment">% B是n*p矩阵,得到p</span></span><br><span class="line">    M=[<span class="built_in">eye</span>(n);<span class="built_in">zeros</span>(N*n,n)]; <span class="comment">% 初始化M矩阵,M矩阵是(N+1)n*n的,</span></span><br><span class="line">                             <span class="comment">% 它上面是n*n个&quot;I&quot;,这一步先把下半部分写成0</span></span><br><span class="line">    C=<span class="built_in">zeros</span>((N+<span class="number">1</span>)*n,N*p); <span class="comment">% 初始化C矩阵,这一步令它有(N+1)n*NP个0</span></span><br><span class="line">    <span class="comment">% 定义M和C</span></span><br><span class="line">    tmp=<span class="built_in">eye</span>(n); <span class="comment">% 定义一个n*n 的 I 矩阵</span></span><br><span class="line">    <span class="comment">% 更新Ｍ和C</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N <span class="comment">% 循环,i从1到N</span></span><br><span class="line">        rows =<span class="built_in">i</span>*n+(<span class="number">1</span>:n); <span class="comment">%定义当前行数,从i*n开始，共n行</span></span><br><span class="line">        C(rows,:)=[tmp*B,C(rows-n, <span class="number">1</span>:<span class="keyword">end</span>-p)]; <span class="comment">%将c矩阵填满</span></span><br><span class="line">        tmp= A*tmp; <span class="comment">%每一次将tmp左乘一次A</span></span><br><span class="line">        M(rows,:)=tmp; <span class="comment">%将M矩阵写满</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 定义Q_bar和R_bar</span></span><br><span class="line">    Q_bar = kron(<span class="built_in">eye</span>(N),Q);</span><br><span class="line">    Q_bar = <span class="built_in">blkdiag</span>(Q_bar,F);</span><br><span class="line">    R_bar = kron(<span class="built_in">eye</span>(N),R);</span><br><span class="line">    <span class="comment">% 计算G,E,H</span></span><br><span class="line">    G=M&#x27;*Q_bar*M; <span class="comment">% G: n*n</span></span><br><span class="line">    E=C&#x27;*Q_bar*M; <span class="comment">% E: NP*n</span></span><br><span class="line">    H=C&#x27;*Q_bar*C+R_bar; <span class="comment">% NP*NP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Prediction.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u_k</span>= <span class="title">Prediction</span><span class="params">(x_k,E,H,N,p)</span></span></span><br><span class="line">    U_k = <span class="built_in">zeros</span>(N*p,<span class="number">1</span>); <span class="comment">% NP x 1</span></span><br><span class="line">    U_k = quadprog(H,E*x_k);</span><br><span class="line">    u_k = U_k(<span class="number">1</span>:p,<span class="number">1</span>); <span class="comment">% 取第一个结果</span></span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/dafaah.png" alt="dafaah" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://www.robotsfan.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.robotsfan.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ROS2——教你写新版Launch文件</title>
    <link href="https://www.robotsfan.com/posts/7a5950c4.html"/>
    <id>https://www.robotsfan.com/posts/7a5950c4.html</id>
    <published>2022-05-04T10:30:00.000Z</published>
    <updated>2023-11-30T14:12:37.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——教你写新版Launch文件"><a href="#ROS2——教你写新版Launch文件" class="headerlink" title="ROS2——教你写新版Launch文件"></a>ROS2——教你写新版Launch文件</h1><h2 id="为什么需要launch"><a href="#为什么需要launch" class="headerlink" title="为什么需要launch"></a>为什么需要launch</h2><p>如需启动一个节点，只需要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run package-name execute-name</span><br></pre></td></tr></table></figure><p>但如果需要启动多个节点，一个一个启动需要开很多终端输入很多条命令，所以可以使用launch文件批量启动。</p><h2 id="如何编写launch文件"><a href="#如何编写launch文件" class="headerlink" title="如何编写launch文件"></a>如何编写launch文件</h2><p>在ROS1中launch文件是一种格式以<code>.launch</code>结尾的xml文档；而在ROS2中推荐使用Python方式编写launch文件，此时的launch文件是一种格式以<code>.launch.py</code>结尾的Python脚本。</p><h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>对于一个基础的启动节点的launch文件，需要引用以下库，然后创建一个名为做<code>generate_launch_description</code>的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_launch_description</span>():</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p><strong>下文中未注明的均在<code>generate_launch_description()</code>函数中进行操作。</strong></p><p>创建<code>LaunchDescription</code>的对象<code>ld</code>（名字任意）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld = LaunchDescription()</span><br></pre></td></tr></table></figure><p>然后创建一个<code>Actions.Node</code>对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example-node = Node(</span><br><span class="line">    package=<span class="string">&#x27;package-name&#x27;</span>, <span class="comment">#节点所在的功能包</span></span><br><span class="line">    namespace=<span class="string">&#x27;package-namespace&#x27;</span>, <span class="comment">#命名空间。如果存在同名节点，这一选项会有用</span></span><br><span class="line">    executable=<span class="string">&#x27;execute-name/script-name.py&#x27;</span>, <span class="comment">#表示要运行的可执行文件名或脚本名字.py</span></span><br><span class="line">    parameters=[&#123;<span class="string">&#x27;parameter-name&#x27;</span>: parameter-value&#125;], <span class="comment">#参数</span></span><br><span class="line">    arguments=[<span class="string">&#x27;-xxx&#x27;</span>, xxx,  <span class="string">&#x27;-xxx&#x27;</span>, xxx ], <span class="comment">#启动参数</span></span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>, <span class="comment">#用于将话题信息打印到屏幕</span></span><br><span class="line">    name=<span class="string">&#x27;node-name&#x27;</span> <span class="comment">#表示启动后的节点名，可以没有</span></span><br><span class="line">    remappings=[ <span class="comment">#重映射</span></span><br><span class="line">        (<span class="string">&#x27;/xxx/xxx-new&#x27;</span>, <span class="string">&#x27;/xxx/xxx-old&#x27;</span>),</span><br><span class="line">]</span><br><span class="line">)</span><br><span class="line">example-node2 = Node(</span><br><span class="line">......</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将上面所有的Node对象加入<code>ld</code>，然后返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ld.add_action(example-node)</span><br><span class="line">ld.add_action(example-node2)</span><br><span class="line"><span class="keyword">return</span> launch_description</span><br></pre></td></tr></table></figure><h3 id="调用shell命令"><a href="#调用shell命令" class="headerlink" title="调用shell命令"></a>调用shell命令</h3><p>需要添加头文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess</span><br></pre></td></tr></table></figure><p>使用<code>ExecuteProcess</code>调用shell命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example_cmd = ExecuteProcess(</span><br><span class="line">    cmd=[<span class="string">&#x27;some-cmd&#x27;</span>, <span class="string">&#x27;some-cmd&#x27;</span>], <span class="comment">#命令，用逗号隔开</span></span><br><span class="line">    additional_env=&#123;<span class="string">&#x27;EXAMPLE_PATH&#x27;</span>: path&#125;, <span class="comment">#可以添加临时的环境变量</span></span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(example_cmd)</span><br></pre></td></tr></table></figure><h3 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h3><p>使用<code>FindPackageShare</code>获取package路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch_ros.substitutions <span class="keyword">import</span> FindPackageShare</span><br><span class="line">......</span><br><span class="line">package-name = ‘example-package’</span><br><span class="line">package-path = FindPackageShare(package = package-name).find(package-name) </span><br></pre></td></tr></table></figure><p>或者使用<code>get_package_share_directory</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ament_index_python.packages <span class="keyword">import</span> get_package_share_directory</span><br><span class="line">......</span><br><span class="line">package-name = ‘example-package’</span><br><span class="line">package-path = get_package_share_directory(package-name),</span><br></pre></td></tr></table></figure><h3 id="连接路径"><a href="#连接路径" class="headerlink" title="连接路径"></a>连接路径</h3><h4 id="使用join"><a href="#使用join" class="headerlink" title="使用join"></a>使用join</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">...</span><br><span class="line"><span class="comment">#文件</span></span><br><span class="line">file-name = <span class="string">&#x27;example-file.xxx&#x27;</span></span><br><span class="line"><span class="comment">#字符串前加`f`表示可以在字符串里面使用用花括号括起来的变量和表达式，如定义好的`file-name`</span></span><br><span class="line">file-path = os.path.join(package-path, <span class="string">f&#x27;example-folder/<span class="subst">&#123;file-name&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment">#或者使用逗号隔开</span></span><br><span class="line">file-path = os.path.join(package-path, <span class="string">&#x27;example-folder&#x27;</span>, file-name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#路径</span></span><br><span class="line"><span class="built_in">dir</span>-path = os.path.join(package-path, <span class="string">&#x27;example-folder/&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="使用替换"><a href="#使用替换" class="headerlink" title="使用替换"></a>使用替换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> PathJoinSubstitution</span><br><span class="line">...</span><br><span class="line">PathJoinSubstitution([</span><br><span class="line">    FindPackageShare(<span class="string">&#x27;example-package&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;example-folder&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;example-file.xxx&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="改变参数"><a href="#改变参数" class="headerlink" title="改变参数"></a>改变参数</h3><p>一般需要用到以下两个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> LaunchConfiguration</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> DeclareLaunchArgument</span><br></pre></td></tr></table></figure><p><code>LaunchConfiguration</code>用于在变量中存储启动参数的值并将它们传递给所需的操作，允许我们在launch文件的任何部分获取启动参数的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example-cfg = LaunchConfiguration(<span class="string">&#x27;arg-name&#x27;</span>, default=<span class="string">&#x27;true&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>DeclareLaunchArgument</code>用于定义可以从上述启动文件或控制台传递的启动参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example-arg = DeclareLaunchArgument(</span><br><span class="line">    <span class="string">&#x27;arg-name&#x27;</span>,</span><br><span class="line">    default_value=<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;some description&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(example-arg)</span><br></pre></td></tr></table></figure><h3 id="启动另一个launch文件"><a href="#启动另一个launch文件" class="headerlink" title="启动另一个launch文件"></a>启动另一个launch文件</h3><p>假设已经存在很多的单独的launch文件用于启动不同的功能，如果需要同时启动这些launch文件，可以使用<code>IncludeLaunchDescription</code>在launch文件中嵌套启动launch文件，这样可以提高复用率。</p><p>需要以下两个头文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> IncludeLaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.launch_description_sources <span class="keyword">import</span> PythonLaunchDescriptionSource</span><br></pre></td></tr></table></figure><p>使用<code>IncludeLaunchDescription</code>嵌套launch文件，其中同样可以使用上文所述的传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">another-launch = IncludeLaunchDescription(</span><br><span class="line">    PythonLaunchDescriptionSource(</span><br><span class="line">    os.path.join(launch_file_dir, <span class="string">&#x27;launch-file-name.launch.py&#x27;</span>)</span><br><span class="line">    ),</span><br><span class="line">    launch_arguments=&#123;<span class="string">&#x27;arg-name&#x27;</span>: example-arg&#125;.items()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(another-launch)</span><br></pre></td></tr></table></figure><h3 id="在另一个launch文件中使用参数"><a href="#在另一个launch文件中使用参数" class="headerlink" title="在另一个launch文件中使用参数"></a>在另一个launch文件中使用参数</h3><p>这是一个困扰了我两天的，比较麻烦的简单问题。我们来看一个实例：这个launch文件有一个字符串格式的路径作为参数，其中的<code>robot_state_publisher</code>需要传入<code>robot_description</code>作为参数，而这个参数需要使用<code>open()</code>，也就是需要那个路径参数。我们自然而然会想到使用<code>LaunchConfiguration</code>，但是当你试图获取<code>urdf_path_cfg</code>的时候会发现这根本不是一个字符串。具体解决方案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> DeclareLaunchArgument</span><br><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> LaunchConfiguration</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> OpaqueFunction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launch_setup</span>(<span class="params">context, *args, **kwargs</span>):</span></span><br><span class="line">    use_sim_time_cfg = LaunchConfiguration(<span class="string">&#x27;use_sim_time&#x27;</span>)</span><br><span class="line">    urdf_path_cfg = LaunchConfiguration(<span class="string">&#x27;urdf_path&#x27;</span>)</span><br><span class="line">    urdf_path = urdf_path_cfg.perform(context)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[92m&#x27;</span> + <span class="string">&quot;robot_state_publisher: Use urdf dir: &quot;</span> + urdf_path + <span class="string">&#x27;\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(urdf_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infp:</span><br><span class="line">        robot_desc = infp.read()</span><br><span class="line"></span><br><span class="line">    robot_state_publisher_node = Node(</span><br><span class="line">        package=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        name=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">        parameters=[&#123;</span><br><span class="line">            <span class="string">&#x27;use_sim_time&#x27;</span>: use_sim_time_cfg,</span><br><span class="line">            <span class="string">&#x27;robot_description&#x27;</span>: robot_desc</span><br><span class="line">        &#125;]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        robot_state_publisher_node,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_launch_description</span>():</span></span><br><span class="line"></span><br><span class="line">    ld = LaunchDescription()</span><br><span class="line"></span><br><span class="line">    use_sim_time_arg = DeclareLaunchArgument(</span><br><span class="line">        <span class="string">&#x27;use_sim_time&#x27;</span>,</span><br><span class="line">        default_value=<span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">        description=<span class="string">&#x27;Use simulation (Gazebo) clock if true&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    urdf_path_arg = DeclareLaunchArgument(</span><br><span class="line">        <span class="string">&#x27;urdf_path&#x27;</span>,</span><br><span class="line">        default_value=<span class="string">&#x27;robot.urdf&#x27;</span>,</span><br><span class="line">        description=<span class="string">&#x27;urdf_path&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ld.add_action(urdf_path_arg)</span><br><span class="line">    ld.add_action(use_sim_time_arg)</span><br><span class="line">    ld.add_action(OpaqueFunction(function=launch_setup))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ld</span><br></pre></td></tr></table></figure><p>这种写法我个人认为极其不优雅，但是确实能解决实际问题。</p><p>强烈建议ROS加入获取参数内容的方法！！！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="ROS2学习" scheme="https://www.robotsfan.com/categories/ROS2%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ROS2" scheme="https://www.robotsfan.com/tags/ROS2/"/>
    
  </entry>
  
  <entry>
    <title>手撕卡尔曼滤波器</title>
    <link href="https://www.robotsfan.com/posts/b4727fbe.html"/>
    <id>https://www.robotsfan.com/posts/b4727fbe.html</id>
    <published>2022-04-14T14:36:00.000Z</published>
    <updated>2022-04-15T12:12:19.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手撕卡尔曼滤波器"><a href="#手撕卡尔曼滤波器" class="headerlink" title="手撕卡尔曼滤波器"></a>手撕卡尔曼滤波器</h1><p>卡尔曼滤波器（Kalman Filter），从字面意思上来看，“Filter滤波器”一词并不能很好地体现其特性。卡尔曼滤波器用一句话来说就是“Optimal Recursive Data-Processing Algorithm”，即为“最优化 递归 数字处理 算法”，它更像是一种观测器，而不是一般意义上的滤波器。卡尔曼滤波器的应用非常广泛，尤其是在导航中。它的广泛应用是因为世界中存在大量的不确定性，当我们描述一个系统时，这个不确定性主要体现在三个方面：</p><ol><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量传感器存在误差</li></ol><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>下面看一个例子，多次用同一把尺子测量同一枚硬币的直径，用 $z_k$ 表示第k次的测量结果。由于种种误差，测量得到：</p><script type="math/tex; mode=display">\begin{aligned}z_1=50.1mm \\z_2=50.4mm \\z_3=50.2mm\end{aligned}</script><p>此时如果要估计真实结果，自然而然地会想到取平均值。用 $\hat{x}_k$ 表示第k次的估计值，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\hat{x}_k &= \frac{1}{k}(z_1+z_2+\cdots+z_k)\\          &= \frac{1}{k}(z_1+z_2+\cdots+z_{k-1}) + \frac{1}{k}(z_k)\\          &= \frac{k-1}{k}\frac{1}{k-1}(z_1+z_2+\cdots+z_{k-1}) + \frac{1}{k}(z_k)\\          &= \frac{k-1}{k}\hat{x}_{k-1} + \frac{1}{k}(z_k)\\          &= \hat{x}_{k-1} + \frac{1}{k}(z_k-\hat{x}_{k-1})\end{aligned}</script><p>上式中，第三行 $\frac{1}{k-1}(z_1+z_2+\cdots+z_{k-1})$ 就是 $k-1$ 次的平均值 $\hat{x}_{k-1}$ </p><p>观察最后一行结论，$k\uparrow, \frac{1}{k-1}\to0,\hat{x}_k\to\hat{x}_{k-1}$ ，也就是说，随着k的增加，此时拥有了大量的数据，对估计的结果就比较有信心了，测量的结果就不是很重要了。相反，如果k比较小， $\frac{1}{k-1}$ 就会比较大，测量结果 $z_k$ 就会起到很大的作用，尤其是测量结果和估计值差距比较大的时候。</p><p>令 $K_k=\frac{1}{k-1}$ ，则此时公式可以表示为：</p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}_{k-1} + K_k(z_k-\hat{x}_{k-1})</script><p>上式表示的含义为：当前的估计值 = 上一次的估计值 + 系数 * ( 当前测量值 - 上一次的估计值 ) ，其中的 $K_k$ 就是卡尔曼增益/因数（Kalman Gain），通过这个公式可以看出，新的估计值 $\hat{x}_k$ 与上一次的估计值 $\hat{x}_{k-1}$ 有关，上一次的又与上上次的有关，这就是一种递归思想（Recursive），这也是卡尔曼滤波器的优势，他不需要追溯很久以前的数据，只需要上一次的就可以。下面来讨论一下这个 $K_k$ ：</p><p>引入两个误差：</p><ol><li>估计误差 $e_{EST}$ （e代表误差error，EST代表估计estimate）</li><li>测量误差 $e_{MEA}$ （e代表误差error，MEA代表测量measurement）</li></ol><p>则 $K_k$ 可以表示为</p><script type="math/tex; mode=display">K_k = \frac{e_{EST_{k-1}}}{e_{EST_{k-1}}+e_{MEA_{k}}}</script><p>这个公式是卡尔曼滤波中的核心公式，具体的推导后文会讲到。下面对这个公式进行讨论。在k时刻，</p><ol><li>当 $e_{EST_{k-1}} \gg e_{MEA_{k}}$ ， $K_k\rightarrow1$ ，此时 $\hat{x}_k = z_k$ ，这说明当第k-1次的估计误差远大于第k次的测量误差时，第k次的估计值很趋近于测量值。（估计的误差大，测量的误差小，更信任测量值）</li><li>当 $e_{EST_{k-1}} \ll e_{MEA_{k}}$ ， $K_k\rightarrow 0$ ，此时 $\hat{x}_k = \hat{x}_{k-1}$ ，这说明当第k-1次的估计误差远小于第k次的测量误差时，第k次的估计值很趋近于测量值。（估计的误差小，测量的误差大，更信任估计值）</li></ol><p>运用以上知识，解决一个实际问题可以分为三步：</p><ol><li>计算卡尔曼增益 $K_k$ ，公式见前文</li><li>计算估算值 $\hat{x}_k$ ，公式见前文</li><li>更新估计误差 $e_{EST_{k}} = (1-K_k)e_{EST_{k-1}}$ ，此公式推导见后文。</li></ol><p>再看前文测量硬币直径的例子，实际长度 $x=50mm$ ，对于第一次测量：</p><script type="math/tex; mode=display">\begin{aligned}\hat{x}_0=40mm \\e_{EST_{0}}=5mm \\z_1=51mm\\e_{MEA_{k}}=3mm\end{aligned}</script><p>估计值是是随便估计的一个值；估计误差随便给一个数；测量值是实际测量得到的；由于测量工具不变，测量误差是一个恒定值。接下来进行递归：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220414223222370.png" alt="image-20220414223222370"></p><p>蓝色是测量值 $z_k$ ，红色为估计值 $\hat{x}_k$ ，可以看到经过反复迭代，估计值越来越接近实际值。这就是卡尔曼滤波器的递归思想。</p><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h3><p>下面举例说明数据融合（Data Fusion）</p><p>分别用两个称称一个东西，得到两个结果，分别为</p><script type="math/tex; mode=display">\begin{aligned}z_1=30mm \\z_2=32mm \end{aligned}</script><p>两个称都有误差，两个称的标准差（Standard Deviation）分别为：</p><script type="math/tex; mode=display">\begin{aligned}\sigma_1=2g \\\sigma_2=4g \end{aligned}</script><p>他们均符合正态分布/高斯分布（Natural/Gaussin Distribution）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415103427679.png" alt="image-20220415103427679"></p><p>如果用这两个结果去估计真实值 $\hat{z}=?$ ，可以用到上一节的思想，则</p><script type="math/tex; mode=display">\begin{array}{c}\hat{z} = z_{1} + K(z_2-z_{1}),k\in[0,1] \\k=0,\hat{z}=z_1\\ k=1,\hat{z}=z_2\end{array}</script><p>求k使得 $\sigma_{\hat{z}}$ 最小，也就是使得方差 $Var(\hat{z})$ 最小</p><script type="math/tex; mode=display">\begin{aligned}\sigma_{\hat{z}}^2&=Var(\hat{z})\\                &=Var(z_1 + K(z_2-z_1))\\                &=Var(z_1 -Kz_1+ Kz_2)\\                &=Var((1-K)z_1+ Kz_2)\\                &=Var((1-K)z_1)+Var(Kz_2)\\                &=(1-K)^2Var(z_1)+K^2Var(z_2)\\                &=(1-K)^2\sigma_1^2+K^2\sigma_2^2\\\end{aligned}</script><p>可以看到，第四行中 $(1-K)z_1$ 和 $Kz_2$ 是互相独立的，因为两个称的结果不会互相影响，所以由于方差的性质可以写成两个独立的方差。要求这个式子的最小值，就要对K求导并令导数等于0。可以解出K：</p><script type="math/tex; mode=display">\begin{array}{c}\frac{d\sigma_{\hat{z}}^2}{dK}=0\\-2(1-K)\sigma_1^2+2K\sigma_2^2=0\\K=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}=\frac{2^2}{2^2+4^2}=0.2\end{array}</script><p>将K带入上面的式子，得到 $\hat{z}=30.4$ 。此时为最优解。计算此时的标准差 $\sigma_{\hat{z}}=1.79$ ，绘出正态分布图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415105843056.png" alt="image-20220415105843056"></p><p>得到比两个图形更高更瘦的图形，这个过程就叫数据融合。</p><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><p>协方差矩阵（Covarince Matrix）是把方差和协方差在一个矩阵中表示出来，体现了变量间的联动关系。下面举例说明：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415121131214.png" alt="image-20220415121131214"></p><p>令身高为x，体重为y，年龄为z，分别计算平均值，方差和协方差（拿x举例）：</p><script type="math/tex; mode=display">\begin{aligned}\sigma_x^2&=\frac{1}{3}((179-180.3)^2\\&\qquad+(187-180.3)^2\\&\qquad+(175-180.3)^2)\\&=24.89\\\sigma_x\sigma_y&=\frac{1}{3}((179-180.3)(74-75)\\&\qquad+(187-180.3)(80-75)\\&\qquad+(175-180.3)(71-75))\\&=18.7=\sigma_y\sigma_x\end{aligned}</script><p>观察协方差的每一项，如果两个括号内都为负数，相乘为正数；两个括号内都为正数，相乘仍为正数；但一正一负相乘得到负数。所以最后加在一起的结果如果是正数，说明这两个变量的变化方向是一样的；如果是负数，说明这两个变量的变化方向是相反的。</p><p>协方差矩阵表示形式为：</p><script type="math/tex; mode=display">P = \begin{bmatrix}    \sigma_x^2 & \sigma_x\sigma_y & \sigma_x\sigma_z \\    \sigma_y\sigma_x & \sigma_y^2 & \sigma_y\sigma_z \\    \sigma_z\sigma_x & \sigma_z\sigma_y & \sigma_z^2  \end{bmatrix}</script><p>如果需要编程实现，可以通过以下方法求得P（其中a为过渡矩阵）</p><script type="math/tex; mode=display">\begin{aligned}a & = \begin{bmatrix}    x_1 & y_1 & z_1 \\    x_2 & y_2 & z_2 \\    x_3 & y_3 & z_3  \end{bmatrix}-\frac{1}{3}\begin{bmatrix}    1 & 1 & 1 \\    1 & 1 & 1 \\    1 & 1 & 1  \end{bmatrix}\begin{bmatrix}    x_1 & y_1 & z_1 \\    x_2 & y_2 & z_2 \\    x_3 & y_3 & z_3  \end{bmatrix}\\P & = \frac{1}{3}a^Ta\end{aligned}</script><p>多取一些数据，得到协方差矩阵，可以利用协方差矩阵分析各个数据之间的关系；</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415113508938.png" alt></p><p>从协方差矩阵中可以看到，对角线上的数为方差，这些数据比较大，说明了这些变量之间跨度比较大。剩下的数据为协方差，体重和身高的协方差比较大，说明他们是正相关的，身高增加体重也增加；而年龄和其余两者的协方差比较小，说明他们之间的相关性比较小。</p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><p>状态空间表达（State Space Representation），现代控制理论就是以状态空间方程为基础的。以弹簧振动阻尼系统为例：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415113931219.png" alt="image-20220415113931219"></p><p>动态方程表达式为：</p><script type="math/tex; mode=display">m\ddot{x}+B\dot{x}+kx=F</script><p>将F定义为u，也就是系统的输入（Input）。将其转化成状态空间表达形式，定义两个状态（State）变量 $x_1=x$ ， $x_2=\dot{x}$ ，则</p><script type="math/tex; mode=display">\begin{aligned}\dot{x_1}&=x_2\\\dot{x_2}&=\ddot{x}\\         &=\frac{1}{m}u-\frac{B}{m}\dot{x}-\frac{k}{m}x\\         &=\frac{1}{m}u-\frac{B}{m}x_2-\frac{k}{m}x_1\end{aligned}</script><p>这样就用两个一阶微分方程表达出来了。定义两个测量（Meansurement）变量，位置 $z_1=x=x_1$ ，速度 $z_2=\dot{x}=x_2$ </p><p>将上面的式子改写成矩阵形式：</p><script type="math/tex; mode=display">\begin{aligned}\begin{bmatrix}    \dot{x_1} \\    \dot{x_2} \end{bmatrix} & = \begin{bmatrix}    0            & 1 \\  -\frac{k}{m} & -\frac{B}{m}\end{bmatrix}\begin{bmatrix}    x_1 \\    x_2 \end{bmatrix}+\begin{bmatrix}    0 \\    \frac{1}{m} \end{bmatrix}u\\\begin{bmatrix}    z_1 \\    z_2 \end{bmatrix} & = \begin{bmatrix}    1 & 0 \\  0 & 1\end{bmatrix}\begin{bmatrix}    x_1 \\    x_2 \end{bmatrix}\end{aligned}</script><p>归纳出状态空间的表达形式：</p><script type="math/tex; mode=display">\begin{array}{l}\dot{x}(t)=Ax(t)+Bu(t)\\z(t)=Hx(t)\end{array}</script><p>这是一种连续的表达形式， $\dot{x}(t)$ 为x对时间的导数，体现了x随时间的变化。</p><p>如果写成离散形式(本节不深入讲解离散型，只做了解)，其中下标 $k-1,k,k+1$ 里面的1代表一个时间单位，即为采样时间（Sample Time），这种形式体现了上一步到这一步的一种变化：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=Ax_{k-1}+Bu_{k-1}\\z_k=Hx_k\end{array}</script><p>如果增加一些开头提到的不确定性，其中 $w_{k-1}$ 为过程噪音（Process Noise）， $v_k$ 为测量噪音（Meansurement Noise）：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_k=Hx_k+v_k\end{array}</script><p>也就是说当估计结果 $x_k$ 不准确，测量结果 $z_k$ 也不准确的情况下，如何估计一个精确的 $\hat{x}_k$ ？这就是卡尔曼滤波器所要解决的问题。</p><h2 id="卡尔曼增益数学推导"><a href="#卡尔曼增益数学推导" class="headerlink" title="卡尔曼增益数学推导"></a>卡尔曼增益数学推导</h2><p>在上文的状态空间方程中， $x_k$ 为状态变量，A为状态矩阵，B为控制矩阵， $u_k$ 为控制， $w_{k-1}$ 为过程噪音， $v_k$ 为测量噪音，其中噪声是不可测的，是系统不确定性的表现。但过程噪声可以假设其符合正态分布 $P(w)\sim N(0,Q)$ ，其中0为期望，Q为协方差矩阵：</p><script type="math/tex; mode=display">\begin{aligned}Q&=E(ww^T)\\ &=E\left(         \begin{bmatrix}            w_1 \\            w_2          \end{bmatrix}         \begin{bmatrix}            w_1 & w_2           \end{bmatrix}     \right)\\ &=E\left(         \begin{bmatrix}            w_1^2  & w_1w_2\\            w_2w_1 & w_2^2         \end{bmatrix}     \right)\\ &=     \begin{bmatrix}       E(w_1^2)  & E(w_1w_2)\\       E(w_2w_1) & E(w_2^2)     \end{bmatrix}\\ &=     \begin{bmatrix}        \sigma_{w_1}^2 & \sigma_{w_1}\sigma_{w_2} \\        \sigma_{w_2}\sigma_{w_1} & \sigma_{w_2}^2     \end{bmatrix}\end{aligned}</script><p>通过Q这个协方差矩阵可以表示出过程噪声的方差，亦可以表示出过程噪声之间的关系。</p><p>对于测量噪声也同样认为符合正态分布 $P(v)\sim N(0,R)$ ， $R=E(vv^T)$ 同样为协方差矩阵，形同Q。</p><p>但建模的时候噪音是不知道的，所以我们只能测得除掉噪声其余的项，表示为 $\hat{x}_k^-$ ，这是一个估计值所以要加一个hat。此时我们没有做任何处理，只是根据上面的式子去掉噪声得来，所以在上面加一个负号，代表先验估计。</p><script type="math/tex; mode=display">\begin{array}{l}\hat{x}_k^-=A\hat{x}_{k-1}+Bu_{k-1}\\z_k=Hx_k \to \hat{x}_{k_{mea}}=H^{-1}z_k\end{array}</script><p>上式中第一行 $\hat{x}_k^-$ 为算出来的结果，第二行 $\hat{x}_{k_{mea}}$ 为测出来的结果，但他们都不具备测量噪声这一项，他们都是不太准确的。这时可以运用卡尔曼滤波器通过两个不太准确的结果得到一个准确的结果。</p><p>回忆之前数据融合的概念，对于最终的估计值， $\hat{x}_k$ （后验估计） 可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}\hat{x}_k=\hat{x}_k^- + G(H^{-1}z_k-\hat{x}_k^-),G\in[0,1]\\\end{array}</script><ul><li>当 $G=0$ ， $\hat{x}_k=\hat{x}_k^-$ ，此时更相信计算结果</li><li>当 $G=1$ ， $\hat{x}_k=H^{-1}z_k$ ，此时更相信测量结果</li></ul><p>在许多教材中会令 $G=K_kH$ ，卡尔曼滤波器可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-),K_k\in[0,H^{-1}]\\\end{array}</script><ul><li><p>当 $K_k=0$ ， $\hat{x}_k=\hat{x}_k^-$ ，此时更相信计算结果</p></li><li><p>当 $K_k=H^{-1}$ ， $\hat{x}_k=H^{-1}z_k$ ，此时更相信测量结果</p></li></ul><p>接下来的目标就是<strong>寻找 $K_k$ ，使得误差最小</strong>，也就是说使得估计值 $\hat{x}_k$ 趋近于实际值 $x_k$ 。很明显， $K_k$ 的取值与<strong>计算误差</strong>和<strong>测量误差</strong>息息相关，当测量误差特别大时会更相信计算出来的结果，当计算误差特别大时会更相信测量出来的结果。</p><p>令误差 $e_k=x_k-\hat{x}_k$ ，其同样符合正态分布 $P(e_k)\sim N(0,P)$ </p><script type="math/tex; mode=display">\begin{aligned}P=E(ee^T)=     \begin{bmatrix}        \sigma_{e_1}^2 & \sigma_{e_1}\sigma_{e_2} \\        \sigma_{e_2}\sigma_{e_1} & \sigma_{e_2}^2     \end{bmatrix}\end{aligned}</script><p>如果新估计出的 $x_k$ 距离实际值越小，说明误差的方差越小，说明越接近期望值0。而方差之和为P的迹 $tr(P)=\sigma_{e_1}^2+\sigma_{e_2}^2$ ，所以要想让方差最小，接下来的目标就变成了选取合适的 $K_k$ ，使得协方差<strong>矩阵P的迹最小</strong></p><script type="math/tex; mode=display">\begin{aligned}P&=E\left(ee^T\right)\\ &=E\left( \left(x_k-\hat{x}_k\right)\left(x_k-\hat{x}_k\right)^T \right)\end{aligned}</script><p>下面求 $x_k-\hat{x}_k$ ，其中的 $z_k$ 是真实测量的结果，所以 $z_k=Hx_k+v_k$ 。因为 $e_k=x_k-\hat{x}_k$ ，所以可以定义先验误差 $e_k^-=x_k-\hat{x}_k^-$ </p><script type="math/tex; mode=display">\begin{aligned}x_k-\hat{x}_k&=x_k-(\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-))\\&=(I-K_kH)(x_k-\hat{x}_k^-)-K_kv_k \\&=(I-K_kH)e_k^--K_kv_k\end{aligned}</script><p>前文提到， $e_k^-$ 和 $e_k^-$ 的方差都是0，且令先验误差的协方差矩阵 $P_k^-=E(e_k^-{e_k^-}^T)$ 。此时第k步的 $P_k$ 可以整理为</p><script type="math/tex; mode=display">\begin{aligned}P_k&=E\left( \left(x_k-\hat{x}_k\right)\left(x_k-\hat{x}_k\right)^T \right)\\ &=E\left( \left(\left(I-K_kH\right)e_k^--K_kv_k\right)\left(\left(I-K_kH\right)e_k^--K_kv_k\right)^T \right)\\ &=P_k^--K_kHP_k^--(K_kHP_k^-)^T+K_kHP_k^-H^TK_k^T+K_kRK_k^T\end{aligned}</script><p>此时可以计算 $P_k$ 的迹</p><script type="math/tex; mode=display">\begin{aligned}tr(P_k)&=tr(P_k^-)-2tr(K_kHP_k^-)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kRK_k^T)\end{aligned}</script><p>寻找k使得 $tr(P_k)$ 有最小值，对k求导并寻找极值点（求导法则略）</p><script type="math/tex; mode=display">\begin{aligned}\frac{dtr(P_k)}{dk}=0-2(HP_k^-)^T+2K_kHP_k^-H^T+2K_kR=0\\\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}\\\end{aligned}</script><p>至此，我们推出的 $K_k$ 就是卡尔曼增益。这也是卡尔曼滤波器中最核心的公式。</p><p>其中的R是测量噪声的协方差矩阵，R的大小代表了测量噪声方差的大小，也就是 测量噪声的大小。分析 $K_k$ ：</p><ul><li>当R很大， $K_k\to0$ ， $\hat{x}_k=\hat{x}_k^-$ ，此时更相信计算结果</li><li>当R很小， $K_k=\frac{P_k^-H^T}{HP_k^-H^T}=H^{-1},\hat{x}_k=H^{-1}z_k$ ，此时更相信测量结果</li></ul><h2 id="误差协方差矩阵数学推导"><a href="#误差协方差矩阵数学推导" class="headerlink" title="误差协方差矩阵数学推导"></a>误差协方差矩阵数学推导</h2><p>现在来推导卡尔曼增益 $K_k$ 中的先验误差的协方差矩阵 $P_k^-$ 。</p><p>根据前文的结论，我们可以得到真实值 $x_k$ ，先验估计 $\hat{x}_k^-$ ，后验估计 $\hat{x}_k$ ，卡尔曼增益 $K_k$ </p><script type="math/tex; mode=display">\begin{aligned}x_k & = Ax_{k-1}+Bu_{k-1}+w_{k-1}\\\hat{x}_k^- & = A\hat{x}_{k-1}+Bu_{k-1}\\\hat{x}_k & = \hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)\\K_k & = \frac{P_k^-H^T}{HP_k^-H^T+R}\end{aligned}</script><p>根据 $P_k^-$ 的定义， $P_k^-=E(e_k^-{e_k^-}^T)$ ，其中误差为真实值减估计值，</p><script type="math/tex; mode=display">\begin{aligned}e_k^-&=x_k-\hat{x}_k^-\\     &=Ax_{k-1}+Bu_{k-1}+w_{k-1}-A\hat{x}_{k-1}-Bu_{k-1}\\     &=A(x_{k-1}-\hat{x}_{k-1}^-)+w_{k-1}\\     &=Ae_{k-1}+w_{k-1}\end{aligned}</script><p>则 $P_k^-$ 可以整理为：</p><script type="math/tex; mode=display">\begin{aligned}P_k^-&=E(e_k^-{e_k^-}^T)\\     &=E\left( (Ae_{k-1}+w_{k-1})(Ae_{k-1}+w_{k-1})^T \right)\\     &=AE(e_{k-1}^-{e_{k-1}^-}^T)A^T+E(w_{k-1}^-{w_{k-1}^-}^T)\\     &=AP_{k-1}A^T+Q\end{aligned}</script><p>根据上式就可以利用卡尔曼滤波器估计状态变量的值了。分为以下步骤</p><ul><li><p>预测</p><ol><li><p>先验估计</p><p> $\hat{x}_k^-=A\hat{x}_{k-1}+Bu_{k-1}$</p></li><li><p>先验误差协方差矩阵</p><p> $P_k^-=AP_{k-1}A^T+Q$</p></li></ol></li><li><p>校正</p><ol><li><p>卡尔曼增益</p><p> $K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}$</p></li><li><p>后验估计</p><p> $\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)$</p></li></ol></li></ul><p>根据以上四步就可以得到最优估计值，也就是后验估计值 $\hat{x}_k$ 。</p><p>先验误差协方差矩阵 $P_k^-$ 中包含上一次的 $P_{k-1}^-$ 项，每次矫正厚需要更新先验误差协方差矩阵。将卡尔曼增益带入可以求得：</p><script type="math/tex; mode=display">\begin{aligned}P_k&=P_k^--K_kHP_k^--(K_kHP_k^-)^T+K_kHP_k^-H^TK_k^T+K_kRK_k^T\\   &=(I-K_kH)P_k^-\end{aligned}</script><p>所以第五步为</p><ol><li><p>更新先验误差协方差</p><p>$P_k=(I-K_kH)P_k^-$ </p></li></ol><p>以上就是完整的卡尔曼滤波器的五个公式。</p><p>可以看到，每次预测都会用到上一次的结果，所以在最开始要赋予初值 $\hat{x}_0$ 和 $P_0$ ，初值的选取会在下文提及。</p><h2 id="扩展卡尔曼滤波"><a href="#扩展卡尔曼滤波" class="headerlink" title="扩展卡尔曼滤波"></a>扩展卡尔曼滤波</h2><p>前文讲到，卡尔曼滤波器在线性系统里可以得到最优估计值。对于非线性系统，可以将其线性化再进行处理，这种滤波器叫做扩展卡尔曼滤波器（Extend Kalman Filter），简称EKF。</p><p>线性系统可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_k=Hx_k+v_k\end{array}</script><p>而非线性系统，无法用线性的状态空间方程表达，而是可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=f(x_{k-1},u_{k-1},w_{k-1})\\z_k=h(x_k,v_k)\end{array}</script><p>其中f为过程方程，h为测量方程，这是两个非线性的表达形式。注意无论是线性还是非线性，误差v和w都是符合正态分布的。但正态分布的随机变量通过非线性系统以后就不再是正态分布的了。所以如果还想对非线性系统进行卡尔曼滤波，需要对其线性化（Linearization），用泰勒级数展开，不赘述过程只给出结论：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=f(x_0)+\frac{\partial f}{\partial x}(x-x_0)\end{aligned}</script><p>如果需要线性化一个系统，需要找到一个点（Operating Point），在这个点附近进行线性化。对于非线性系统来说最好的线性化的点就是它的真实点，但由于系统有误差，无法知道真实值，所以无法在真实点进行线性化，所以过程方程 $f(x_k)$ 只能<strong>在 $\hat{x}_{k-1}$ 附近</strong>，也就是k-1时刻（上一次）的后验估计附近进行线性化。</p><p>由于不知道误差 $w_{k-1}$ 是多少，所以将其假设为0，定义 $f(\hat{x}_{k-1},u_{k-1},0)=\tilde x_k$ ，可以得到</p><script type="math/tex; mode=display">\begin{aligned}x_k & = f(\hat{x}_{k-1},u_{k-1},0)+A_k(x_{k-1}-\hat{x}_{k-1})+W_kw_{k-1}\\A_k &= \frac{\partial f}{\partial x}|_{\hat{x}_{k-1},u_{k-1}}\qquad W_k  = \frac{\partial f}{\partial w}|_{\hat{x}_{k-1},u_{k-1}}\end{aligned}</script><p>例：</p><script type="math/tex; mode=display">\begin{aligned}x_1&=x_1+sinx_2=f_1\\x_2&=x_1^2=f_2\\A_k&=\frac{\partial f}{\partial x}|_{\hat{x_1}_{k-1},\hat{x_2}_{k-1}}\\&=\begin{bmatrix}    \frac{\partial f_1}{\partial x_1} & \frac{\partial f_1}{\partial x_2} \\  \frac{\partial f_2}{\partial x_1} & \frac{\partial f_2}{\partial x_2}\end{bmatrix}|_{\hat{x_1}_{k-1},\hat{x_2}_{k-1}}\\&=\begin{bmatrix}    1 & cosx_2 \\  2x_1 & 0\end{bmatrix}|_{\hat{x_1}_{k-1},\hat{x_2}_{k-1}}\\&=\begin{bmatrix}    1 & cos\hat{x_2}_{k-1} \\  2\hat{x_1}_{k-1} & 0\end{bmatrix}\end{aligned}</script><p>可以看出，A矩阵随着K的变化而变化，所以每次要重新计算A矩阵。</p><p>同理对于测量方程， $z_k$ <strong>在 $\tilde x_k$ 附近</strong>进行线性化。由于不知道误差 $v_k$ ，所以将其假设为0，定义 $h(\hat{x}_k,0)=\tilde z_k$ </p><script type="math/tex; mode=display">\begin{aligned}z_k&=h(\tilde x,0)+H_k(x_k-\tilde{x}_k)+V_kv_k\\H_k&=\frac{\partial h}{\partial x}|_{\hat{x}_k}\qquad V_k=\frac{\partial h}{\partial v}|_{\hat{x}_k}\\\end{aligned}</script><p>这样就把非线性系统线性化了：</p><script type="math/tex; mode=display">\begin{aligned}x_k&=\tilde x_k+A_k(x_{k-1}-\hat{x}_{k-1})+W_kw_{k-1}\\z_k&=\tilde z_k+H(x_k-\tilde{x}_k)+Vv_k\end{aligned}</script><p>其中的 $W_kw_{k-1}$ 和 $Vv_k$ 也都是正态分布（ $WQW^T$ 相当于矩阵中W的平方）：</p><script type="math/tex; mode=display">\begin{aligned}P(w) &\sim N(0,R)\\P(Ww_{k-1}) &\sim N(0,WQW^T)\\P(Vv_k) &\sim N(0,VRV^T)\end{aligned}</script><p>将卡尔曼滤波器的线性化部分替换成对应非线性的部分，就可以得到扩展卡尔曼滤波器的五个公式：</p><ul><li><p>预测</p><ol><li><p>先验估计</p><p> $\hat{x}_k^-=f(\hat{x}_{k-1},u_{k-1},0)$</p></li><li><p>先验误差协方差矩阵</p><p> $P_k^-=AP_{k-1}A^T+WQW^T$</p></li></ol></li><li><p>校正</p><ol><li><p>卡尔曼增益</p><p> $K_k=\frac{P_k^-H^T}{HP_k^-H^T+VRV^T}$</p></li><li><p>后验估计</p><p> $\hat{x}_k=\hat{x}_k^- + K_k(z_k-h(\hat{x}_k,0))$ </p></li></ol></li></ul><ol><li><p>更新先验误差协方差</p><p> $P_k=(I-K_kH)P_k^-$ </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="https://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="https://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>FOC控制原理——Clark变换和Park变换</title>
    <link href="https://www.robotsfan.com/posts/9532f19e.html"/>
    <id>https://www.robotsfan.com/posts/9532f19e.html</id>
    <published>2022-03-23T08:25:00.000Z</published>
    <updated>2022-03-23T08:32:26.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC控制原理——Clark变换和Park变换"><a href="#FOC控制原理——Clark变换和Park变换" class="headerlink" title="FOC控制原理——Clark变换和Park变换"></a>FOC控制原理——Clark变换和Park变换</h1><h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153620081.png" alt="image-20220323153620081"></p><p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    \begin{aligned}    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c    \end{aligned} \\    \begin{aligned}    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c    \end{aligned}\end{array}\right.</script><p>可以将其整理成矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{ccc}    1 & -\frac{1}{2}       & -\frac{1}{2} \\    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]</script><p>由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故也可整理为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=\frac{3}{2}I_a \\    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b\end{array}\right.</script><p>反Clark变换则将三向信号转换为两向信号，根据上式可以解得</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]=\left[\begin{array}{ccc}    \frac{2}{3}  & 0       \\    -\frac{1}{3} & \frac{1}{\sqrt{3}} \\    -\frac{1}{3} & -\frac{1}{\sqrt{3}}\end{array}\right]\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>也可通过计算Clark变换常数矩阵的伪逆来确定反Clark变换的常数矩阵（使用MATLAB中的 <code>pinv()</code>函数）</p><h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323152939436.png" alt="image-20220323152939436"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323150553068.png" alt="image-20220323150553068"></p><p>通过图像可以看到，输入信号的幅值为1，经过Clark变换后的图像幅值变为1.5，即变为 $\frac{3}{2}$ 倍；进行反Clark变换后幅值又变为1.5，即变为 $\frac{2}{3}$ 倍。所以要进行等幅值变换。修改仿真：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153007076.png" alt="image-20220323153007076"></p><p>可以看到，经过等幅值变换后，幅值统一为1。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323151818659.png" alt="image-20220323151818659"></p><h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Park变换可以将正弦变量线性化</p><p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/v2-d15d057327992a5c50016aea5bb7201b_1440w.jpg" alt="img"></p><p>也就是说 $d-q$ 坐标系始终跟着转子旋转。</p><p>则可以写出</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \\I_{q}=-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)\end{array}\right.</script><p>整理成矩阵形式</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & \sin \theta \\    -\sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>所以如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。</p><p>同理，可以求得反Park变换</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & -\sin \theta \\     \sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]</script><h3 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>在Clark变换和等幅值变换的基础上添加Park变换</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160805870.png" alt="image-20220323160805870"></p><p>关注Park部分</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160942614.png" alt="image-20220323160942614"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="https://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="https://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>机器人动力学——拉格朗日法</title>
    <link href="https://www.robotsfan.com/posts/c0ff5b54.html"/>
    <id>https://www.robotsfan.com/posts/c0ff5b54.html</id>
    <published>2022-03-15T12:30:00.000Z</published>
    <updated>2024-07-17T03:05:31.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器人动力学——拉格朗日法"><a href="#机器人动力学——拉格朗日法" class="headerlink" title="机器人动力学——拉格朗日法"></a>机器人动力学——拉格朗日法</h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p>机器人动力学所用到的运动学方程是一组具有下列形式的二阶微分方程组</p><script type="math/tex; mode=display">\tau = M ( \theta ) \ddot { \theta } + h ( \theta , \dot { \theta } ) \label{1}</script><p>式中，对于所有关节均为驱动关节的开式运动链，广义坐标 $\theta \in \mathbb{R}^{n}$ 表示关节变量；广义力 $\tau \in \mathbb{R}^{n}$ 表示力或力矩，如果 $\theta_i$ 是旋转关节，则 $\tau_i$ 对应力矩；如果 $\theta_i$ 为平动关节，则 $\tau_i$ 对应力； $M ( \theta )\in \mathbb{R}^{n\times{n}}$ 是一个对称且正定的质量矩阵；$h ( \theta , \dot { \theta })\in \mathbb{R}^{n}$ 是将向心力、科里奥利力、重力和摩擦力等集合在一起的力向量，该向量取决于 $\theta$ 和 $ \dot { \theta}$ 这两个变量。</p><p>运动学同样区分正运动学和逆运动学，正向动力学问题是在给定状态变量 $( \theta , \dot { \theta })$ 以及关节力和力矩的前提下确定机器人的加速度 $\ddot { \theta }$ ，即</p><script type="math/tex; mode=display">\ddot { \theta } = M ^ { - 1 } ( \theta ) ( \tau - h ( \theta , \dot { \theta } ) )</script><p>逆动力学问题则是找到对应于机器人状态和期望加速度的关节力和力矩$\tau$，即式 $\eqref{1}$ </p><p>机器人的动力学方程通常可以通过<strong>牛顿-欧拉公式</strong>或<strong>拉格朗日动力学公式</strong>得到。对于简单结构的机器人，如3自由度或自由度更少的情形，拉格朗日形式不仅在概念上十分优雅，并且在实际中非常有效。但对于自由度数目更多的机器人来讲，其计算可能会很快变得烦琐。</p><p>下文将讨论拉格朗日动力学公式</p><h2 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h2><p>力学系统的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 定义为整个系统的动能 ${ \cal K } ( q , \dot { q } )$ 减去势能 ${ \cal P } ( q )$ ，式中的—组独立坐标 $q \in \mathbb{R}^{n}$ 用来描述系统的位形（这个坐标 $q$ 被称为广义坐标）</p><script type="math/tex; mode=display">{ \cal L } ( q , \dot { q } ) = { \cal K } ( q , \dot { q } ) - { \cal P } ( q )</script><p>运动方程现在可以用拉格朗日函数表示如下（推导过程略，详见动力学教材）</p><script type="math/tex; mode=display">f = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { q } } - \frac { \partial { \cal L } } { \partial q }</script><p>这个方程也称为<strong>含外力的欧拉-拉格朗日方程</strong>（在标准形式的欧拉-拉格朗日方程中，外力 $f$ 等于零）</p><h2 id="2R-开链机器人举例"><a href="#2R-开链机器人举例" class="headerlink" title="$2R$ 开链机器人举例"></a>$2R$ 开链机器人举例</h2><p>下面以在重力作用下的—个 $2R$ 开链机器人为例推导动力学方程，如下图所示</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220315193736585.png" alt="image-20220315193736585" style="zoom:80%;"></p><p>将关节坐标 $\theta =(\theta_{1},\theta_{2})$ 选做广义坐标，广义力 $\tau =(\tau_{1},\tau_{2})$ 则对应于关节力矩（因为 $\tau^T\dot{\theta}$ 对应于功率）。本例中的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 可以写成如下分量形式:</p><script type="math/tex; mode=display">\mathcal{L}(\theta, \dot{\theta})=\sum_{i=1}^{2}\left(\mathcal{K}_{i}-\mathcal{P}_{i}\right)</script><p>则欧拉-拉格朗日方程可以写成如下分量形式（ $\tau$ 为关节力和力矩向量）:</p><script type="math/tex; mode=display">\tau_i = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { \theta_i } } - \frac { \partial { \cal L } } { \partial \theta_i } \qquad i = 1,2  \label{6}</script><p>下面我们需要计算两杆的动能和势能（认为两杆各自的质量 $\mathrm { m }1$ 和 $\mathrm { m }2$ 均集中于各杆末端）</p><p>连杆1质心的位置和速度:</p><script type="math/tex; mode=display">\begin{array}{l}{\left[\begin{array}{l}x_{1} \\y_{1}\end{array}\right]=\left[\begin{array}{c}L_{1} \cos \theta_{1} \\L_{1} \sin \theta_{1}\end{array}\right]} \\{\left[\begin{array}{c}\dot{x}_{1} \\\dot{y}_{1}\end{array}\right]=\left[\begin{array}{r}-L_{1} \sin \theta_{1} \\L_{1} \cos \theta_{1}\end{array}\right] \dot{\theta}_{1}}\end{array}</script><p>连杆2质心的位置和速度:</p><script type="math/tex; mode=display">\begin{array}{l}{\left[\begin{array}{l}x_{2} \\y_{2}\end{array}\right]=\left[\begin{array}{c}L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\end{array}\right]} \\{\left[\begin{array}{l}\dot{x}_{2} \\\dot{y}_{2}\end{array}\right]=\left[\begin{array}{rr}-L_{1} \sin \theta_{1}-L_{2} \sin \left(\theta_{1}+\theta_{2}\right) & -L_{2} \sin \left(\theta_{1}+\theta_{2}\right) \\L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) & L_{2} \cos \left(\theta_{1}+\theta_{2}\right)\end{array}\right]\left[\begin{array}{l}\dot{\theta}_{1} \\\dot{\theta}_{2}\end{array}\right] }\end{array}</script><p>由 $\mathcal{K} =\frac{1}{2} \mathfrak{m} v^2 = \frac{1}{2} \mathfrak{m}(\dot{x}^2 + \dot{y}^2)$ ，连杆的动能项 ${ \cal K }_1$ 和 ${ \cal K }_2$ 分别为</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{K}_{1} &=\frac{1}{2} \mathfrak{m}_{1}\left(\dot{x}_{1}^{2}+\dot{y}_{1}^{2}\right) \\&=\frac{1}{2} \mathfrak{m}_{1} L_{1}^{2} \dot{\theta}_{1}^{2} \\\mathcal{K}_{2} &=\frac{1}{2} \mathfrak{m}_{2}\left(\dot{x}_{2}^{2}+\dot{y}_{2}^{2}\right) \\&=\frac{1}{2} \mathfrak{m}_{2}\left(\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \dot{\theta}_{1}^{2}+2\left(L_{2}^{2}+L_{1} L_{2} \cos \theta_{2}\right) \dot{\theta}_{1} \dot{\theta}_{2}+L_{2}^{2} \dot{\theta}_{2}^{2}\right)\end{aligned}</script><p>势能只取决于高度，即 $y$ 坐标。由 $\mathcal{P} = \mathfrak{m} g y$ ，连杆的势能项 ${ \cal P }_1$ 和 ${ \cal P }_2$ 分别为</p><script type="math/tex; mode=display">\begin{array}{l}\mathcal{P}_{1}=\mathfrak{m}_{1} g y_{1}=\mathfrak{m}_{1} g L_{1} \sin \theta_{1} \\\mathcal{P}_{2}=\mathfrak{m}_{2} g y_{2}=\mathfrak{m}_{2} g\left(L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\right)\end{array}</script><p>将动能项与势能项带入拉格朗日函数 $\eqref{6}$ 即可得到平面 $2R$ 运动链的动力学方程:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\tau_{1}=&\left(\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right)\right) \ddot{\theta}_{1} \\&+\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{2}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\&+\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right), \\\tau_{2}=& \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{1}+\mathfrak{m}_{2} L_{2}^{2} \ddot{\theta}_{2}+\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2} \\&+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) .\end{aligned}\right.</script><p>可以看到，即使是一个简单的 $2R$ 机器人，其逆运动学方程也十分复杂。对上述各项进行整理，得到如下形式的方程:</p><script type="math/tex; mode=display">\tau=M(\theta) \ddot{\theta}+\underbrace{c(\theta, \dot{\theta})+g(\theta)}_{h(\theta, \dot{\theta})}</script><p>式中</p><script type="math/tex; mode=display">\begin{aligned}M(\theta) &=\left[\begin{array}{cc}\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \\\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}L_{2}^{2} \\\end{array}\right] \\c(\theta, \dot{\theta}) &=\left[\begin{array}{c}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2}\end{array}\right] \\g(\theta) &=\left[\begin{array}{c}\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right)\end{array}\right]\end{aligned}</script><p>式中 <strong>$M(\theta)$ 为对称正定的质量矩阵</strong>， <strong>$c(\theta, \dot{\theta})$ 为速度乘积项，包含科里奥利和向心力矩的向量</strong>，其中包含 $\dot{\theta}^2$ 的二次项称为向心项，包含 $\dot{\theta}_{i} \dot{\theta}_{j}(i \ne j)$ 的二次项则称为科里奥利项。 <strong>$g(\theta)$ 为重力项</strong> ，因为此处势能仅来自重力，若末端有弹簧，弹簧也会贡献势能。这些揭示了运动方程是 $\ddot{\theta}$ 的线性函数、 $\dot{\theta}$ 的二次函数、 $\theta$ 的三角函数。上述结论不仅适用于 $2R$ 型机器人，对于包含转动关节的串联运动链也同样适用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="https://www.robotsfan.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="机器人" scheme="https://www.robotsfan.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>树莓派使用串口</title>
    <link href="https://www.robotsfan.com/posts/dab7fbfc.html"/>
    <id>https://www.robotsfan.com/posts/dab7fbfc.html</id>
    <published>2022-03-15T12:30:00.000Z</published>
    <updated>2024-07-17T03:03:42.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派使用串口"><a href="#树莓派使用串口" class="headerlink" title="树莓派使用串口"></a>树莓派使用串口</h1><p>树莓派默认将 serial0 映射到 外接GPIO的15、16脚。默认将 serial1 映射到 BT蓝牙上。所以如果想要将 ttyAMA0映射到外部 GPIO上，只需要禁用蓝牙，并将 serial0 和serial1 他们链接的对象互换。</p><p>但树莓派4B的更改方式与旧版本不同，终端输入<code>ls -l /dev/serial*</code>，发现只有serial1-&gt;ttyAMA0，没有serial0也没有ttyS0，更没有二者的映射。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>不要去修改<code>config.txt</code>里的配置！！！</strong>网上很多教程<strong>误人子弟</strong>，此文件开头就明确声明了禁止修改，用户的修改均要放置到<code>usercfg.txt</code>中！打开<code>config.txt</code>可以看到这个文件引用了<code>syscfg.txt</code>，这个文件里面写了<code>enable_uart=0</code>，也就是说即便在<code>config.txt</code>中修改了<code>enable_uart=1</code>，下面还是会被重新赋值为<code>enable_uart=0</code>。而<code>usercfg.txt</code>是在<code>syscfg.txt</code>后引用的，所以用户的修改项会覆盖上面的所有配置。</p><p>正确方法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /boot/firmware</span><br><span class="line">sudo vi usercfg.txt</span><br></pre></td></tr></table></figure><p>在里面添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enable_uart=1</span><br><span class="line">dtoverlay=disable-bt</span><br></pre></td></tr></table></figure><p>保存，然后禁用跟蓝牙有关的开机启动项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> bluetooth</span><br></pre></td></tr></table></figure><p>重启树莓派</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>然后再次<code>ls -l /dev/serial*</code>就可以看到正确的映射关系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="其他" scheme="https://www.robotsfan.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="树莓派" scheme="https://www.robotsfan.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV文档矫正</title>
    <link href="https://www.robotsfan.com/posts/c780224b.html"/>
    <id>https://www.robotsfan.com/posts/c780224b.html</id>
    <published>2022-03-14T02:30:00.000Z</published>
    <updated>2022-03-14T02:27:16.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV文档矫正"><a href="#OpenCV文档矫正" class="headerlink" title="OpenCV文档矫正"></a>OpenCV文档矫正</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将一个斜着拍摄的文档矫正成正的，如图所示：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_origin.jpg" alt="opencv-wendang-image_origin"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_output.jpg" alt="opencv-wendang-image_output"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>读取原始图像，若图像太大可以先进行缩放处理，并获取原始图像的宽和高</li><li>对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</li><li>找到最大的轮廓，并提取角点<ol><li>进行降噪处理：检测轮廓面积，只保留大于阈值面积的轮廓</li><li>计算每个轮廓的周长，使用DP算法计算出轮廓点的个数，规则为周长*0.02</li><li>找到图像中面积最大的，且角点为4的轮廓</li></ol></li><li>将找到的四个角点排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角<ol><li>将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</li><li>将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</li><li>重新排列四个角点</li></ol></li><li>进行透视变换<ol><li>根据变换前及变换后的四个角点，创建变换矩阵</li><li>根据变换矩阵对图像进行透视变换</li></ol></li><li>若透视变换后有一些毛边，按需要进行裁剪，裁剪后重新调整比例<ol><li>创建一个矩形用来裁剪，并设定四周裁剪5像素</li><li>裁剪后重新调整图像宽高</li></ol></li><li>显示变换后图像</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码中均有详细注释，请仔细阅读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些定义</span></span><br><span class="line">Mat image_origin,     <span class="comment">// 原始图像</span></span><br><span class="line">image_gray,       <span class="comment">// 灰度处理后的图像</span></span><br><span class="line">image_blur,       <span class="comment">// 高斯模糊处理后的图像</span></span><br><span class="line">image_canny,      <span class="comment">// 边缘检测后的图像</span></span><br><span class="line">image_dilate,     <span class="comment">// 膨胀后的图像</span></span><br><span class="line">image_erode,      <span class="comment">// 腐蚀后的图像</span></span><br><span class="line">image_preprocess, <span class="comment">// 预处理后的图像</span></span><br><span class="line">image_trans,      <span class="comment">// 透视变换后的图像</span></span><br><span class="line">image_crop;      <span class="comment">// 裁剪后的图像</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; origin_points,  <span class="comment">// 重新排列前的角点</span></span><br><span class="line">  reorder_points; <span class="comment">// 重新排列后的角点</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> origin_width = <span class="number">0</span>, origin_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：预处理，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line"><span class="comment"> * 输入：图像，是否显示(0-不显示 1-显示每一步处理后的图像 2-只显示最终图像)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PreProcess</span><span class="params">(<span class="keyword">const</span> Mat&amp; image, <span class="keyword">int</span> display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 灰度处理</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, image_gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(image_gray, image_blur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边缘检测(边缘检测前对图像进行一次高斯模糊)</span></span><br><span class="line"><span class="built_in">Canny</span>(image_blur, image_canny, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 膨胀和腐蚀(有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀)</span></span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(image_canny, image_dilate, kernel);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="comment">//erode(image_dilate, image_erode, kernel);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示预处理效果</span></span><br><span class="line"><span class="keyword">if</span>(display == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;灰度处理后的图像&quot;</span>, image_gray);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯模糊后的图像&quot;</span>, image_blur);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;边缘检测后的图像&quot;</span>, image_canny);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;膨胀后的图像&quot;</span>, image_dilate);</span><br><span class="line"><span class="comment">//imshow(&quot;腐蚀后的图像&quot;, image_erode);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(display == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;预处理后的图像&quot;</span>, image_dilate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image_dilate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：找到面积最大的轮廓</span></span><br><span class="line"><span class="comment"> * 输入：源图像</span></span><br><span class="line"><span class="comment"> * 输出：最大轮廓的四个角点数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">GetMaxContour</span><span class="params">(<span class="keyword">const</span> Mat&amp; img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment"> * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment"> * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * findContours找到轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment"> * 取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment"> * 取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment"> * 取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment"> * 取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment"> * 取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment"> * 取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment"> * 取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment"> * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * drawContours绘出轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours</span></span><br><span class="line"><span class="comment"> * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//drawContours(image, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">corners_contours</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; biggest_contours;</span><br><span class="line"><span class="keyword">double</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检测轮廓面积</span></span><br><span class="line"><span class="keyword">double</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设图像中有噪声，需要将其过滤，只保留面积大于1000的轮廓</span></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line"><span class="keyword">double</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], corners_contours[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到图像中面积最大的，且角点为4的轮廓</span></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; max_area &amp;&amp; corners_contours[i].<span class="built_in">size</span>() == <span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drawContours(image_origin, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">biggest_contours = &#123; corners_contours[i][<span class="number">0</span>],corners_contours[i][<span class="number">1</span>] ,corners_contours[i][<span class="number">2</span>] ,corners_contours[i][<span class="number">3</span>] &#125;;</span><br><span class="line">max_area = contour_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 只绘制角点之间的边框线，Debug用，取消注释可以看到检测出的所有边界框</span></span><br><span class="line"><span class="comment">//drawContours(image_origin, corners_contours, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(image_origin, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最大的轮廓</span></span><br><span class="line"><span class="keyword">return</span> biggest_contours;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：绘制一些点</span></span><br><span class="line"><span class="comment"> * 输入：点集，颜色</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoints</span><span class="params">(vector&lt;Point&gt; points, <span class="keyword">const</span> Scalar&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(image_origin, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line"><span class="built_in">putText</span>(image_origin, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：重新排列四个角点的顺序</span></span><br><span class="line"><span class="comment"> * 最终顺序为： 0  1</span></span><br><span class="line"><span class="comment"> *   2  3</span></span><br><span class="line"><span class="comment"> *   数组中为左上角-右上角-左下角-右下角</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">ReorderPoints</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Point&gt; newPoints;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV中左上顶点为(0,0)，右为x轴正向，下为y轴正向。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</span></span><br><span class="line">sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line"><span class="comment">// 将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</span></span><br><span class="line">subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新排列</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 0 和的最小值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 1 差的最大值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 2 差的最小值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 3 和的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：</span></span><br><span class="line"><span class="comment"> * 输入：源图像，四个角点的集合(角点的顺序为，左上角-右上角-左下角-右下角)，输出的宽，输出的高</span></span><br><span class="line"><span class="comment"> * 输出：透视变换后的图像</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PerspectiveTrans</span><span class="params">(<span class="keyword">const</span> Mat&amp; img, vector&lt;Point&gt; points, <span class="keyword">float</span> width, <span class="keyword">float</span> height )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 前面经过重新排列，四个角点的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="comment">// 变换后的四个角点</span></span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;width,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,height&#125;,&#123;width,height&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line"><span class="built_in">warpPerspective</span>(img, image_trans, matrix, <span class="built_in">Point</span>(width, height));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image_trans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.读取原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/image_origin.jpg&quot;</span>;</span><br><span class="line">image_origin = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 若图像太大可以先进行缩放处理</span></span><br><span class="line"><span class="comment">//resize(image_origin, image_origin, Size(), 0.5, 0.5);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始图像的宽和高</span></span><br><span class="line">origin_width  = image_origin.<span class="built_in">size</span>().width;</span><br><span class="line">origin_height = image_origin.<span class="built_in">size</span>().height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line">image_preprocess = <span class="built_in">PreProcess</span>(image_origin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找到最大的轮廓，并提取角点</span></span><br><span class="line">origin_points = <span class="built_in">GetMaxContour</span>(image_preprocess);</span><br><span class="line"><span class="comment">//DrawPoints(origin_points, Scalar(0, 0, 255)); // 红色</span></span><br><span class="line"><span class="comment">// 此时发现，角点的顺序不固定，为了后面进行透视变换时与代码中变换后点集的顺序相同，需要将其排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">reorder_points = <span class="built_in">ReorderPoints</span>(origin_points);</span><br><span class="line"><span class="comment">//DrawPoints(reorder_points, Scalar(0, 255, 0)); //绿色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.透视变换</span></span><br><span class="line">image_trans = <span class="built_in">PerspectiveTrans</span>(image_origin, reorder_points, origin_width, origin_height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换后有一些毛边，若需要可以进行裁剪</span></span><br><span class="line"><span class="comment">// 四周裁剪5像素</span></span><br><span class="line"><span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 创建一个矩形用来裁剪</span></span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, origin_width - (<span class="number">2</span> * cropVal), origin_height - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">image_crop = <span class="built_in">image_trans</span>(roi);</span><br><span class="line"><span class="comment">// 裁剪后重新调整比例</span></span><br><span class="line"><span class="built_in">resize</span>(image_crop, image_crop, <span class="built_in">Size</span>(origin_width, origin_height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.显示并输出变换后图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;源图像&quot;</span>, image_origin);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;最终图像&quot;</span>, image_crop);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;res/image_output.jpg&quot;</span>, image_crop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image.jpg" alt="opencv-wendang-image"></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
</feed>
