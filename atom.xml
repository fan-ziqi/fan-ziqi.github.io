<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>范子琦的博客</title>
  
  
  <link href="http://www.robotsfan.com/atom.xml" rel="self"/>
  
  <link href="http://www.robotsfan.com/"/>
  <updated>2022-04-08T13:59:41.426Z</updated>
  <id>http://www.robotsfan.com/</id>
  
  <author>
    <name>Fan Ziqi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FOC学习笔记【持续更新中】</title>
    <link href="http://www.robotsfan.com/posts/d99d1c1a.html"/>
    <id>http://www.robotsfan.com/posts/d99d1c1a.html</id>
    <published>2022-04-05T09:30:00.000Z</published>
    <updated>2022-04-08T13:59:41.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC学习笔记【持续更新中】"><a href="#FOC学习笔记【持续更新中】" class="headerlink" title="FOC学习笔记【持续更新中】"></a>FOC学习笔记【持续更新中】</h1><p><strong>2022.03.30 更新到状态观测器</strong></p><h2 id="FOC框架"><a href="#FOC框架" class="headerlink" title="FOC框架"></a>FOC框架</h2><p>三向电机，UVW三向，角度互差120度</p><p>对于BLDC控制方法，每次换向增加60度，转子只能到达六个位置，所以六步换向会有振动；使用FOC控制方法可以使转子到达任意角度，所以运行起来会更加平滑。</p><p>举个例子，如果想到达40度位置，只需要在0度方向通电一段时间，在60度方向通电一段时间，再在空矢量（全桥000或111）的状态下通电一段时间（空矢量的时长用来调节扭矩），三段时间组成一个周期，以这个周期循环产生PWM，即可锁定至40度。改变0度和60度的通电时长比例即可到达任意位置。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328103406110.png" alt="image-20220328103406110" style="zoom: 50%;"></p><p>要想使磁场旋转，就需要输入正弦电压。而我们的输入是直流电，可以通过不断改变PWM脉宽来模拟正弦电压，体现在电流上则为正弦电流。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328104728924.png" alt="image-20220328104728924" style="zoom:50%;"></p><p>对于一个完整的FOC框架，先来看正向通路：输入 $I_{d_ref}$ 和 $I_{q_ref}$ 与下文反馈通路采样得到的电流 $I_d$ 和 $I_q$ 进行PID调节输出 $U_d$ 和 $U_q$ （输入的 $I_{d_ref}$ 通常为0， $I_{q_ref}$ 前通常还需要接入一个速度PID构成速度环。），再通过反Park变换转换成 $U_\alpha$ 和 $U_\beta$ ，送进SVPWM产生六路PWM信号，将PWM信号输入逆变桥控制MOS管的通断，产生三向电压控制电机转动。</p><p>再来看反馈通路：通过采样电阻采集两路的电流，根据基尔霍夫电流定律，可以算出第三向电流，将三向电流通过Clark变换转化成 $I_\alpha$ 和 $I_\beta$ ，再通过Park变换转换成 $I_d$ 和 $I_q$ ，送入PID构成电流环。同时Park变换和反Park变换需要输入当前角度。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328110606943.png" alt="image-20220328110606943"></p><p>获得角度和速度的方法分为有感和无感。有感采用霍尔元件（Hall Sensor），安装在电机上检测电机磁铁的位置。无感使用观测器（observer）获得角度速度信息，本文将使用卡尔曼滤波观测器（EKF），输入为  $U_\alpha$ 、 $U_\beta$ 、 $I_\alpha$ 、 $I_\beta$ 。使用无感方式不需要霍尔传感器，可以减少线的数量，也可以减小成本。</p><h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>为什么要使用坐标变换？电机控制大多是在控制速度/转矩，需要用PID闭环控制正弦交流电压的幅值和角度，不是很容易实现，所以通过坐标变化把正弦交流信息分解成角度信息（Q轴控制转矩）和幅值信息（D轴控制磁场）单独控制。</p><p><strong>FOC的变换中要满足等幅值变换，即变换前后幅值不变。</strong></p><p>坐标变换都分为正向变换和反向变换，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。</p><p>下面的变换均采用联立和矩阵两种形式表示，以方便使用。</p><h3 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142441996.png" alt="image-20220328142441996" style="zoom:50%;"></p><p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    \begin{aligned}    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c    \end{aligned} \\    \begin{aligned}    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c    \end{aligned}\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{ccc}    1 & -\frac{1}{2}       & -\frac{1}{2} \\    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]</script><p>我们一般在电路中只采集两向电流，由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故上式也可整理为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=\frac{3}{2}I_a \\    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}    \frac{3}{2} & 0\\    \frac{\sqrt{3}}{2} & \sqrt{3}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \end{array}\right]</script><p>由于变换前后 $I_a$ 和 $I_\alpha$ 幅值要相同，所以要进行等幅值变换，变换系数为 $\frac{2}{3}$ ，即变为</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=I_a \\    I_\beta=\frac{1}{\sqrt3}(I_a+2I_b)\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}    1 & 0\\    \frac{1}{\sqrt{3}} & \frac{2}{\sqrt{3}}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \end{array}\right]</script><p>（这里的系数在后文SVPWM里相电压的幅值与电压空间矢量之间有一个 $\frac{3}{2}$ 的系数相抵消）</p><p>MATLAB实现为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103933845.png" alt="image-20220330103933845"></p><h3 id="Clark反变换"><a href="#Clark反变换" class="headerlink" title="Clark反变换"></a>Clark反变换</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142204832.png" alt="image-20220328142204832" style="zoom:50%;"></p><p>Clark反变换则将三向信号转换为两向信号。根据图可以写出：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{a} =  U_{\alpha} \\U_{b} = -\frac{1}{2}U_{\alpha} + \frac{\sqrt3}{2}U_{\beta}\\U_{c} = -\frac{1}{2}U_{\alpha} - \frac{\sqrt3}{2}U_{\beta}\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    U_{a} \\    U_{b} \\    U_{c}\end{array}\right]=\left[\begin{array}{ccc}    1  & 0       \\    -\frac{1}{2} & \frac{\sqrt{3}}{2} \\    -\frac{1}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    U_{\alpha} \\    U_{\beta}\end{array}\right]</script><p>MATLAB实现为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103915885.png" alt="image-20220330103915885"></p><h3 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h3><p>Park变换可以将正弦变量线性化</p><p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142542510.png" alt="image-20220328142542510" style="zoom:50%;"></p><p>也就是说 $d-q$ 坐标系始终跟着转子同步旋转。</p><p>则根据上图可以写出</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos\theta+I_{\beta} \sin\theta \\I_{q}=-I_{\alpha} \sin\theta+I_{\beta} \cos\theta\end{array}\right.</script><p>很明显上述变换可以用旋转矩阵来表示，使用矩阵形式可以很方便地写出：</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & \sin \theta \\    -\sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>（如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。）</p><p>MATLAB实现为</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104003922.png" alt="image-20220330104003922"></p><h3 id="Park反变换"><a href="#Park反变换" class="headerlink" title="Park反变换"></a>Park反变换</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220328142732077.png" alt="image-20220328142732077" style="zoom:50%;"></p><p>根据上面的推导可以求得反Park变换</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{\alpha}=U_{d} \cos\theta-U_{q} \sin\theta \\U_{\beta}= U_{d} \sin\theta+U_{q} \cos\theta\end{array}\right.</script><p>同理，使用旋转矩阵可以求出反变换的系数矩阵：</p><script type="math/tex; mode=display">\left[\begin{array}{l}    U_{\alpha} \\    U_{\beta}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & -\sin \theta \\     \sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    U_{d} \\    U_{q}\end{array}\right]</script><p>MATLAB实现为</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103857619.png" alt="image-20220330103857619"></p><h3 id="MATLAB仿真"><a href="#MATLAB仿真" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h3><p>为了更清楚地仿真，这里不用矩阵形式表示，如需矩阵形式可以看我另一篇文章。</p><p>请注意，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。但是在这节的仿真中，把正变换和反变换连在一起，没有实际意义，只是为了验证。</p><p>输入Vd为0，Vq为1，角度为由0到2pi的连续值。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103716603.png" alt="image-20220330103716603"></p><p>再来看foc模块内部，输入经过两个逆变换，再经过两个正变换。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103816443.png" alt="image-20220330103816443"></p><p>运行查看波形（新版本MATLAB常值输入为一个圆圈）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104412589.png" alt="image-20220330104412589"></p><h2 id="SVPWM"><a href="#SVPWM" class="headerlink" title="SVPWM"></a>SVPWM</h2><p>根据BLDC的六步换向，可以将一圈分为六个扇区，前文FOC引入章节已经讲过，只需要控制每个状态通电的时间就可以控制转子到达任意角度。这就是SVPWM。</p><p>SVPWM的输入为 $U_{\alpha}$ 和 $U_{\beta}$ ，输出为三向计数器的比较值。所以应该首先判断用哪两个相邻矢量，然后计算两个相邻矢量的作用时长，然后将作用时长转化成计数器的比较数值送入定时器。下面对这三个步骤进行讲解。</p><h3 id="扇区判断"><a href="#扇区判断" class="headerlink" title="扇区判断"></a>扇区判断</h3><p>三相电压可以表示为（ $U_{m}$ 为电压幅值）：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{m}cos\theta \\U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\U_c = U_{m}cos(\theta+\frac{2}{3}\pi)\end{array}</script><p>将其转换为 $\alpha-\beta$ 坐标系，可以算出</p><script type="math/tex; mode=display">\begin{array}{l}U_{\alpha} = U_{m}cos\theta \\U_{\beta} = U_{m}sin\theta\end{array}</script><p>从这个式子发现，可以从中算出角度信息从而可以判断在哪个扇区</p><script type="math/tex; mode=display">\theta = arctan(\frac{U_{\beta}}{U_{\alpha}})</script><p>由于除法和反三角函数对于MCU来说计算量比较大。我们来找一个简便算法。</p><p> $U_{\alpha}$ 是关于cos的三角函数， $U_{\beta}$ 是关于sin的三角函数，可以得到：</p><script type="math/tex; mode=display">\begin{array}{l}扇区1:& U_{\alpha} > 0&,& U_{\beta} > 0\\扇区2:& U_{\alpha} >or< 0&,& U_{\beta} > 0\\扇区3:& U_{\alpha} < 0&,& U_{\beta} > 0\\扇区4:& U_{\alpha} < 0&,& U_{\beta} < 0\\扇区5:& U_{\alpha} >or< 0&,& U_{\beta} < 0\\扇区6:& U_{\alpha} > 0&,& U_{\beta} < 0\end{array}</script><p>可以看到，通过 $U_{\beta}$ 的正负可以判断出是1/2/3扇区还是4/5/6扇区。</p><p>这个条件只将扇区分为两个部分，我们还需要几个条件来更细致地分。将每个扇区的反三角函数范围计算出来：</p><script type="math/tex; mode=display">\begin{aligned}扇区1:& tan0^{\circ} >   \frac{U_{\beta}}{U_{\alpha}} > tan60^{\circ} &\Rightarrow& 0 &>&        \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\扇区2:& tan60^{\circ} >  \frac{U_{\beta}}{U_{\alpha}} > tan120^{\circ} &\Rightarrow& \sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\扇区3:& tan120^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan180^{\circ} &\Rightarrow&-\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0        \\扇区4:& tan180^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan240^{\circ} &\Rightarrow&0        &>& \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\扇区5:& tan240^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan300^{\circ} &\Rightarrow&\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\扇区6:& tan300^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan360^{\circ} &\Rightarrow& -\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0\end{aligned}</script><p>观察这个结论， $U_{\beta}$ 和 $\sqrt{3}U_{\alpha}$ 似乎有关系，回顾反Clark变换， $U_{b}$ 和 $U_{c}$ 的式子就是这种关系。所以可以把上面的结论往反Clark变换上凑。看一下反Clark变换的图像，注意我们需要的关系里的 $\sqrt{3}$ 是乘在 $U_{\alpha}$ 上的，所以我们把 $U_{\beta}$ 和 $U_{\alpha}$ 反一下，对应的公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{a} =  U_{\beta} \\U_{b} = -\frac{1}{2}U_{\beta} + \frac{\sqrt3}{2}U_{\alpha}\\U_{c} = -\frac{1}{2}U_{\beta} - \frac{\sqrt3}{2}U_{\alpha}\end{array}\right.</script><p>生成上述公式的图像，其中黄色的线为 $U_{a}$ 为 $U_{\beta}$ ，蓝色的线 $U_{b}$ 为 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，红色的线 $U_{c}$ 为 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330145027064.png" alt="image-20220330145027064"></p><p>可以看到在每个扇区内总有一向大于0，两向小于0，所以 $U_{b}$ 和 $U_{c}$ 的正负可以当做判断条件之一。我们顺便还又一次得到了 $U_{\beta}$ 这个判断条件。整理一下上面的式子</p><script type="math/tex; mode=display">\begin{aligned}扇区1:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\扇区2:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\扇区3:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区4:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区5:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区6:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\end{aligned}</script><p>所以通过计算 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 的正负可以判断出是1/6扇区，3/4扇区，2扇区，5扇区的哪一组。</p><p>综上，我们的判断条件有： $U_{\beta}$ 、 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 。我们分别定义：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{\beta} \\U_b = \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\\U_c = -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\end{array}</script><p>综合这三个条件就可以判断是在哪个扇区 。那么有没有一种算法可以将这一堆判断数值化并转换成1~6的数字呢？可以用下面的公式：</p><script type="math/tex; mode=display">N=A+2B+4C</script><p>式中A代表 $U_a$ 的正负，B代表 $U_b$ 的正负，C代表 $U_c$ 的正负，大于0为1，小于0为0。最后转换出来的的N即为1~6的数字：</p><script type="math/tex; mode=display">\begin{array}{c}扇区 & 1 & 2 & 3 & 4 & 5 & 6 & \\N   & 3 & 1 & 5 & 4 & 6 & 2 &\end{array}</script><p>至此，我们成功完成了扇区判断。</p><h3 id="计算相邻矢量作用时长"><a href="#计算相邻矢量作用时长" class="headerlink" title="计算相邻矢量作用时长"></a>计算相邻矢量作用时长</h3><p>控制相邻矢量作用时长就可以控制转子到达任意方向，下面进行分析。</p><h4 id="六个矢量的大小"><a href="#六个矢量的大小" class="headerlink" title="六个矢量的大小"></a>六个矢量的大小</h4><p>六个MOS管可以产生8种状态</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152650462.png" alt="image-20220330152650462" style="zoom:50%;"></p><p>设上开下合为0（电流从O往对应的向流），上合下开为1（电流从对应的向往O流），表示其中的六个矢量。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152634407.png" alt="image-20220330152634407"></p><p>放在一张图中即为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152741018.png" alt="image-20220330152741018" style="zoom:50%;"></p><p>还有两个零矢量（000和111），无电流，不产生磁场。</p><p>对于100的状态，可以等效为下面的电路图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330154344462.png" alt="image-20220330154344462" style="zoom:25%;"></p><p>可以计算出电机中三个相电压（每相相对于电机中间连接点的电压）</p><script type="math/tex; mode=display">\begin{aligned}U_{AN} &=U_{A}-U_{N}=\frac{2}{3} U_{d c} \\U_{BN} &=U_{B}-U_{N}=-\frac{1}{3} U_{d c} \\U_{CN} &=U_{C}-U_{N}=-\frac{1}{3} U_{d c}\end{aligned}</script><p>同理可以计算其他所有方向矢量的相电压，可以看出，六个矢量的大小均为 $\frac{2}{3} U_{d c}$ ，即<strong>SVPWM相电压幅值为 $\frac{2}{3} U_{d c}$</strong> </p><h4 id="电压利用率"><a href="#电压利用率" class="headerlink" title="电压利用率"></a>电压利用率</h4><p>电压利用率等于合成矢量的电压除以母线电压。下面在复平面计算合成矢量的电压 $U_{out}$ ：</p><script type="math/tex; mode=display">U_{out} = U_a +U_{b}\cdot e^{j\cdot \frac{2}{3}\pi}+U_{c}\cdot e^{j\cdot (-\frac{2}{3}\pi)}</script><p>根据欧拉公式可以推导出：</p><script type="math/tex; mode=display">e^{jx}=cosx+jsinx</script><p>又因为三相电压与相电压幅值之间的关系：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{m}cos\theta \\U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\U_c = U_{m}cos(\theta+\frac{2}{3}\pi)\end{array}</script><p>带入可以计算出 $U_{out}$ ：</p><script type="math/tex; mode=display">U_{out}=\frac{3}{2}U_m\cdot e^{j\theta}</script><p>合成矢量的电压是相电压幅值的 $\frac{3}{2}$ 倍，而SVPWM相电压幅值 $U_m$ 为 $\frac{2}{3} U_{d c}$ ，所以</p><script type="math/tex; mode=display">U_{out}=U_{dc}</script><p>即<strong>合成矢量的电压等于母线电压</strong>。所以<strong>SVPWM的电压利用率是100%</strong>。</p><h4 id="SVPWM输出电压是马鞍波"><a href="#SVPWM输出电压是马鞍波" class="headerlink" title="SVPWM输出电压是马鞍波"></a>SVPWM输出电压是马鞍波</h4><p>由于中间连接点N的点位 是浮动的，为三角波，而相电压是每相相对于电机中间连接点N的电压，所以相电压不是一个正弦波，而是一个正弦波与一个三角波叠加而成的，即为马鞍波。网图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/d94c427b1d664ffe9b585d58e60482f6.jpg" alt="d94c427b1d664ffe9b585d58e60482f6"></p><h4 id="矢量作用时长"><a href="#矢量作用时长" class="headerlink" title="矢量作用时长"></a>矢量作用时长</h4><p>合成矢量的电压是所在扇区两个矢量与空矢量不同时长的组合：</p><script type="math/tex; mode=display">U_{out}=U_x\frac{T_x}{T_s}+U_y\frac{T_y}{T_s}+U_0\frac{T_0}{T_s}</script><p>由于SVPWM的输入是 $U_{\alpha}$ 和 $U_{\beta}$ ，但是要控制 $T_x$ 和 $T_y$ ，所以要找到他们的对应关系。</p><p>对于第一个扇区，将 $U_{out}$ 在 $\alpha-\beta$ 坐标系中表示：</p><script type="math/tex; mode=display">\begin{array}{l}U_\alpha=|U_x|\frac{T_x}{T_s}+|U_y|\frac{T_y}{T_s}cos60^{\circ}\\U_\beta=|U_y|\frac{T_y}{T_s}sin60^{\circ}\end{array}</script><p>其中 $|U_x|$ 和 $|U_y|$ 根据前面的计算均为 $\frac{2}{3} U_{d c}$ ，可以解出：</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\end{array}</script><p>同理，可以计算出所有六个扇区：</p><p>第二扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\end{array}</script><p>第三扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\end{array}</script><p>第四扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\end{array}</script><p>第五扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\end{array}</script><p>第六扇区 </p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\end{array}</script><p>六个扇区中都有相同的项，其中包含前文判断扇区所用的 $U_1$ 、 $U_2$ 、 $U_3$ 。直接把前面已经计算过的变量拿过来使用，大大减少了计算量。式中的 $\frac{\sqrt{3}T_S}{U_{dc}}$ 为调制比，定义：</p><script type="math/tex; mode=display">\begin{array}{l}U_{mr} = \frac{\sqrt{3}T_S}{U_{dc}} \\X= \frac{\sqrt{3}T_S}{U_{dc}}U_\beta=U_{mr}U_1\\Y= \frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_2\\Z= \frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_3\end{array}</script><p>可以将六个扇区表示为：</p><script type="math/tex; mode=display">\begin{array}{c}& T_x & T_y  \\扇区1&  Y  &  X  \\扇区2& -Y  & -Z  \\扇区3&  X  &  Z  \\扇区4& -X  & -Y  \\扇区5&  Z  &  Y  \\扇区6& -Z  & -X  \\\end{array}</script><h3 id="定时器比较值计算"><a href="#定时器比较值计算" class="headerlink" title="定时器比较值计算"></a>定时器比较值计算</h3><p>我们前文算出来的 $T_x$ 和 $T_y$ 以秒为单位，需要把 $T_x$ 和 $T_y$ 转换为定时器比较值。定时器模式使用中心对齐，只需要控制半个周期的比较值就可以产生相对中心对称的PWM波。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331141308347.png" alt="image-20220331141308347" style="zoom:50%;"></p><p>先来看第一扇区。在一个扇区内切换状态的时候，合理使用零矢量可以保证每一次切换只改变一路MOS管。那么第一扇区内的切换顺序就为：</p><script type="math/tex; mode=display">000 \to 100 \to 110 \to 111 \to 110 \to 100 \to 000</script><p>可以看到，切换顺序构成了一个环路。在一个周期内我们需要控制三段作用时长：</p><script type="math/tex; mode=display">T_s=T_x+T_y+T_N</script><p>六个MOS需要产生六路PWM来控制他们的状态。由于上下半桥是互补的，所以只需要生成三个PWM：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331151522966.png" alt="image-20220331151522966"></p><p>由于是中心对齐模式，所以只需要控制半个周期的时长 $\frac{T_x}{2}$ 和 $\frac{T_y}{2}$ 。在半个周期内 $T_N$ 出现了两次，分别为000和111，在半个周期内这两段时间平均分配。即为 $\frac{T_S-T_x-T_y}{4}$ 。</p><p>这样就可以计算三个定时器的比较值 $T_1$ 、 $T_2$ 和 $T_3$ ：</p><script type="math/tex; mode=display">\begin{array}{l}T_1= \frac{T_S-T_x-T_y}{4}\\T_2=T_a+\frac{T_x}{2}\\T_3=T_b+\frac{T_y}{2}\end{array}</script><p>同理，可以计算出所有六个扇区的切换顺序。通过结果可以得到结论：</p><p>设</p><script type="math/tex; mode=display">\begin{array}{l}T_a= \frac{T_S-T_x-T_y}{4}\\T_b=T_a+\frac{T_x}{2}\\T_c=T_b+\frac{T_y}{2}\end{array}</script><p>那么六个扇区可以表示为：</p><script type="math/tex; mode=display">\begin{array}{c}  & 扇区1 & 扇区2 & 扇区3 & 扇区4 & 扇区5 & 扇区6 & \\T1& T_a & T_b & T_c & T_c & T_b & T_a &\\T2& T_b & T_a & T_a & T_b & T_c & T_c &\\T3& T_c & T_c & T_b & T_a & T_a & T_b &\end{array}</script><p>至此，SVPWM输出比较值 $T_1$ 、 $T_2$ 、 $T_3$ ，互补得到六个比较值，输入到定时器，输出三路PWM。</p><h4 id="MATLAB仿真-1"><a href="#MATLAB仿真-1" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h4><p>设定Udc为24，pwm为18000</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163919487.png" alt="image-20220331163919487"></p><p>在foc子模块中，将park反变换的输出输入SVPWM模块：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163836635.png" alt="image-20220331163836635"></p><p>SVPWM模块：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[T1,T2,T3,sector]</span> = <span class="title">fcn</span><span class="params">(Ualpha,Ubeta,Udc,Tpwm)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">sector = single(<span class="number">0</span>);</span><br><span class="line">T1 = single(<span class="number">0</span>);</span><br><span class="line">T2 = single(<span class="number">0</span>);</span><br><span class="line">T3 = single(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一步：扇区判断</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ua = Ubeta;</span><br><span class="line">Ub = (<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line">Uc = (-<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% 计算判断扇区所用的ABC的值</span></span><br><span class="line">A=single(<span class="number">0</span>);B=single(<span class="number">0</span>);C=single(<span class="number">0</span>);N=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(Ua&gt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ua&lt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Ub&gt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ub&lt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Uc&gt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Uc&lt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算判断扇区所用的N的值</span></span><br><span class="line">N = A + <span class="number">2</span>*B + <span class="number">4</span>*C;</span><br><span class="line"><span class="comment">% 扇区判断</span></span><br><span class="line"><span class="keyword">switch</span> (N)   </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        sector = single(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        sector = single(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        sector = single(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        sector = single(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        sector = single(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        sector = single(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：计算相邻矢量作用时长</span></span><br><span class="line"><span class="comment">% 计算调制比</span></span><br><span class="line">Umr = <span class="built_in">sqrt</span>(<span class="number">3</span>)*Tpwm/Udc;</span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">X = Umr * Ua;</span><br><span class="line">Y = Umr * Ub;</span><br><span class="line">Z = Umr * Uc;</span><br><span class="line"><span class="comment">% 分扇区计算Tx和Ty的值</span></span><br><span class="line">Tx=single(<span class="number">0</span>);Ty=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        Tx = Y; Ty = X;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        Tx = -Y; Ty = -Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        Tx = X; Ty = Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        Tx = -X; Ty = -Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        Tx = Z; Ty = Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        Tx = -Z; Ty = -X;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：定时器比较值计算</span></span><br><span class="line"><span class="comment">% 干啥用的？</span></span><br><span class="line"><span class="keyword">if</span> Tx+Ty &gt; Tpwm</span><br><span class="line">    Tx = Tx/(Tx+Ty);</span><br><span class="line">    Ty = Ty/(Tx+Ty);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Tx = Tx;</span><br><span class="line">    Ty = Ty;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ta = (Tpwm-Tx-Ty)/<span class="number">4.0</span>;</span><br><span class="line">Tb = Ta+Tx/<span class="number">2.0</span>;</span><br><span class="line">Tc = Tb+Ty/<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">% 分扇区计算定时器比较值T1、T2和T3的值</span></span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        T1 = Ta; T2 = Tb; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        T1 = Tb; T2 = Ta; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        T1 = Tc; T2 = Ta; T3 = Tb;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        T1 = Tc; T2 = Tb; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        T1 = Tb; T2 = Tc; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        T1 = Ta; T2 = Tc; T3 = Tb;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到，定时器比较值为马鞍波</p><p><img src="/posts/Users\fanziqi\AppData\Roaming\Typora\typora-user-images\image-20220331165323898.png" alt="image-20220331165323898"></p><p>扇区为从1到6的循环</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331165348883.png" alt="image-20220331165348883"></p><h2 id="电流闭环"><a href="#电流闭环" class="headerlink" title="电流闭环"></a>电流闭环</h2><p>前文输入 $U_{d}$ 和 $U_{q}$ 到反Park变换，输出 $U_{\alpha}$ 和 $U_{\beta}$ 到SVPWM，输出三对互补的PWM到全桥，最后输出三相电压到电机。如果需要让电机以设定的电流运行，就需要PI闭环控制电流。闭环控制三相交流电流是不太容易实现的，所以我们选择闭环控制直流电流 $I_{d}$ 和 $I_{q}$ 。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/20220406114532.png" alt></p><p>PI控制器输入 $I_{d_{ref}}$ 和 $I_{q_{ref}}$ ，输出 $U_{d}$ 和 $U_{q}$ ，现在还需要反馈量 $I_{d}$ 和 $I_{q}$ ，这就需要用到前文讲到的正变换。用采样电阻搭配ADC采集全桥上任意两相的电流，通过基尔霍夫电流定律计算第三相电流，一并送入Clark变换输出 $I_{\alpha}$ 和 $I_{\beta}$ ，再通过Park变换产生反馈量 $I_{d}$ 和 $I_{q}$ 。</p><p>对于PI的参数设定，有一个参考设定值（还是需要自行调整）：</p><script type="math/tex; mode=display">\begin{array}{c}  & P & I &\\d& K_{pd}=\alpha L_d & K_{Id}=\alpha R\\q& K_{pq}=\alpha L_q & K_{Iq}=\alpha R\end{array}</script><p>其中 $\alpha$ 的取值为（ $\tau$ 为电机的时间常数）：</p><script type="math/tex; mode=display">\alpha = \frac{2\pi}{\tau} \\\tau = min\left\{\frac{L_d}{R},\frac{L_q}{R}\right\}</script><p>电机分为表贴电机和内嵌式电机，表贴式是把永磁体贴在转子表面，内嵌式是把永磁体安装在转子内。我们常用的电机都是表贴电机，对于表贴电机， $L_d=L_q=L$ ，则：</p><script type="math/tex; mode=display">K_{pd}=2\pi R \\K_{Id}=2\pi \frac{R^2}{L}</script><h2 id="角度和速度"><a href="#角度和速度" class="headerlink" title="角度和速度"></a>角度和速度</h2><h3 id="有感（HALL）"><a href="#有感（HALL）" class="headerlink" title="有感（HALL）"></a>有感（HALL）</h3><p>霍尔传感器分为60度和120度</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220406151555324.png" alt="image-20220406151555324"></p><p>画一下转一圈三个霍尔传感器的波形</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220406151530069.png" alt="image-20220406151530069"></p><p>这两种排列方式除了组合方式不同，其他都一样。</p><p>单片机通过输入捕获采集三路高低电平的跳变，通过对三路信号进行异或，则转一圈可以进6次中断，进入中断后检测IO电平就可以知道电机对应角度。但现在一圈只能获取到6个固定的角度值，无法获取到如80度这个角度。这时可以对速度进行积分得到角度，速度的获取可以通过查询60-120之间定时器的计数值来获得。但是转到80度的时候没办法获取到120度时候的定时器计数值就无法获取当前段的速度，这时可以用前一段的速度近似为当前段的速度。</p><h3 id="无感（EKF）"><a href="#无感（EKF）" class="headerlink" title="无感（EKF）"></a>无感（EKF）</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>前面的有感部分，是在电机上安装霍尔传感器，引出三根线到单片机通过输入捕获算出当前角度，再与预设角度完成角度闭环。</p><p>而无感控制则不需要霍尔传感器，只需要三根UVW线输出到电机即可，去掉了霍尔传感器和三根线，节省了成本；有些使用场合无法使用霍尔传感器，则需要使用无感，比如空调压缩机，内部充满了润滑油，无法安装霍尔传感器；有些时候有感算法或硬件出现问题也可以切换至无感，防止系统闸机，比如汽车运行中霍尔传感器突然坏了，为了使整个系统正常运行，就可以临时切换到无感。上述这些都是无感控制的优点。无感控制现在已经越来越普及，空调、洗衣机、高端风扇、汽车都在用无感控制。</p><p>无感是如何获取到转子位置的呢？观察永磁同步电机的方程：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_\alpha = Ri_\alpha + L_s \frac{di_\alpha}{dt} - \omega_e \psi_f sin\theta\\U_\beta = Ri_\beta + L_s \frac{di_\beta}{dt} + \omega_e \psi_f cos\theta\end{array}\right.</script><p>上述方程的含义为：将每一相抽象为一个电阻，一个电感和一个反电动势的串联，则每一相的电压为前面三项压降之和（反电动势为速度乘磁链）。方程中的电阻R、电感L、和磁链flux为电机的固有参数，电流可以通过采样电阻获得，剩下角度和转速，可以很容易地获得他们之间的关系。</p><p>但是电机参数会有误差，除了生产误差，温度的改变会造成电阻值变化、采集的电流经过运算放大器会造成误差、AD转换的精度还会造成误差。所以通过这种方式直接计算，稳定性、抗干扰能力、鲁棒性都不高，只是一个理论方法，无法实际应用。所以要用状态观测器重构整个电机的模型，提高稳定性。</p><h4 id="状态观测器"><a href="#状态观测器" class="headerlink" title="状态观测器"></a>状态观测器</h4><p>观测器有很多种，EKF、滑膜、龙伯格、自适应等，这里先将EKF，即卡尔曼滤波观测器。</p><p>无感观测器的输入为 $U_{\alpha}$ 、 $U_{\beta}$ 、 $I_{\alpha}$ 、 $I_{\beta}$ 和电机参数，输出角度 $\theta$ 和速度 $\omega_e$  ， $\theta$ 送入park变换和反park变换， $\omega_e$ 用作下文的速度闭环。</p><p>状态空间方程为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\frac{dx}{dt} = Ax+Bu = f(x)+Bu\\y=Cx\end{array}\right.</script><p>无感观测器的框图为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220406164426022.png" alt="image-20220406164426022"></p><p>将永磁同步电机的方程转化为状态空间表达式：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\frac{d i_\alpha}{dt} = -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta + \frac{1}{L_s}U_\alpha \\\frac{d i_\beta}{dt} = -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta + \frac{1}{L_s}U_\beta \\\frac{d \omega_e}{dt} = 0 \\\frac{d \theta}{dt} = \omega_e\end{array}\right.</script><p>整理成矩阵形式</p><script type="math/tex; mode=display">\dot{x}=\begin{bmatrix} \frac{d i_\alpha}{dt} \\ \frac{d i_\beta}{dt} \\ \frac{d \omega_e}{dt} \\ \frac{d \theta}{dt} \\\end{bmatrix}\quadx=\begin{bmatrix} i_\alpha \\ i_\beta \\ \omega_e \\ \theta \\\end{bmatrix}\quadf(x)=\begin{bmatrix} -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta \\ -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta \\ 0 \\ \omega_e \\\end{bmatrix}\quadB=\begin{bmatrix} \frac{1}{L_s} & 0 \\ 0 & \frac{1}{L_s} \\ 0 & 0 \\ 0 & 0 \\\end{bmatrix}\quadu=\begin{bmatrix} U_\alpha \\ U_\beta \\\end{bmatrix}\quadC=\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\\end{bmatrix}\quad</script><h2 id="速度闭环"><a href="#速度闭环" class="headerlink" title="速度闭环"></a>速度闭环</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="http://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="http://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>FOC控制原理——Clark变换和Park变换</title>
    <link href="http://www.robotsfan.com/posts/9532f19e.html"/>
    <id>http://www.robotsfan.com/posts/9532f19e.html</id>
    <published>2022-03-23T08:25:00.000Z</published>
    <updated>2022-03-23T08:32:26.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC控制原理——Clark变换和Park变换"><a href="#FOC控制原理——Clark变换和Park变换" class="headerlink" title="FOC控制原理——Clark变换和Park变换"></a>FOC控制原理——Clark变换和Park变换</h1><h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153620081.png" alt="image-20220323153620081"></p><p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    \begin{aligned}    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c    \end{aligned} \\    \begin{aligned}    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c    \end{aligned}\end{array}\right.</script><p>可以将其整理成矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{ccc}    1 & -\frac{1}{2}       & -\frac{1}{2} \\    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]</script><p>由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故也可整理为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=\frac{3}{2}I_a \\    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b\end{array}\right.</script><p>反Clark变换则将三向信号转换为两向信号，根据上式可以解得</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]=\left[\begin{array}{ccc}    \frac{2}{3}  & 0       \\    -\frac{1}{3} & \frac{1}{\sqrt{3}} \\    -\frac{1}{3} & -\frac{1}{\sqrt{3}}\end{array}\right]\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>也可通过计算Clark变换常数矩阵的伪逆来确定反Clark变换的常数矩阵（使用MATLAB中的 <code>pinv()</code>函数）</p><h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323152939436.png" alt="image-20220323152939436"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323150553068.png" alt="image-20220323150553068"></p><p>通过图像可以看到，输入信号的幅值为1，经过Clark变换后的图像幅值变为1.5，即变为 $\frac{3}{2}$ 倍；进行反Clark变换后幅值又变为1.5，即变为 $\frac{2}{3}$ 倍。所以要进行等幅值变换。修改仿真：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153007076.png" alt="image-20220323153007076"></p><p>可以看到，经过等幅值变换后，幅值统一为1。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323151818659.png" alt="image-20220323151818659"></p><h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Park变换可以将正弦变量线性化</p><p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/v2-d15d057327992a5c50016aea5bb7201b_1440w.jpg" alt="img"></p><p>也就是说 $d-q$ 坐标系始终跟着转子旋转。</p><p>则可以写出</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \\I_{q}=-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)\end{array}\right.</script><p>整理成矩阵形式</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & \sin \theta \\    -\sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>所以如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。</p><p>同理，可以求得反Park变换</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & -\sin \theta \\     \sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]</script><h3 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>在Clark变换和等幅值变换的基础上添加Park变换</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160805870.png" alt="image-20220323160805870"></p><p>关注Park部分</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160942614.png" alt="image-20220323160942614"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="http://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="http://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>机器人动力学——拉格朗日法</title>
    <link href="http://www.robotsfan.com/posts/c0ff5b54.html"/>
    <id>http://www.robotsfan.com/posts/c0ff5b54.html</id>
    <published>2022-03-15T12:30:00.000Z</published>
    <updated>2022-03-15T12:35:41.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器人动力学——拉格朗日法"><a href="#机器人动力学——拉格朗日法" class="headerlink" title="机器人动力学——拉格朗日法"></a>机器人动力学——拉格朗日法</h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p>机器人动力学所用到的运动学方程是一组具有下列形式的二阶微分方程组</p><script type="math/tex; mode=display">\tau = M ( \theta ) \ddot { \theta } + h ( \theta , \dot { \theta } ) \label{1}</script><p>式中，对于所有关节均为驱动关节的开式运动链，广义坐标 $\theta \in \mathbb{R}^{n}$ 表示关节变量；广义力 $\tau \in \mathbb{R}^{n}$ 表示力或力矩，如果 $\theta_i$ 是旋转关节，则 $\tau_i$ 对应力矩；如果 $\theta_i$ 为平动关节，则 $\tau_i$ 对应力； $M ( \theta )\in \mathbb{R}^{n\times{n}}$ 是一个对称且正定的质量矩阵；$h ( \theta , \dot { \theta })\in \mathbb{R}^{n}$ 是将向心力、科里奥利力、重力和摩擦力等集合在一起的力向量，该向量取决于 $\theta$ 和 $ \dot { \theta}$ 这两个变量。</p><p>运动学同样区分正运动学和逆运动学，正向动力学问题是在给定状态变量 $( \theta , \dot { \theta })$ 以及关节力和力矩的前提下确定机器人的加速度 $\ddot { \theta }$ ，即</p><script type="math/tex; mode=display">\ddot { \theta } = M ^ { - 1 } ( \theta ) ( \tau - h ( \theta , \dot { \theta } ) )</script><p>逆动力学问题则是找到对应于机器人状态和期望加速度的关节力和力矩$\tau$，即式 $\eqref{1}$ </p><p>机器人的动力学方程通常可以通过<strong>牛顿-欧拉公式</strong>或<strong>拉格朗日动力学公式</strong>得到。对于简单结构的机器人，如3自由度或自由度更少的情形，拉格朗日形式不仅在概念上十分优雅，并且在实际中非常有效。但对于自由度数目更多的机器人来讲，其计算可能会很快变得烦琐。</p><p>下文将讨论拉格朗日动力学公式</p><h2 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h2><p>力学系统的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 定义为整个系统的动能 ${ \cal K } ( q , \dot { q } )$ 减去势能 ${ \cal P } ( q )$ ，式中的—组独立坐标 $q \in \mathbb{R}^{n}$ 用来描述系统的位形（这个坐标 $q$ 被称为广义坐标）</p><script type="math/tex; mode=display">{ \cal L } ( q , \dot { q } ) = { \cal K } ( q , \dot { q } ) - { \cal P } ( q )</script><p>运动方程现在可以用拉格朗日函数表示如下（推导过程略，详见动力学教材）</p><script type="math/tex; mode=display">f = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { q } } - \frac { \partial { \cal L } } { \partial q }</script><p>这个方程也称为<strong>含外力的欧拉-拉格朗日方程</strong>（在标准形式的欧拉-拉格朗日方程中，外力 $f$ 等于零）</p><h2 id="2R-开链机器人举例"><a href="#2R-开链机器人举例" class="headerlink" title="$2R$ 开链机器人举例"></a>$2R$ 开链机器人举例</h2><p>下面以在重力作用下的—个 $2R$ 开链机器人为例推导动力学方程，如下图所示</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220315193736585.png" alt="image-20220315193736585" style="zoom:80%;"></p><p>将关节坐标 $\theta =(\theta_{1},\theta_{2})$ 选做广义坐标，广义力 $\tau =(\tau_{1},\tau_{2})$ 则对应于关节力矩（因为 $\tau^T\dot{\theta}$ 对应于功率）。本例中的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 可以写成如下分量形式:</p><script type="math/tex; mode=display">\mathcal{L}(\theta, \dot{\theta})=\sum_{i=1}^{2}\left(\mathcal{K}_{i}-\mathcal{P}_{i}\right)</script><p>则欧拉-拉格朗日方程可以写成如下分量形式（ $\tau$ 为关节力和力矩向量）:</p><script type="math/tex; mode=display">\tau_i = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { \theta_i } } - \frac { \partial { \cal L } } { \partial \theta_i } \qquad i = 1,2  \label{6}</script><p>下面我们需要计算两杆的动能和势能（认为两杆各自的质量 $\mathrm { m }1$ 和 $\mathrm { m }2$ 均集中于各杆末端）</p><p>连杆1质心的位置和速度:</p><script type="math/tex; mode=display">\begin{array}{l}{\left[\begin{array}{l}x_{1} \\y_{1}\end{array}\right]=\left[\begin{array}{c}L_{1} \cos \theta_{1} \\L_{1} \sin \theta_{1}\end{array}\right]} \\{\left[\begin{array}{c}\dot{x}_{1} \\\dot{y}_{1}\end{array}\right]=\left[\begin{array}{r}-L_{1} \sin \theta_{1} \\L_{1} \cos \theta_{1}\end{array}\right] \dot{\theta}_{1}}\end{array}</script><p>连杆2质心的位置和速度:</p><script type="math/tex; mode=display">\begin{array}{l}{\left[\begin{array}{l}x_{2} \\y_{2}\end{array}\right]=\left[\begin{array}{c}L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\end{array}\right]} \\{\left[\begin{array}{l}\dot{x}_{2} \\\dot{y}_{2}\end{array}\right]=\left[\begin{array}{rr}-L_{1} \sin \theta_{1}-L_{2} \sin \left(\theta_{1}+\theta_{2}\right) & -L_{2} \sin \left(\theta_{1}+\theta_{2}\right) \\L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) & L_{2} \cos \left(\theta_{1}+\theta_{2}\right)\end{array}\right]\left[\begin{array}{l}\dot{\theta}_{1} \\\dot{\theta}_{2}\end{array}\right] }\end{array}</script><p>由 $\mathcal{K} =\frac{1}{2} \mathfrak{m} v^2 = \frac{1}{2} \mathfrak{m}(\dot{x}^2 + \dot{y}^2)$ ，连杆的动能项 ${ \cal K }_1$ 和 ${ \cal K }_2$ 分别为</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{K}_{1} &=\frac{1}{2} \mathfrak{m}_{1}\left(\dot{x}_{1}^{2}+\dot{y}_{1}^{2}\right) \\&=\frac{1}{2} \mathfrak{m}_{1} L_{1}^{2} \dot{\theta}_{1}^{2} \\\mathcal{K}_{2} &=\frac{1}{2} \mathfrak{m}_{2}\left(\dot{x}_{2}^{2}+\dot{y}_{2}^{2}\right) \\&=\frac{1}{2} \mathfrak{m}_{2}\left(\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \dot{\theta}_{1}^{2}+2\left(L_{2}^{2}+L_{1} L_{2} \cos \theta_{2}\right) \dot{\theta}_{1} \dot{\theta}_{2}+L_{2}^{2} \dot{\theta}_{2}^{2}\right)\end{aligned}</script><p>势能只取决于高度，即 $y$ 坐标。由 $\mathcal{P} = \mathfrak{m} g y$ ，连杆的势能项 ${ \cal P }_1$ 和 ${ \cal P }_2$ 分别为</p><script type="math/tex; mode=display">\begin{array}{l}\mathcal{P}_{1}=\mathfrak{m}_{1} g y_{1}=\mathfrak{m}_{1} g L_{1} \sin \theta_{1} \\\mathcal{P}_{2}=\mathfrak{m}_{2} g y_{2}=\mathfrak{m}_{2} g\left(L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\right)\end{array}</script><p>将动能项与势能项带入拉格朗日函数 $\eqref{6}$ 即可得到平面 $2R$ 运动链的动力学方程:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\tau_{1}=&\left(\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right)\right) \ddot{\theta}_{1} \\&+\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{2}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\&+\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right), \\\tau_{2}=& \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{1}+\mathfrak{m}_{2} L_{2}^{2} \ddot{\theta}_{2}+\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2} \\&+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) .\end{aligned}\right.</script><p>可以看到，即使是一个简单的 $2R$ 机器人，其逆运动学方程也十分复杂。对上述各项进行整理，得到如下形式的方程:</p><script type="math/tex; mode=display">\tau=M(\theta) \ddot{\theta}+\underbrace{c(\theta, \dot{\theta})+g(\theta)}_{h(\theta, \dot{\theta})}</script><p>式中</p><script type="math/tex; mode=display">\begin{aligned}M(\theta) &=\left[\begin{array}{cc}\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \\\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}L_{2}^{2} \\\end{array}\right] \\c(\theta, \dot{\theta}) &=\left[\begin{array}{c}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2}\end{array}\right] \\g(\theta) &=\left[\begin{array}{c}\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right)\end{array}\right]\end{aligned}</script><p>式中 <strong>$M(\theta)$ 为对称正定的质量矩阵</strong>， <strong>$c(\theta, \dot{\theta})$ 为速度乘积项，包含科里奥利和向心力矩的向量</strong>，其中包含 $\dot{\theta}^2$ 的二次项称为向心项，包含 $\dot{\theta}_{i} \dot{\theta}_{j}(i \ne j)$ 的二次项则称为科里奥利项。 <strong>$g(\theta)$ 为重力项</strong> ，因为此处势能仅来自重力，若末端有弹簧，弹簧也会贡献势能。这些揭示了运动方程是 $\ddot{\theta}$ 的线性函数、 $\dot{\theta}$ 的二次函数、 $\theta$ 的三角函数。上述结论不仅适用于 $2R$ 型机器人，对于包含转动关节的串联运动链也同样适用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="机器人学" scheme="http://www.robotsfan.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
    
    
    <category term="机器人学" scheme="http://www.robotsfan.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>树莓派使用串口</title>
    <link href="http://www.robotsfan.com/posts/dab7fbfc.html"/>
    <id>http://www.robotsfan.com/posts/dab7fbfc.html</id>
    <published>2022-03-15T12:30:00.000Z</published>
    <updated>2022-03-18T12:01:10.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派使用串口"><a href="#树莓派使用串口" class="headerlink" title="树莓派使用串口"></a>树莓派使用串口</h1><p>树莓派默认将 serial0 映射到 外接GPIO的15、16脚。默认将 serial1 映射到 BT蓝牙上。所以如果想要将 ttyAMA0映射到外部 GPIO上，只需要禁用蓝牙，并将 serial0 和serial1 他们链接的对象互换。</p><p>但树莓派4B的更改方式与旧版本不同，终端输入<code>ls -l /dev/serial*</code>，发现只有serial1-&gt;ttyAMA0，没有serial0也没有ttyS0，更没有二者的映射。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>不要去修改<code>config.txt</code>里的配置！！！</strong>网上很多教程<strong>误人子弟</strong>，此文件开头就明确声明了禁止修改，用户的修改均要放置到<code>usercfg.txt</code>中！打开<code>config.txt</code>可以看到这个文件引用了<code>syscfg.txt</code>，这个文件里面写了<code>enable_uart=0</code>，也就是说即便在<code>config.txt</code>中修改了<code>enable_uart=1</code>，下面还是会被重新赋值为<code>enable_uart=0</code>。而<code>usercfg.txt</code>是在<code>syscfg.txt</code>后引用的，所以用户的修改项会覆盖上面的所有配置。</p><p>正确方法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /boot/firmware</span><br><span class="line">sudo vi usercfg.txt</span><br></pre></td></tr></table></figure><p>在里面添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enable_uart=1</span><br><span class="line">dtoverlay=disable-bt</span><br></pre></td></tr></table></figure><p>保存，然后禁用跟蓝牙有关的开机启动项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> bluetooth</span><br></pre></td></tr></table></figure><p>重启树莓派</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>然后再次<code>ls -l /dev/serial*</code>就可以看到正确的映射关系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="小技能" scheme="http://www.robotsfan.com/categories/%E5%B0%8F%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="树莓派" scheme="http://www.robotsfan.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV文档矫正</title>
    <link href="http://www.robotsfan.com/posts/c780224b.html"/>
    <id>http://www.robotsfan.com/posts/c780224b.html</id>
    <published>2022-03-14T02:30:00.000Z</published>
    <updated>2022-03-14T02:27:16.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV文档矫正"><a href="#OpenCV文档矫正" class="headerlink" title="OpenCV文档矫正"></a>OpenCV文档矫正</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将一个斜着拍摄的文档矫正成正的，如图所示：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_origin.jpg" alt="opencv-wendang-image_origin"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_output.jpg" alt="opencv-wendang-image_output"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>读取原始图像，若图像太大可以先进行缩放处理，并获取原始图像的宽和高</li><li>对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</li><li>找到最大的轮廓，并提取角点<ol><li>进行降噪处理：检测轮廓面积，只保留大于阈值面积的轮廓</li><li>计算每个轮廓的周长，使用DP算法计算出轮廓点的个数，规则为周长*0.02</li><li>找到图像中面积最大的，且角点为4的轮廓</li></ol></li><li>将找到的四个角点排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角<ol><li>将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</li><li>将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</li><li>重新排列四个角点</li></ol></li><li>进行透视变换<ol><li>根据变换前及变换后的四个角点，创建变换矩阵</li><li>根据变换矩阵对图像进行透视变换</li></ol></li><li>若透视变换后有一些毛边，按需要进行裁剪，裁剪后重新调整比例<ol><li>创建一个矩形用来裁剪，并设定四周裁剪5像素</li><li>裁剪后重新调整图像宽高</li></ol></li><li>显示变换后图像</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码中均有详细注释，请仔细阅读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些定义</span></span><br><span class="line">Mat image_origin,     <span class="comment">// 原始图像</span></span><br><span class="line">image_gray,       <span class="comment">// 灰度处理后的图像</span></span><br><span class="line">image_blur,       <span class="comment">// 高斯模糊处理后的图像</span></span><br><span class="line">image_canny,      <span class="comment">// 边缘检测后的图像</span></span><br><span class="line">image_dilate,     <span class="comment">// 膨胀后的图像</span></span><br><span class="line">image_erode,      <span class="comment">// 腐蚀后的图像</span></span><br><span class="line">image_preprocess, <span class="comment">// 预处理后的图像</span></span><br><span class="line">image_trans,      <span class="comment">// 透视变换后的图像</span></span><br><span class="line">image_crop;      <span class="comment">// 裁剪后的图像</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; origin_points,  <span class="comment">// 重新排列前的角点</span></span><br><span class="line">  reorder_points; <span class="comment">// 重新排列后的角点</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> origin_width = <span class="number">0</span>, origin_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：预处理，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line"><span class="comment"> * 输入：图像，是否显示(0-不显示 1-显示每一步处理后的图像 2-只显示最终图像)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PreProcess</span><span class="params">(<span class="keyword">const</span> Mat&amp; image, <span class="keyword">int</span> display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 灰度处理</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, image_gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(image_gray, image_blur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边缘检测(边缘检测前对图像进行一次高斯模糊)</span></span><br><span class="line"><span class="built_in">Canny</span>(image_blur, image_canny, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 膨胀和腐蚀(有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀)</span></span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(image_canny, image_dilate, kernel);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="comment">//erode(image_dilate, image_erode, kernel);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示预处理效果</span></span><br><span class="line"><span class="keyword">if</span>(display == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;灰度处理后的图像&quot;</span>, image_gray);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯模糊后的图像&quot;</span>, image_blur);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;边缘检测后的图像&quot;</span>, image_canny);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;膨胀后的图像&quot;</span>, image_dilate);</span><br><span class="line"><span class="comment">//imshow(&quot;腐蚀后的图像&quot;, image_erode);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(display == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;预处理后的图像&quot;</span>, image_dilate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image_dilate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：找到面积最大的轮廓</span></span><br><span class="line"><span class="comment"> * 输入：源图像</span></span><br><span class="line"><span class="comment"> * 输出：最大轮廓的四个角点数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">GetMaxContour</span><span class="params">(<span class="keyword">const</span> Mat&amp; img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment"> * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment"> * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * findContours找到轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment"> * 取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment"> * 取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment"> * 取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment"> * 取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment"> * 取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment"> * 取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment"> * 取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment"> * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * drawContours绘出轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours</span></span><br><span class="line"><span class="comment"> * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//drawContours(image, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">corners_contours</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; biggest_contours;</span><br><span class="line"><span class="keyword">double</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检测轮廓面积</span></span><br><span class="line"><span class="keyword">double</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设图像中有噪声，需要将其过滤，只保留面积大于1000的轮廓</span></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line"><span class="keyword">double</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], corners_contours[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到图像中面积最大的，且角点为4的轮廓</span></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; max_area &amp;&amp; corners_contours[i].<span class="built_in">size</span>() == <span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drawContours(image_origin, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">biggest_contours = &#123; corners_contours[i][<span class="number">0</span>],corners_contours[i][<span class="number">1</span>] ,corners_contours[i][<span class="number">2</span>] ,corners_contours[i][<span class="number">3</span>] &#125;;</span><br><span class="line">max_area = contour_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 只绘制角点之间的边框线，Debug用，取消注释可以看到检测出的所有边界框</span></span><br><span class="line"><span class="comment">//drawContours(image_origin, corners_contours, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(image_origin, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最大的轮廓</span></span><br><span class="line"><span class="keyword">return</span> biggest_contours;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：绘制一些点</span></span><br><span class="line"><span class="comment"> * 输入：点集，颜色</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoints</span><span class="params">(vector&lt;Point&gt; points, <span class="keyword">const</span> Scalar&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(image_origin, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line"><span class="built_in">putText</span>(image_origin, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：重新排列四个角点的顺序</span></span><br><span class="line"><span class="comment"> * 最终顺序为： 0  1</span></span><br><span class="line"><span class="comment"> *   2  3</span></span><br><span class="line"><span class="comment"> *   数组中为左上角-右上角-左下角-右下角</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">ReorderPoints</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Point&gt; newPoints;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV中左上顶点为(0,0)，右为x轴正向，下为y轴正向。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</span></span><br><span class="line">sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line"><span class="comment">// 将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</span></span><br><span class="line">subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新排列</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 0 和的最小值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 1 差的最大值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 2 差的最小值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 3 和的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：</span></span><br><span class="line"><span class="comment"> * 输入：源图像，四个角点的集合(角点的顺序为，左上角-右上角-左下角-右下角)，输出的宽，输出的高</span></span><br><span class="line"><span class="comment"> * 输出：透视变换后的图像</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PerspectiveTrans</span><span class="params">(<span class="keyword">const</span> Mat&amp; img, vector&lt;Point&gt; points, <span class="keyword">float</span> width, <span class="keyword">float</span> height )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 前面经过重新排列，四个角点的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="comment">// 变换后的四个角点</span></span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;width,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,height&#125;,&#123;width,height&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line"><span class="built_in">warpPerspective</span>(img, image_trans, matrix, <span class="built_in">Point</span>(width, height));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image_trans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.读取原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/image_origin.jpg&quot;</span>;</span><br><span class="line">image_origin = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 若图像太大可以先进行缩放处理</span></span><br><span class="line"><span class="comment">//resize(image_origin, image_origin, Size(), 0.5, 0.5);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始图像的宽和高</span></span><br><span class="line">origin_width  = image_origin.<span class="built_in">size</span>().width;</span><br><span class="line">origin_height = image_origin.<span class="built_in">size</span>().height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line">image_preprocess = <span class="built_in">PreProcess</span>(image_origin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找到最大的轮廓，并提取角点</span></span><br><span class="line">origin_points = <span class="built_in">GetMaxContour</span>(image_preprocess);</span><br><span class="line"><span class="comment">//DrawPoints(origin_points, Scalar(0, 0, 255)); // 红色</span></span><br><span class="line"><span class="comment">// 此时发现，角点的顺序不固定，为了后面进行透视变换时与代码中变换后点集的顺序相同，需要将其排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">reorder_points = <span class="built_in">ReorderPoints</span>(origin_points);</span><br><span class="line"><span class="comment">//DrawPoints(reorder_points, Scalar(0, 255, 0)); //绿色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.透视变换</span></span><br><span class="line">image_trans = <span class="built_in">PerspectiveTrans</span>(image_origin, reorder_points, origin_width, origin_height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换后有一些毛边，若需要可以进行裁剪</span></span><br><span class="line"><span class="comment">// 四周裁剪5像素</span></span><br><span class="line"><span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 创建一个矩形用来裁剪</span></span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, origin_width - (<span class="number">2</span> * cropVal), origin_height - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">image_crop = <span class="built_in">image_trans</span>(roi);</span><br><span class="line"><span class="comment">// 裁剪后重新调整比例</span></span><br><span class="line"><span class="built_in">resize</span>(image_crop, image_crop, <span class="built_in">Size</span>(origin_width, origin_height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.显示并输出变换后图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;源图像&quot;</span>, image_origin);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;最终图像&quot;</span>, image_crop);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;res/image_output.jpg&quot;</span>, image_crop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image.jpg" alt="opencv-wendang-image"></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV直方图均衡化</title>
    <link href="http://www.robotsfan.com/posts/ab9acae.html"/>
    <id>http://www.robotsfan.com/posts/ab9acae.html</id>
    <published>2022-03-11T02:35:00.000Z</published>
    <updated>2022-03-11T02:28:34.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV直方图均衡化"><a href="#OpenCV直方图均衡化" class="headerlink" title="OpenCV直方图均衡化"></a>OpenCV直方图均衡化</h1><p>直方图均衡化，是对图像进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。<strong>直方图均衡化适用于增强直方图呈尖峰分布的图像。</strong></p><h2 id="几种图片的的直方图均衡化处理效果"><a href="#几种图片的的直方图均衡化处理效果" class="headerlink" title="几种图片的的直方图均衡化处理效果"></a>几种图片的的直方图均衡化处理效果</h2><h3 id="欠曝"><a href="#欠曝" class="headerlink" title="欠曝"></a>欠曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140221839.png" alt="image-20220308140221839"></p><h3 id="过曝"><a href="#过曝" class="headerlink" title="过曝"></a>过曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140259367.png" alt="image-20220308140259367"></p><p>从上面两个图片可以看到，直方图均衡化对于背景和前景都太亮或者太暗的图像效果较好，而且这是一个可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图。但缺点是直方图均衡化对处理的数据不加选择，它可能会增加背景噪声的对比度并且降低有用信号的对比度；变换后图像的灰度级减少，某些细节消失；某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。</p><p>下面再贴一张Luna的处理图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140434486.png" alt="image-20220308140434486"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直方图均衡化</span></span><br><span class="line"><span class="function">Mat <span class="title">Histogramequalization</span><span class="params">(Mat src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> R[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> G[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rows = src.rows;</span><br><span class="line"><span class="keyword">int</span> cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> sum = rows * cols;</span><br><span class="line"><span class="comment">//统计直方图的RGB分布</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]]++;</span><br><span class="line">G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]]++;</span><br><span class="line">R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建直方图的累计分布方程，用于直方图均衡化</span></span><br><span class="line"><span class="keyword">double</span> val[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">val[<span class="number">0</span>] += B[i];</span><br><span class="line">val[<span class="number">1</span>] += G[i];</span><br><span class="line">val[<span class="number">2</span>] += R[i];</span><br><span class="line">B[i] = val[<span class="number">0</span>] * <span class="number">255</span> / sum;</span><br><span class="line">G[i] = val[<span class="number">1</span>] * <span class="number">255</span> / sum;</span><br><span class="line">R[i] = val[<span class="number">2</span>] * <span class="number">255</span> / sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归一化直方图</span></span><br><span class="line"><span class="function">Mat <span class="title">dst</span><span class="params">(rows, cols, CV_8UC3)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">dst.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]];</span><br><span class="line">dst.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]];</span><br><span class="line">dst.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat luna = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Luna——原始图像&quot;</span>, luna);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Luna——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(luna));</span><br><span class="line"></span><br><span class="line">Mat guobao = <span class="built_in">imread</span>(<span class="string">&quot;./guobao.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;过曝光——原始图像&quot;</span>, guobao);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;过曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(guobao));</span><br><span class="line"></span><br><span class="line">Mat qianbao = <span class="built_in">imread</span>(<span class="string">&quot;./qianbao.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——原始图像&quot;</span>, qianbao);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(qianbao));</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV滤波算法</title>
    <link href="http://www.robotsfan.com/posts/8b4c19c3.html"/>
    <id>http://www.robotsfan.com/posts/8b4c19c3.html</id>
    <published>2022-03-11T02:30:00.000Z</published>
    <updated>2022-03-11T02:28:34.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV滤波算法"><a href="#OpenCV滤波算法" class="headerlink" title="OpenCV滤波算法"></a>OpenCV滤波算法</h1><h2 id="三种滤波的优缺点对比"><a href="#三种滤波的优缺点对比" class="headerlink" title="三种滤波的优缺点对比"></a>三种滤波的优缺点对比</h2><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯滤波适合有高斯噪声的图片。能够很好的抑制图像输入时随机引入的噪声，将像素点跟邻域像素看作是一种高斯分布的关系，它的操作是将图像和一个高斯核进行卷积操作。但是不能很好地抑制椒盐噪声。</p><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值滤波适合有椒盐噪声的图片。将窗口函数里面的所有像素进行排序取得中位数来代表该窗口中心的像素值，对椒盐噪声和脉冲噪声的抑制效果特别好，同时又能保留边缘细节。但是不能很好地抑制高斯噪声。</p><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>把每个像素都用周围的8个像素来做均值操作，幅值近似相等且随机分布在不同位置上，这样可以平滑图像，速度较快，算法简单。但是无法去掉噪声，只能微弱的减弱它。对于椒盐噪声，中值滤波是选择适当的点来替代污染点的值，所以处理效果好，由于椒盐噪声的均值不为0，所以均值滤波不能很好地去除噪声点。</p><h2 id="三种滤波算法对不同噪声的处理"><a href="#三种滤波算法对不同噪声的处理" class="headerlink" title="三种滤波算法对不同噪声的处理"></a>三种滤波算法对不同噪声的处理</h2><p><strong>给经过灰度处理的图像分别加入椒盐噪声、高斯噪声和椒盐高斯噪声，分别使用高斯滤波、中值滤波和均值滤波对图像进行滤波，下面为运行后的效果图：</strong></p><h3 id="添加椒盐噪声"><a href="#添加椒盐噪声" class="headerlink" title="添加椒盐噪声"></a>添加椒盐噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132251591.png" alt="image-20220308132251591"></p><h3 id="添加高斯噪声"><a href="#添加高斯噪声" class="headerlink" title="添加高斯噪声"></a>添加高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132404182.png" alt="image-20220308132404182"></p><h3 id="添加椒盐噪声和高斯噪声"><a href="#添加椒盐噪声和高斯噪声" class="headerlink" title="添加椒盐噪声和高斯噪声"></a>添加椒盐噪声和高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132459737.png" alt="image-20220308132459737"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//生成高斯噪声</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">generate_gause_noise</span><span class="params">(<span class="keyword">double</span> mu, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义小值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epsilon = numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> z0, z1;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">flag = !flag;</span><br><span class="line"><span class="comment">//flag为假构造高斯随机变量X</span></span><br><span class="line"><span class="keyword">if</span> (!flag)</span><br><span class="line"><span class="keyword">return</span> z1 * sigma + mu;</span><br><span class="line"><span class="keyword">double</span> u1, u2;</span><br><span class="line"><span class="comment">//构造随机变量</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">u1 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">u2 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">&#125; <span class="keyword">while</span> (u1 &lt;= epsilon);</span><br><span class="line"><span class="comment">//flag为真构造高斯随机变量</span></span><br><span class="line">z0 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">cos</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line">z1 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">sin</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line"><span class="keyword">return</span> z0*sigma + mu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为图像加入高斯噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_gause_noise</span><span class="params">(Mat&amp; image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> channels = image.<span class="built_in">channels</span>();</span><br><span class="line"><span class="keyword">int</span> rowsNumber = image.rows;</span><br><span class="line"><span class="keyword">int</span> colsNumber = image.cols*channels;</span><br><span class="line"><span class="comment">//推断图像的连续性</span></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">isContinuous</span>())</span><br><span class="line">&#123;</span><br><span class="line">colsNumber *= rowsNumber;</span><br><span class="line">rowsNumber = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsNumber; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colsNumber; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加入高斯噪声</span></span><br><span class="line"><span class="keyword">int</span> val = image.ptr&lt;uchar&gt;(i)[j] + <span class="built_in">generate_gause_noise</span>(<span class="number">3</span>, <span class="number">0.8</span>) * <span class="number">32</span>;</span><br><span class="line"><span class="keyword">if</span> (val &lt; <span class="number">0</span>)</span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (val&gt;<span class="number">255</span>)</span><br><span class="line">val = <span class="number">255</span>;</span><br><span class="line">image.ptr&lt;uchar&gt;(i)[j] = (uchar)val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加椒盐噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_salt_noise</span><span class="params">(Mat&amp; image, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line"><span class="comment">// 灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;uchar&gt;(j, i) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 彩色图像</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line"><span class="comment">// 灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;uchar&gt;(j, i) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 彩色图像</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">median_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> start = win_size/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">vector&lt;uchar&gt; model;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; int(src.at&lt;uchar&gt;(i, j)) &lt;&lt; endl;</span></span><br><span class="line">model.<span class="built_in">push_back</span>(src.at&lt;uchar&gt;(i, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(model.<span class="built_in">begin</span>(), model.<span class="built_in">end</span>());     <span class="comment">//采用快速排序进行</span></span><br><span class="line">src.at&lt;uchar&gt;(m, n) = model[win_size*win_size/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mean_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> start = win_size / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">sum += src.at&lt;uchar&gt;(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum / win_size / win_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成高斯模板</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; <span class="built_in">gause_template</span>(<span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> xcore = size / <span class="number">2</span>, ycore = size / <span class="number">2</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">float</span> base = <span class="number">1.0</span> / <span class="number">2</span> / CV_PI / sigma / sigma;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</span><br><span class="line">vector&lt;<span class="keyword">float</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; size; y++) &#123;</span><br><span class="line"><span class="keyword">float</span> t1 = (<span class="built_in">pow</span>(x - xcore, <span class="number">2</span>) + <span class="built_in">pow</span>(y - ycore, <span class="number">2</span>)) / <span class="number">2.0</span> / sigma / sigma;</span><br><span class="line"><span class="keyword">float</span> temp = base*<span class="built_in">exp</span>(-t1);</span><br><span class="line">v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gause_filter</span><span class="params">(Mat&amp; src, <span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = <span class="built_in">gause_template</span>(sigma,size);</span><br><span class="line"><span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> start = size / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line"><span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; gaussTem[i - m + start][j - n + start] &lt;&lt; endl;</span></span><br><span class="line">sum += src.at&lt;uchar&gt;(i, j)*gaussTem[i-m+start][j-n+start];  <span class="comment">//重点理解！！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flitter my_flitter;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//灰度处理</span></span><br><span class="line"><span class="built_in">cvtColor</span>(src, src,COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;灰度处理过的原始图像&quot;</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//椒盐噪声</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加椒盐噪声</span></span><br><span class="line">Mat src_add_salt_noise;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_add_salt_noise, CV_8UC1);</span><br><span class="line">my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_noise, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐噪声&quot;</span>, src_add_salt_noise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line">Mat Trans_Median = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line">Mat Trans_Mean = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Mat Trans_Gause = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯噪声</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加高斯噪声</span></span><br><span class="line">Mat src_add_gause_noise;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_add_gause_noise, CV_8UC1);</span><br><span class="line">my_flitter.<span class="built_in">add_gause_noise</span>(src_add_gause_noise);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;添加高斯噪声&quot;</span>, src_add_gause_noise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line">Mat Trans_Median = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line">Mat Trans_Mean = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Mat Trans_Gause = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//椒盐+高斯噪声</span></span><br><span class="line">&#123;</span><br><span class="line">Mat src_add_salt_and_gause_noise;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_add_salt_and_gause_noise, CV_8UC1);</span><br><span class="line"><span class="comment">//添加椒盐噪声</span></span><br><span class="line">my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_and_gause_noise, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">//添加高斯噪声</span></span><br><span class="line">my_flitter.<span class="built_in">add_gause_noise</span>(src_add_salt_and_gause_noise);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐+高斯噪声&quot;</span>, src_add_salt_and_gause_noise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line">Mat Trans_Median = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line">Mat Trans_Mean = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Mat Trans_Gause = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>透视变换MATLAB仿真，OpenCV验证</title>
    <link href="http://www.robotsfan.com/posts/bc853aec.html"/>
    <id>http://www.robotsfan.com/posts/bc853aec.html</id>
    <published>2022-03-11T02:25:00.000Z</published>
    <updated>2022-03-11T02:28:34.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="透视变换MATLAB仿真，OpenCV验证"><a href="#透视变换MATLAB仿真，OpenCV验证" class="headerlink" title="透视变换MATLAB仿真，OpenCV验证"></a>透视变换MATLAB仿真，OpenCV验证</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220311102049452.png" alt="image-20220311102049452"></p><h2 id="Matlab仿真"><a href="#Matlab仿真" class="headerlink" title="Matlab仿真"></a>Matlab仿真</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原图像的四个顶点分别左乘变换矩阵，并对其归一化。然后使用一个矩形将这个四边形框在内，矩形的选取规则为：左下顶点为所有xy的最小值，右上顶点为所有xy的最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 原图像F的四个顶点坐标</span></span><br><span class="line">x0y0 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line">xnyn = [<span class="number">640</span>;<span class="number">480</span>;<span class="number">1</span>];</span><br><span class="line">x0yn = [<span class="number">0</span>;<span class="number">480</span>;<span class="number">1</span>];</span><br><span class="line">xny0 = [<span class="number">640</span>;<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 变换矩阵</span></span><br><span class="line">A = [<span class="number">6.01</span> <span class="number">-1.65</span> <span class="number">537</span>;<span class="number">0.188</span> <span class="number">2.88</span> <span class="number">554</span>;<span class="number">0.000584</span> <span class="number">-0.000620</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 计算透视变换后图像的四个顶点坐标</span></span><br><span class="line">toushi_x0y0 = (A * x0y0) / (A(<span class="number">3</span>,<span class="number">1</span>) * x0y0(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * x0y0(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_xnyn = (A * xnyn) / (A(<span class="number">3</span>,<span class="number">1</span>) * xnyn(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * xnyn(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_x0yn = (A * x0yn) / (A(<span class="number">3</span>,<span class="number">1</span>) * x0yn(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * x0yn(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_xny0 = (A * xny0) / (A(<span class="number">3</span>,<span class="number">1</span>) * xny0(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * xny0(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 画图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 原图像（黑色）</span></span><br><span class="line"><span class="built_in">plot</span>(x0y0(<span class="number">1</span>,<span class="number">1</span>),x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(x0yn(<span class="number">1</span>,<span class="number">1</span>),x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(xnyn(<span class="number">1</span>,<span class="number">1</span>),xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(xny0(<span class="number">1</span>,<span class="number">1</span>),xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([x0y0(<span class="number">1</span>,<span class="number">1</span>),x0yn(<span class="number">1</span>,<span class="number">1</span>)],[x0y0(<span class="number">2</span>,<span class="number">1</span>),x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([x0yn(<span class="number">1</span>,<span class="number">1</span>),xnyn(<span class="number">1</span>,<span class="number">1</span>)],[x0yn(<span class="number">2</span>,<span class="number">1</span>),xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([xnyn(<span class="number">1</span>,<span class="number">1</span>),xny0(<span class="number">1</span>,<span class="number">1</span>)],[xnyn(<span class="number">2</span>,<span class="number">1</span>),xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([xny0(<span class="number">1</span>,<span class="number">1</span>),x0y0(<span class="number">1</span>,<span class="number">1</span>)],[xny0(<span class="number">2</span>,<span class="number">1</span>),x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 变换后图像（蓝色）</span></span><br><span class="line"><span class="built_in">plot</span>(toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>)],[toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>)],[toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">1</span>,<span class="number">1</span>)],[toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>)],[toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用一个矩形框起来（绿色）</span></span><br><span class="line">all_x = [toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>)];</span><br><span class="line">all_y = [toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>)];</span><br><span class="line">new_x0y0 = [<span class="built_in">min</span>(all_x);<span class="built_in">min</span>(all_y)]</span><br><span class="line">new_x0yn = [<span class="built_in">min</span>(all_x);<span class="built_in">max</span>(all_y)];</span><br><span class="line">new_xnyn = [<span class="built_in">max</span>(all_x);<span class="built_in">max</span>(all_y)]</span><br><span class="line">new_xny0 = [<span class="built_in">max</span>(all_x);<span class="built_in">min</span>(all_y)];</span><br><span class="line"><span class="built_in">plot</span>(new_x0y0(<span class="number">1</span>,<span class="number">1</span>),new_x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_x0yn(<span class="number">1</span>,<span class="number">1</span>),new_x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_xnyn(<span class="number">1</span>,<span class="number">1</span>),new_xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_xny0(<span class="number">1</span>,<span class="number">1</span>),new_xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_x0y0(<span class="number">1</span>,<span class="number">1</span>),new_x0yn(<span class="number">1</span>,<span class="number">1</span>)],[new_x0y0(<span class="number">2</span>,<span class="number">1</span>),new_x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_x0yn(<span class="number">1</span>,<span class="number">1</span>),new_xnyn(<span class="number">1</span>,<span class="number">1</span>)],[new_x0yn(<span class="number">2</span>,<span class="number">1</span>),new_xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_xnyn(<span class="number">1</span>,<span class="number">1</span>),new_xny0(<span class="number">1</span>,<span class="number">1</span>)],[new_xnyn(<span class="number">2</span>,<span class="number">1</span>),new_xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_xny0(<span class="number">1</span>,<span class="number">1</span>),new_x0y0(<span class="number">1</span>,<span class="number">1</span>)],[new_xny0(<span class="number">2</span>,<span class="number">1</span>),new_x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%输出G的尺寸</span></span><br><span class="line">delta_x = <span class="built_in">max</span>(all_x) - <span class="built_in">min</span>(all_x)</span><br><span class="line">delta_y = <span class="built_in">max</span>(all_y) - <span class="built_in">min</span>(all_y)</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>运行代码，输出图像，下图中<strong>黑色矩形</strong>为原图像F，<strong>蓝色矩形</strong>为透视变换后的图像，<strong>绿色矩形</strong>是用矩形框起来的最终图像G：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308173653334.png" alt="image-20220308173653334" style="zoom:67%;"></p><p>同时MATLAB控制台输出<strong>delta_x = 3.7003e+03</strong>，<strong>delta_y = 2.2660e+03</strong></p><p>也就是说经过透视变换后的图像G的尺寸为<strong>3700.3*2266</strong></p><h2 id="OpenCV验证"><a href="#OpenCV验证" class="headerlink" title="OpenCV验证"></a>OpenCV验证</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>随便选取一张图片，将其拉伸到640*480，再对其进行上述变换矩阵指定的透视变换，最后输出图片。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伸缩图片至640*480</span></span><br><span class="line">Mat imgResize;</span><br><span class="line"><span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">640</span>,<span class="number">480</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变换前与变换后的顶点坐标</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">640</span>,<span class="number">480</span>&#125;,&#123;<span class="number">0</span>,<span class="number">480</span>&#125;,&#123;<span class="number">640</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">537.0f</span>,<span class="number">554.0f</span>&#125;,&#123;<span class="number">3337.2f</span>,<span class="number">1911.2f</span>&#125;,&#123;<span class="number">-363.0f</span>,<span class="number">2756.8</span>&#125;,&#123;<span class="number">3190.8</span>,<span class="number">490.9</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line">Mat imgWarp;</span><br><span class="line"><span class="built_in">warpPerspective</span>(imgResize, imgWarp, matrix, <span class="built_in">Size</span>(<span class="number">4000</span>, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记原始图像位置</span></span><br><span class="line"><span class="built_in">rectangle</span>(imgWarp, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">640</span>, <span class="number">480</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line"><span class="built_in">putText</span>(imgWarp, <span class="string">&quot;Origin Image&quot;</span>, <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>), FONT_HERSHEY_COMPLEX, <span class="number">2</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变换后图像</span></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;res/output.jpg&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>下图中左上角为原始图像（合并显示有点麻烦所以只画了一个跟原始图像一样大的白色矩形代替）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/output.jpg" alt="output" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</title>
    <link href="http://www.robotsfan.com/posts/b5b2ecfc.html"/>
    <id>http://www.robotsfan.com/posts/b5b2ecfc.html</id>
    <published>2022-03-11T02:00:00.000Z</published>
    <updated>2022-03-11T02:28:34.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"><a href="#OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道" class="headerlink" title="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"></a>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGB_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mat RGB_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line"><span class="function">Mat* <span class="title">Set_RGB_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line"><span class="function">Mat <span class="title">Get_R</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_G</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_B</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//HSV类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSV_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mat HSV_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line"><span class="function">Mat* <span class="title">Set_HSV_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line"><span class="function">Mat <span class="title">Get_V</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_S</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_H</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//彩色图片的读取</span></span><br><span class="line">Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//RGB三通道分离并显示</span></span><br><span class="line">RGB_Channels my_rgb;</span><br><span class="line"><span class="built_in">split</span>(image,my_rgb.<span class="built_in">Set_RGB_Color_Channels</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;R&quot;</span>,my_rgb.<span class="built_in">Get_R</span>());</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;G&quot;</span>,my_rgb.<span class="built_in">Get_G</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;B&quot;</span>,my_rgb.<span class="built_in">Get_B</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB转HSV</span></span><br><span class="line">Mat image_hsv;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, image_hsv, COLOR_BGR2HSV_FULL);</span><br><span class="line"><span class="comment">//HSV三通道分离并显示</span></span><br><span class="line">HSV_Channels my_hsv;</span><br><span class="line"><span class="built_in">split</span>(image_hsv,my_hsv.<span class="built_in">Set_HSV_Color_Channels</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;H&quot;</span>,my_hsv.<span class="built_in">Get_H</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;S&quot;</span>,my_hsv.<span class="built_in">Get_S</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;V&quot;</span>,my_hsv.<span class="built_in">Get_V</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/8f0ffc2404d1a1957390a20f6bb47673.png" alt="image-20220302161619338"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记</title>
    <link href="http://www.robotsfan.com/posts/404e593e.html"/>
    <id>http://www.robotsfan.com/posts/404e593e.html</id>
    <published>2022-03-09T09:30:00.000Z</published>
    <updated>2022-03-09T09:18:02.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><h2 id="1-导入图像视频和网络摄像头"><a href="#1-导入图像视频和网络摄像头" class="headerlink" title="1 导入图像视频和网络摄像头"></a>1 导入图像视频和网络摄像头</h2><p>首先包含三个常用的头文件和IO库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后需要使用命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h3 id="1-1-图像"><a href="#1-1-图像" class="headerlink" title="1.1 图像"></a>1.1 图像</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 首先需要定义图像文件路径，使用string类型来存储</span></span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">    <span class="comment">// 用Mat类型读取图像</span></span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;图像&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 使用waitKey进行一个延时，否则图像会立即关闭。0为无穷大，即不会关闭。</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-视频"><a href="#1-2-视频" class="headerlink" title="1.2 视频"></a>1.2 视频</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 首先需要定义视频文件路径，使用string类型来存储</span></span><br><span class="line">string path = <span class="string">&quot;res/test_video.mp4&quot;</span>;</span><br><span class="line"><span class="comment">// 构造VideoCapture类型对象</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line"><span class="comment">// 单帧图像</span></span><br><span class="line">Mat img;</span><br><span class="line"><span class="comment">// 对于视频来说需要捕获所有帧并显示，所以需要while循环。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取一帧图像</span></span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"><span class="comment">// 显示图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;视频&quot;</span>, img);</span><br><span class="line"><span class="comment">// 这时需要延时，否则视频非常快</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视频结束后会抛出错误（无法读取文件），原因为视频结束后没有图像送入img所以报错。</p><h3 id="1-3-摄像头"><a href="#1-3-摄像头" class="headerlink" title="1.3 摄像头"></a>1.3 摄像头</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 摄像头不需要路径，需要输入相机的ID号，剩下的和读取视频一样</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line">Mat img;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;摄像头&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基本函数"><a href="#2-基本函数" class="headerlink" title="2 基本函数"></a>2 基本函数</h2><p>前文包含的头文件<code>#include &lt;opencv2/imgproc.hpp&gt;</code>就是图像处理的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">Mat imgGray;</span><br><span class="line"><span class="comment">// “convert”，即为转换图像的颜色空间，这里将彩色图想转换为灰度图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line"></span><br><span class="line">Mat imgBlur;</span><br><span class="line"><span class="comment">// 添加高斯模糊(7*7)</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line"></span><br><span class="line">Mat imgCanny;</span><br><span class="line"><span class="comment">// 边缘检测，通常在边缘检测前对图像进行一次高斯模糊(可以自行对比有什么区别)</span></span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀</span></span><br><span class="line">Mat imgDil, imgErode;</span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgDil);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Erode&quot;</span>, imgErode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122257889.png" alt="image-20220309122257889"></p><h2 id="3-对图像进行伸缩和剪裁"><a href="#3-对图像进行伸缩和剪裁" class="headerlink" title="3 对图像进行伸缩和剪裁"></a>3 对图像进行伸缩和剪裁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伸缩</span></span><br><span class="line">Mat imgResize;</span><br><span class="line"><span class="comment">// 使用size方法查看图像尺寸</span></span><br><span class="line">cout &lt;&lt; img.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 可以调整成具体的大小</span></span><br><span class="line"><span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">400</span>,<span class="number">600</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Resize Size()&quot;</span>, imgResize);</span><br><span class="line"><span class="comment">// 也可以调整缩放比例fxfy</span></span><br><span class="line"><span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(),<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Resize &quot;</span>, imgResize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪</span></span><br><span class="line">Mat imgCrop;</span><br><span class="line"><span class="comment">// 矩形数据类型，前两个参数为剪裁起点（左上角 x = 0, y = 0），后两个参数为宽和高</span></span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(<span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"><span class="comment">// 使用刚刚定义的矩形对图像进行裁剪</span></span><br><span class="line">imgCrop = <span class="built_in">img</span>(roi);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122213509.png" alt="image-20220309122213509"></p><h2 id="4-绘制形状和文字"><a href="#4-绘制形状和文字" class="headerlink" title="4 绘制形状和文字"></a>4 绘制形状和文字</h2><p>下文中，使用Point()定义一个点，使用Scalar()定义一个标量（颜色）</p><p>绘制形状和文字所用函数中最后两个参数均为颜色和厚度(FILLED为填充)，不再重复说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建一个空白图像，512*512大小，8位3通道(CV_8UC3)，白色(255,255,255)</span></span><br><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">512</span>, <span class="number">512</span>, CV_8UC3, Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画圆 传入圆心，半径</span></span><br><span class="line"><span class="built_in">circle</span>(img, <span class="built_in">Point</span>(<span class="number">256</span>, <span class="number">256</span>), <span class="number">155</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),FILLED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画矩形 传入左上角与右下角点的坐标</span></span><br><span class="line"><span class="built_in">rectangle</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">226</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">286</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画线 传入起点和终点的坐标</span></span><br><span class="line"><span class="built_in">line</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">296</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">296</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文字 传入文字，左上角坐标，字体，比例</span></span><br><span class="line"><span class="built_in">putText</span>(img, <span class="string">&quot;OpenCV Learning&quot;</span>, <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">262</span>), FONT_HERSHEY_COMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122144678.png" alt="image-20220309122144678"></p><h2 id="5-透视变换"><a href="#5-透视变换" class="headerlink" title="5 透视变换"></a>5 透视变换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/cards.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用画图工具获取到点坐标，使用Point2f创建浮点数</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>,<span class="number">142</span>&#125;,&#123;<span class="number">771</span>,<span class="number">190</span>&#125;,&#123;<span class="number">405</span>,<span class="number">395</span>&#125;,&#123;<span class="number">674</span>,<span class="number">457</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变换后的大小</span></span><br><span class="line"><span class="keyword">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line">Mat imgWarp;</span><br><span class="line"><span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Size</span>(w, h));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示四个顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，成功将图形矫正</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122100872.png" alt="image-20220309122100872"></p><h2 id="6-颜色识别"><a href="#6-颜色识别" class="headerlink" title="6 颜色识别"></a>6 颜色识别</h2><p>颜色识别需要设定选取好的hsv三个通道的最大值和最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/lambo.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">Mat imgHSV;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义选取好的六个值</span></span><br><span class="line"><span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line"><span class="keyword">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// 定义下限和上限</span></span><br><span class="line"><span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line"><span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建遮罩</span></span><br><span class="line">Mat mask;</span><br><span class="line"><span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行查看效果</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121922828.png" alt="image-20220309121922828"></p><p>上面的值可以使用Trackbar试出来，替换一张图片再次尝试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">Mat imgHSV;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定初始值</span></span><br><span class="line"><span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">0</span>, vmin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hmax = <span class="number">179</span>, smax = <span class="number">255</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建遮罩</span></span><br><span class="line">Mat mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义窗口名</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line"><span class="comment">// 创建Trackbar</span></span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line"><span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line"><span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始值是这样的</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121750288.png" alt="image-20220309121750288"></p><p>因为这张图里都是确定的颜色，所以只需要拖动前两行即可筛选出想要的颜色</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121842503.png" alt="image-20220309121842503"></p><h2 id="7-形状识别"><a href="#7-形状识别" class="headerlink" title="7 形状识别"></a>7 形状识别</h2><p>本节将学习如何检测圆形、正方形、矩形、三角形这些形状，和识别出图像中的轮廓</p><h3 id="7-1-预处理"><a href="#7-1-预处理" class="headerlink" title="7.1 预处理"></a>7.1 预处理</h3><p>首先对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。详见</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在识别形状之前需要对图片进行一系列的预处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 灰度处理</span></span><br><span class="line">Mat imgGray;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊</span></span><br><span class="line">Mat imgBlur;</span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边缘检测</span></span><br><span class="line">Mat imgCanny;</span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 膨胀和腐蚀</span></span><br><span class="line">Mat imgDil, imgErode;</span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//// 在这里进行边缘检测</span></span><br><span class="line"><span class="comment">//getContours(imgDil,img);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Dil&quot;</span>, imgDil);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从处理后的图像可以看到，单单使用边缘检测，三角形的轮廓线断断续续，会对之后的识别造成影响。经过膨胀之后的图像轮廓线是实线，边缘特性更好。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309144348598.png" alt="image-20220309144348598"></p><p>关闭主函数中无用的输出，只留下<code>imshow(&quot;Image&quot;, img);</code>，然后去除<code>getContours(imgDil,img);</code>的注释，再进行下一步。</p><h3 id="7-2-找到轮廓"><a href="#7-2-找到轮廓" class="headerlink" title="7.2 找到轮廓"></a>7.2 找到轮廓</h3><p>根据边缘找到轮廓</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment"> * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment"> * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment"> * 取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment"> * 取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment"> * 取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment"> * 取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment"> * 取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment"> * 取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment"> * 取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment"> * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours</span></span><br><span class="line"><span class="comment"> * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">drawContours</span>(img_output, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，图像轮廓被正确地识别出来了。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309134724054.png" alt="image-20220309134724054"></p><h3 id="7-3-去除噪声"><a href="#7-3-去除噪声" class="headerlink" title="7.3 去除噪声"></a>7.3 去除噪声</h3><p>假设图像中最小的黑色圆圈为噪声，我们要将其滤除，所以需要判断轮廓大小并对其筛选。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设图像中有噪声，需要将其过滤</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//检测轮廓大小</span></span><br><span class="line"><span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">cout &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">drawContours</span>(img_output, contours, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，黑色噪声成功被滤除</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309135058081.png" alt="image-20220309135058081"></p><h3 id="7-4-识别形状"><a href="#7-4-识别形状" class="headerlink" title="7.4 识别形状"></a>7.4 识别形状</h3><p>下一步我们要找到这些轮廓的角点，并对角点的数量进行判断，例如三角形就是3，四边形就是4，圆形可能七八个，并同时绘制出边界框与形状名称。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//drawContours(img_output, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图形形状字符串</span></span><br><span class="line">string object_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line"><span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出边界框</span></span><br><span class="line">bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过判断角点的数量来确定是什么形状</span></span><br><span class="line"><span class="keyword">int</span> object_corners = (<span class="keyword">int</span>)contours_corners[i].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(object_corners == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Triangle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(object_corners == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 通过计算宽高比来区分正方形和矩形</span></span><br><span class="line"><span class="keyword">float</span> aspect_ratio = (<span class="keyword">float</span>)bounding_box[i].width / (<span class="keyword">float</span>)bounding_box[i].height;</span><br><span class="line">cout &lt;&lt; aspect_ratio &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 宽高比在0.95~1.05范围内算作正方形</span></span><br><span class="line"><span class="keyword">if</span> (aspect_ratio &gt; <span class="number">0.95</span> &amp;&amp; aspect_ratio &lt; <span class="number">1.05</span>)</span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余的算作矩形</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(object_corners &gt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只绘制角点之间的边框线</span></span><br><span class="line"><span class="built_in">drawContours</span>(img_output, contours_corners, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 绘制矩形，bounding_box[i].tl()左上角，bounding_box[i].br()右下角</span></span><br><span class="line"><span class="built_in">rectangle</span>(img_output, bounding_box[i].<span class="built_in">tl</span>(), bounding_box[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 绘制文字（什么形状），绘制在边框的左上角再往上5像素</span></span><br><span class="line"><span class="built_in">putText</span>(img_output, object_type, <span class="built_in">Point</span>(bounding_box[i].x, bounding_box[i].y - <span class="number">5</span> ), FONT_HERSHEY_PLAIN, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不同形状的物体被成功识别出。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309143927287.png" alt="image-20220309143927287"></p><h2 id="8-人脸检测"><a href="#8-人脸检测" class="headerlink" title="8 人脸检测"></a>8 人脸检测</h2><p>人脸检测需要包含<code>#include &lt;opencv2/objdetect.hpp&gt;</code>头文件</p><p>使用OpenCV自带的Haar特征分类器进行检测。Haar特征分类器就是一个XML文件，该文件中会描述人体各个部位的Haar特征值。包括人脸、眼睛、嘴唇等等。通常被放置在一个叫haarcascades的目录下（全盘搜索一下就能找到），有以下这些：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309152132992.png" alt="image-20220309152132992"></p><p>根据命名可以知道各个分类器的用途。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/face.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写级联分类器</span></span><br><span class="line">CascadeClassifier faceCascade;</span><br><span class="line"><span class="comment">// 加载训练好的模型（族特征数据库）这里的路径请自行修改</span></span><br><span class="line">faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个矩形向量</span></span><br><span class="line">vector&lt;Rect&gt; faces;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 族检测算法</span></span><br><span class="line"><span class="comment"> * 参数1：image--待检测图片，一般为灰度图像加快检测速度；</span></span><br><span class="line"><span class="comment"> * 参数2：objects--被检测物体的矩形框向量组；</span></span><br><span class="line"><span class="comment"> * 参数3：scaleFactor--表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%;</span></span><br><span class="line"><span class="comment"> * 参数4：minNeighbors--表示构成检测目标的相邻矩形的最小个数(默认为3个)。</span></span><br><span class="line"><span class="comment"> * 如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。</span></span><br><span class="line"><span class="comment"> * 如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，</span></span><br><span class="line"><span class="comment"> * 这种设定值一般用在用户自定义对检测结果的组合程序上；</span></span><br><span class="line"><span class="comment"> * 参数5：flags--要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING</span></span><br><span class="line"><span class="comment"> * 如果设置为CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域，因此这些区域通常不会是人脸所在区域；</span></span><br><span class="line"><span class="comment"> * 参数6、7：minSize和maxSize用来限制得到的目标区域的范围。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在脸四周画出矩形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到成功检测到人脸</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309153539038.png" alt="image-20220309153539038"></p><p>同样地，可以对视频流进行同样的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">CascadeClassifier faceCascade;</span><br><span class="line">faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Rect&gt; faces;</span><br><span class="line">faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面演示三个应用</p><h2 id="应用1-空间绘图"><a href="#应用1-空间绘图" class="headerlink" title="应用1 空间绘图"></a>应用1 空间绘图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////  Project 1 - 虚拟绘图 //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints;  <span class="comment">// to store all points</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////  颜色定义 ////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用前面讲过的程序提取颜色</span></span><br><span class="line"><span class="comment">// hmin, smin, vmin hmax, smax, vmax</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; myColors&#123; &#123;<span class="number">95</span>,<span class="number">22</span>,<span class="number">49</span>,<span class="number">139</span>,<span class="number">138</span>,<span class="number">92</span>&#125;, <span class="comment">// Green</span></span><br><span class="line">  &#123;<span class="number">144</span>,<span class="number">76</span>,<span class="number">63</span>,<span class="number">179</span>,<span class="number">166</span>,<span class="number">154</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line">vector&lt;Scalar&gt; myColorValues&#123; &#123;<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>&#125;,<span class="comment">// Green</span></span><br><span class="line">  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">getContours</span><span class="params">(Mat img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义笔头位置</span></span><br><span class="line"><span class="function">Point <span class="title">myPoint</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定笔头位置为设定点</span></span><br><span class="line">myPoint.x = bounding_box[i].x + bounding_box[i].width / <span class="number">2</span>;</span><br><span class="line">myPoint.y = bounding_box[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 显示角和边界框</span></span><br><span class="line"><span class="comment">//drawContours(img, contours_corners, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(img, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> myPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findColor</span>(Mat img)</span><br><span class="line">&#123;</span><br><span class="line">Mat imgHSV;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myColors.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Scalar <span class="title">lower</span><span class="params">(myColors[i][<span class="number">0</span>], myColors[i][<span class="number">1</span>], myColors[i][<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function">Scalar <span class="title">upper</span><span class="params">(myColors[i][<span class="number">3</span>], myColors[i][<span class="number">4</span>], myColors[i][<span class="number">5</span>])</span></span>;</span><br><span class="line">Mat mask;</span><br><span class="line"><span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="built_in">to_string</span>(i), mask);</span><br><span class="line">Point myPoint = <span class="built_in">getContours</span>(mask);</span><br><span class="line"><span class="keyword">if</span> (myPoint.x != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 每个myPoint都有三个值，xy和颜色序号</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(&#123; myPoint.x,myPoint.y,i &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawOnCanvas</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newPoints.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(img, <span class="built_in">Point</span>(newPoints[i][<span class="number">0</span>],newPoints[i][<span class="number">1</span>]), <span class="number">10</span>, myColorValues[newPoints[i][<span class="number">2</span>]], FILLED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line">newPoints = <span class="built_in">findColor</span>(img);</span><br><span class="line"><span class="built_in">drawOnCanvas</span>(newPoints, myColorValues);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-应用2-文章扫描"><a href="#10-应用2-文章扫描" class="headerlink" title="10 应用2 文章扫描"></a>10 应用2 文章扫描</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 2 - Document Scanner  //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat imgOriginal, imgGray, imgBlur, imgCanny, imgThre, imgDil, imgErode, imgWarp, imgCrop;</span><br><span class="line">vector&lt;Point&gt; initialPoints,docPoints;</span><br><span class="line"><span class="keyword">float</span> w = <span class="number">420</span>, h = <span class="number">596</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">preProcessing</span><span class="params">(Mat img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line"><span class="comment">//erode(imgDil, imgErode, kernel);</span></span><br><span class="line"><span class="keyword">return</span> imgDil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">getContours</span><span class="params">(Mat image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(image, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; biggest;</span><br><span class="line"><span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">string objectType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (area &gt; maxArea &amp;&amp; conPoly[i].<span class="built_in">size</span>()==<span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">biggest = &#123; conPoly[i][<span class="number">0</span>],conPoly[i][<span class="number">1</span>] ,conPoly[i][<span class="number">2</span>] ,conPoly[i][<span class="number">3</span>] &#125;;</span><br><span class="line">maxArea = area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(imgOriginal, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawPoints</span><span class="params">(vector&lt;Point&gt; points, Scalar color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(imgOriginal, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line"><span class="built_in">putText</span>(imgOriginal, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">reorder</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Point&gt; newPoints;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line">subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//0</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//1</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//2</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">getWarp</span><span class="params">(Mat img, vector&lt;Point&gt; points, <span class="keyword">float</span> w, <span class="keyword">float</span> h )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> imgWarp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">string path = <span class="string">&quot;res/paper.jpg&quot;</span>;</span><br><span class="line">imgOriginal = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">resize</span>(imgOriginal, imgOriginal, <span class="built_in">Size</span>(), <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preprpcessing - Step 1</span></span><br><span class="line">imgThre = <span class="built_in">preProcessing</span>(imgOriginal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Contours - Biggest  - Step 2</span></span><br><span class="line">initialPoints = <span class="built_in">getContours</span>(imgThre);</span><br><span class="line"><span class="comment">//drawPoints(initialPoints, Scalar(0, 0, 255));</span></span><br><span class="line">docPoints = <span class="built_in">reorder</span>(initialPoints);</span><br><span class="line"><span class="comment">//drawPoints(docPoints, Scalar(0, 255, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Warp - Step 3</span></span><br><span class="line">imgWarp = <span class="built_in">getWarp</span>(imgOriginal, docPoints, w, h);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Crop - Step 4</span></span><br><span class="line"><span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, w - (<span class="number">2</span> * cropVal), h - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">imgCrop = <span class="built_in">imgWarp</span>(roi);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, imgOriginal);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgThre);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用3-车牌检测"><a href="#应用3-车牌检测" class="headerlink" title="应用3 车牌检测"></a>应用3 车牌检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 3 - 牌照检测 //////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat img;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">CascadeClassifier plateCascade;</span><br><span class="line">plateCascade.<span class="built_in">load</span>(<span class="string">&quot;Resources/haarcascade_russian_plate_number.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (plateCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Rect&gt; plates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line">plateCascade.<span class="built_in">detectMultiScale</span>(img, plates, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plates.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Mat imgCrop = <span class="built_in">img</span>(plates[i]);</span><br><span class="line"><span class="comment">//imshow(to_string(i), imgCrop);</span></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;Resources/Plates/&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;.png&quot;</span>, imgCrop);</span><br><span class="line"><span class="built_in">rectangle</span>(img, plates[i].<span class="built_in">tl</span>(), plates[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04安装OpenCV并配置Clion工程</title>
    <link href="http://www.robotsfan.com/posts/eb0a41f8.html"/>
    <id>http://www.robotsfan.com/posts/eb0a41f8.html</id>
    <published>2022-02-27T02:30:00.000Z</published>
    <updated>2022-02-27T02:37:46.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Ubuntu20-04安装OpenCV并配置Clion工程"><a href="#Ubuntu20-04安装OpenCV并配置Clion工程" class="headerlink" title="Ubuntu20.04安装OpenCV并配置Clion工程"></a>Ubuntu20.04安装OpenCV并配置Clion工程</h1><h2 id="1-OpenCV安装"><a href="#1-OpenCV安装" class="headerlink" title="1 OpenCV安装"></a>1 OpenCV安装</h2><h3 id="1-1-二进制安装"><a href="#1-1-二进制安装" class="headerlink" title="1.1 二进制安装"></a>1.1 二进制安装</h3><p>Ubuntu20.04支持apt二进制安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libopencv-dev python3-opencv</span><br></pre></td></tr></table></figure><p>查看版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import cv2; print(cv2.__version__)&quot;</span></span><br></pre></td></tr></table></figure><p>安装成功返回<code>4.2.0</code></p><h3 id="1-2-源码安装"><a href="#1-2-源码安装" class="headerlink" title="1.2 源码安装"></a>1.2 源码安装</h3><h4 id="1-2-1-安装编译环境和依赖"><a href="#1-2-1-安装编译环境和依赖" class="headerlink" title="1.2.1 安装编译环境和依赖"></a>1.2.1 安装编译环境和依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential cmake git pkg-config libgtk-3-dev \</span><br><span class="line">    libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \</span><br><span class="line">    libxvidcore-dev libx264-dev libjpeg-dev libpng-dev libtiff-dev \</span><br><span class="line">    gfortran openexr libatlas-base-dev python3-dev python3-numpy \</span><br><span class="line">    libtbb2 libtbb-dev libdc1394-22-dev libopenexr-dev \</span><br><span class="line">    libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev</span><br></pre></td></tr></table></figure><h4 id="1-2-2-Clone最新的OpenCV源码"><a href="#1-2-2-Clone最新的OpenCV源码" class="headerlink" title="1.2.2 Clone最新的OpenCV源码"></a>1.2.2 Clone最新的OpenCV源码</h4><p>截止2022.02.27，GitHub更新到OpenCV4.5.5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/opencv_build &amp;&amp; <span class="built_in">cd</span> ~/opencv_build</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure><h4 id="1-2-3-Cmake编译"><a href="#1-2-3-Cmake编译" class="headerlink" title="1.2.3 Cmake编译"></a>1.2.3 Cmake编译</h4><h5 id="1-2-3-1-创建临时目录"><a href="#1-2-3-1-创建临时目录" class="headerlink" title="1.2.3.1 创建临时目录"></a>1.2.3.1 创建临时目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv_build/opencv</span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><h5 id="1-2-3-2-设置编译选项"><a href="#1-2-3-2-设置编译选项" class="headerlink" title="1.2.3.2 设置编译选项"></a>1.2.3.2 设置编译选项</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=ON \</span><br><span class="line">    -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">    -D OPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">    -D OPENCV_EXTRA_MODULES_PATH=~/opencv_build/opencv_contrib/modules \</span><br><span class="line">    -D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure><p>正常应该出现以下提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/vagrant/opencv_build/opencv/build</span><br></pre></td></tr></table></figure><h5 id="1-2-3-3-开始Cmake编译"><a href="#1-2-3-3-开始Cmake编译" class="headerlink" title="1.2.3.3 开始Cmake编译"></a>1.2.3.3 开始Cmake编译</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>注：j后面的数字为处理器内核数，可以使用<code>nproc</code>来查询</p><h4 id="1-2-4-安装OpenCV"><a href="#1-2-4-安装OpenCV" class="headerlink" title="1.2.4 安装OpenCV"></a>1.2.4 安装OpenCV</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="1-2-5-验证安装"><a href="#1-2-5-验证安装" class="headerlink" title="1.2.5 验证安装"></a>1.2.5 验证安装</h4><p>C++</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv4</span><br></pre></td></tr></table></figure><p>返回<code>4.3.0</code></p><p>Python</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import cv2; print(cv2.__version__)&quot;</span></span><br></pre></td></tr></table></figure><p>返回<code>4.3.0-dev</code></p><h2 id="2-Clion工程配置"><a href="#2-Clion工程配置" class="headerlink" title="2 Clion工程配置"></a>2 Clion工程配置</h2><p>新建工程，本文选择C++11标准</p><p>编辑<code>CmakeList.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenCV_Test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(OpenCV_Test main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(OpenCV_Test <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>到运行调试配置中修改工作目录为<code>$ProjectFileDir$</code>（或手动输入当前main.cpp所在目录）</p><p>在工作目录下放置一个图片命名为<code>test.jpg</code></p><p>编写测试程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;OpenCV-Test&quot;</span>,image);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，若配置无误即可显示出图片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技能" scheme="http://www.robotsfan.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Ubuntu" scheme="http://www.robotsfan.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——34关键词const</title>
    <link href="http://www.robotsfan.com/posts/4307fde0.html"/>
    <id>http://www.robotsfan.com/posts/4307fde0.html</id>
    <published>2022-02-20T13:20:00.000Z</published>
    <updated>2022-02-20T13:24:46.767Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——34关键词const"><a href="#深入学习C-——34关键词const" class="headerlink" title="深入学习C++——34关键词const"></a>深入学习C++——34关键词const</h1><p>const是一种“伪”关键词，他不像void int，const对代码的生成不会造成什么影响。它类似于private、public这样的关键词，它是对开发人员写代码强制特定的规则。const是你做出的承诺，它承诺某些东西将是不变的。（这种承诺是可以打破的，你是否遵守承诺取决于你自己，但是请遵守你自己的承诺）</p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>下面演示const最基础的应用场景，const在程序中一般修饰一个需要保持不变的数字，比如<code>MAX_AGE</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line">MAX_AGE = <span class="number">100</span>; <span class="comment">//正确，a的值可以被修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line">MAX_AGE = <span class="number">100</span>; <span class="comment">//错误，const常量不能被修改</span></span><br></pre></td></tr></table></figure><h2 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h2><p>再来讨论一下指针的问题。首先声明一个未被const修饰的整形指针a：（定义<code>int MAX_AGE = 90;</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*a = <span class="number">2</span>;<span class="comment">//可以改变指针指向的内容</span></span><br><span class="line">a = &amp;MAX_AGE;<span class="comment">//可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *a &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure><p>此时在<code>*</code>前加上<code>const</code>，就变成了<strong>常量指针</strong>，意味着不能修改指针指向的内容：</p><p>常量指针有两种写法，<code>const int *</code>和<code>int const *</code>都是可以的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*b = <span class="number">2</span>;<span class="comment">//错误。不可以改变指针指向的内容</span></span><br><span class="line">b = &amp;MAX_AGE;<span class="comment">//可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *b &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure><p>如果在<code>*</code>后加上<code>const</code>，就变成了<strong>指针常量</strong>，意味着指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化：</p><p>指针常量只能写成<code>int * const</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*c = <span class="number">2</span>;<span class="comment">//可以改变指针指向的内容</span></span><br><span class="line">c = &amp;MAX_AGE;<span class="comment">//错误。不可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *c &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure><p>同理，如果写成<code>const int* const d = new int;</code>，即意味着不能改变指针指向的内容，也不能改变指针变量指向的地址。</p><h2 id="类内方法中使用const"><a href="#类内方法中使用const" class="headerlink" title="类内方法中使用const"></a>类内方法中使用const</h2><p>在类中的方法名后加上const，表示方法不会修改任何实际的类，因此不能修改类成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_x, m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        m_x = <span class="number">2</span>;<span class="comment">//错误，不能修改类成员变量</span></span><br><span class="line"><span class="keyword">return</span> m_x;<span class="comment">//只能读不能写</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假如此时有一个函数，使用了常量引用，它保证了函数内不会对这个类做任何的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此时将<code>GetX()</code>方法后的<code>const</code>去掉，上面函数内就不能调用GetX了。因为GetX函数已经不能保证它不会写入Entity了。<strong>常对象只能调用常函数</strong>。所以我们常常会见到函数的两个版本，此时常对象就会调用带有const的那个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所诉，如果你的方法实际上没有修改类或者他们不应该修改类，那就把他们标记成const。否则在有常量引用的情况下就用不了你的方法了。</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——7链接器</title>
    <link href="http://www.robotsfan.com/posts/9823ae96.html"/>
    <id>http://www.robotsfan.com/posts/9823ae96.html</id>
    <published>2022-02-10T07:00:00.000Z</published>
    <updated>2022-02-20T13:24:46.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——7链接器"><a href="#深入学习C-——7链接器" class="headerlink" title="深入学习C++——7链接器"></a>深入学习C++——7链接器</h1><p>从文本形式的源文件到可执行文件中间其实经过了编译和链接两个步骤，本文来讨论一下C++链接器是如何工作的。</p><h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><p>当我们编译好源文件，我们需要通过一个叫做链接的过程。链接的任务是找到每个符号和函数所在的地方，并把它们链接起来。多个翻译单元（一个CPP文件可以理解为一个翻译单元）之间并不互通，我们需要一种方法把这些文件连接起来成一个项目。即使只有一个翻译单元，也需要将main函数连接起来，这就是链接器的主要目的和要做的事情。</p><h2 id="一些常见的链接错误"><a href="#一些常见的链接错误" class="headerlink" title="一些常见的链接错误"></a>一些常见的链接错误</h2><h3 id="未解决的外部符号"><a href="#未解决的外部符号" class="headerlink" title="未解决的外部符号"></a>未解决的外部符号</h3><p>当链接器找不到确切定义时会发生。来看一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，Multiply函数没有被任何函数调用，其中的Log函数虽然被声明了但是并没有并定义。这样依然会报错。虽然我们没有使用Multiply函数，但是在技术上来讲，我们有可能会用到Log函数，所以链接器需要链接到它，所以会报错。但是如果使用static将Multiply函数限制在该文件中使用<code>static void Multiply(int a, int b)</code>，由于我们没有使用该函数，所以不再报错。</p><p>如果一个函数的声明和定义中的输入和返回的数据类型不对应，也会报错。</p><h3 id="有重复的符号"><a href="#有重复的符号" class="headerlink" title="有重复的符号"></a>有重复的符号</h3><p>如果我们的函数或变量具有相同的名字或签名，链接器会不知道该链接哪一个。即使没有申明，两个相同的函数放在不同的文件中，依然会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，如果一个函数需要在其它文件中使用，则要将函数的定义写在cpp中，然后在对应的hpp文件中写上该函数的声明，最后在需要用它的文件中#include这个hpp文件即可避免链接错误。</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——6编译器</title>
    <link href="http://www.robotsfan.com/posts/dac51109.html"/>
    <id>http://www.robotsfan.com/posts/dac51109.html</id>
    <published>2022-02-10T02:00:00.000Z</published>
    <updated>2022-02-20T13:24:46.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——6编译器"><a href="#深入学习C-——6编译器" class="headerlink" title="深入学习C++——6编译器"></a>深入学习C++——6编译器</h1><p>从文本形式的源文件到可执行文件中间其实经过了编译和链接两个步骤，本文来讨论一下C++编译器是如何工作的。</p><p>C++编译器只负责一件事，将文本文件（我们写的代码）转换成称为目标文件的中间格式。这些目标文件可以传递到链接，链接可以做它所有要链接的事情。</p><p>编译器在生成这些目标文件时，首先会预处理代码，这意味着所有的预处理器语句都会先处理。然后进行记号化和解析，将文本转换为编译器真正能够理解和推理的格式。这创建了所谓的抽象语法树。语法树一旦被创建，编译器就可以开始实际生成代码。目标文件中都是机器码，如果进行反汇编，就可以看到相对应的汇编语句。</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——5C++工作原理</title>
    <link href="http://www.robotsfan.com/posts/a6a7cea1.html"/>
    <id>http://www.robotsfan.com/posts/a6a7cea1.html</id>
    <published>2022-02-10T00:00:00.000Z</published>
    <updated>2022-02-20T13:24:46.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——5C-工作原理"><a href="#深入学习C-——5C-工作原理" class="headerlink" title="深入学习C++——5C++工作原理"></a>深入学习C++——5C++工作原理</h1><h2 id="分析main-cpp"><a href="#分析main-cpp" class="headerlink" title="分析main.cpp"></a>分析main.cpp</h2><p>对于一个后缀为<code>.cpp</code>的C++源文件，先来分析一下文件的结构</p><p><code>#</code>符号之后的都是预处理语句（叫预处理的原因为它实际上在编译之前就发生了）。<code>#include</code>的含义是找到&lt;&gt;中的文件，然后将该文件中的所有内容拷贝到现在的文件内。这些被包含的文件称为头文件，在C++中通常以<code>.hpp</code>为后缀。</p><p>来看一个预处理的神奇操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*file2.hpp*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*file1.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;file2.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>这个程序能否成功编译？可以看到main函数是没有右花括号的，但是<code>#include &quot;file2.hpp&quot;</code>这一句将file2中的文件原封不动拷贝到了当前的地方，即补上了一个花括号，所以可以编译成功。</p><p>除了#include，常用的预处理命令还有<code>#if #endif</code>，这一对是这么用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int a = 1;会被编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 1;不会被编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来是main函数。<code>main</code>函数是程序的入口，当运行程序时计算机从这个函数开始执行代码。在这里，main函数的返回类型是int，但是代码中没有返回任何东西，这是因为main函数是特殊的，它不一定需要返回值。没有写return进行返回的话，它会默认返回了0。注意，这只对main函数适用！</p><p><code>&lt;&lt;</code> 符号叫做重载运算符，可以理解为一个函数。</p><h2 id="代码如何编译为二进制文件"><a href="#代码如何编译为二进制文件" class="headerlink" title="代码如何编译为二进制文件"></a>代码如何编译为二进制文件</h2><p>项目中的每一个cpp文件都会被编译，但是头文件不会被编译，头文件的内容在预处理时全部拷贝到了到了cpp中。每一个cpp文件都被编译为object file（目标文件），我们需要将这些文件合并成一个执行文件，链接（Link）会将所有的目标文件合并成一个.exe文件。</p><p>如果在一个文件（比如main.cpp）中使用了另一个文件中的函数，编译会报错，需要在main.cpp中声明那个函数的存在。声明表示这个符号、函数是存在的，去掉函数的结构体后加分号就是函数的声明。声明与定义不同，定义是说明这个函数到底是什么，是函数的函数体。<code>void Log(const char* message);</code>这就是一个声明，其实<code>void Log(const char*);</code>这样写也可以，但习惯上使用前者，会更加清晰。在构建整个项目时，所有.cpp文件都会被编译，链接器会找到正确的Log函数的定义在哪里，如果找不到定义，会报链接错误。</p><p>关于编译器和链接器会单独讲解</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Gitbook</title>
    <link href="http://www.robotsfan.com/posts/d5c8f039.html"/>
    <id>http://www.robotsfan.com/posts/d5c8f039.html</id>
    <published>2022-02-07T12:47:00.000Z</published>
    <updated>2022-02-07T12:48:48.561Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Gitbook"><a href="#Gitbook" class="headerlink" title="Gitbook"></a>Gitbook</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装gitbook"><a href="#安装gitbook" class="headerlink" title="安装gitbook"></a>安装gitbook</h3><p>gitbook基于Node.js，所以要先安装Node.js，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F">官网</a>。</p><p>安装好node后，安装gitbook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g gitbook-cli</span><br><span class="line">//当前目录下安装</span><br><span class="line">npm install gitbook-cli</span><br></pre></td></tr></table></figure><h3 id="检查版本"><a href="#检查版本" class="headerlink" title="检查版本"></a>检查版本</h3><p>安装好之后执行<code>gitbook -V</code>检查版本，不出意外应该会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CLI version: 2.3.2</span><br><span class="line">Installing GitBook 3.2.3</span><br><span class="line">/xxx/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287</span><br><span class="line">      <span class="keyword">if</span> (cb) cb.apply(this, arguments)</span><br><span class="line">                 ^</span><br><span class="line"></span><br><span class="line">TypeError: cb.apply is not a <span class="keyword">function</span></span><br><span class="line">    at /data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18</span><br><span class="line">    at FSReqCallback.oncomplete (fs.js:169:5)</span><br></pre></td></tr></table></figure><p>此时需要进入上面给出的目录，找到polyfills.js，将62-64注释掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs.stat = statFix(fs.stat)</span></span><br><span class="line"><span class="comment">//fs.fstat = statFix(fs.fstat)</span></span><br><span class="line"><span class="comment">//fs.lstat = statFix(fs.lstat)</span></span><br></pre></td></tr></table></figure><p>此时运行<code>gitbook -V</code>不会报错。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>新建一个工程目录，在目录下执行<code>gitbook init</code>，应该又报错了。这是因为node的版本太高了，需要对node进行降级。这里我推荐使用nvm来管理nodeJs的版本。因为我还有使用高版本node的需求，而且降级也挺麻烦的。nvm的<a href="https://github.com/coreybutler/nvm-windows/releases">下载地址</a>，选择nvm-setup.zip，安装时第二个路径要选择nodejs的安装路径。</p><p>查看安装的nodejs版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure><p>安装低版本nodejs，这个版本经测试可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v12.22.3</span><br></pre></td></tr></table></figure><p>等待安装完，切换版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use v12.22.3</span><br></pre></td></tr></table></figure><p>回到工程根目录再次初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure><p>初始化成功，创建了<code>README.md</code>（书籍的介绍）和<code>SUMMARY.md</code>（书籍的目录结构）</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这里拿自动目录插件举例，在工程根目录下创建一个<code>book.json</code>，写入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;summary&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在根目录下执行<code>gitbook install ./</code>即可安装插件。启动服务后这个插件会自动生成目录。下文会讲解如何生成目录。</p><h2 id="加入文章"><a href="#加入文章" class="headerlink" title="加入文章"></a>加入文章</h2><p>在根目录下创建文件夹，以数字和短横线开头：<code>0-Example</code>，同样<code>0-Example</code>下也可以创建子文件夹。每一个文件夹相当于一个目录，子文件夹就是多级目录。</p><p>每一个子文件夹下要有一个命名为<code>0-README.md</code>的文件，用于放置这个目录的简介，其他md文件也要以数字和短横线开头：<code>1-TestPage.md</code></p><h2 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h2><p>加入好文章之后，启动本地服务，前文安装的summary插件会自动生成层级目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure><p>然后在浏览器中打开<a href="http://localhost:4000/，检验你的成果！">http://localhost:4000/，检验你的成果！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="小技能" scheme="http://www.robotsfan.com/categories/%E5%B0%8F%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Gitbook" scheme="http://www.robotsfan.com/tags/Gitbook/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——21~23静态</title>
    <link href="http://www.robotsfan.com/posts/fd77a296.html"/>
    <id>http://www.robotsfan.com/posts/fd77a296.html</id>
    <published>2022-02-07T08:45:00.000Z</published>
    <updated>2022-02-07T09:01:10.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——21-23静态"><a href="#深入学习C-——21-23静态" class="headerlink" title="深入学习C++——21~23静态"></a>深入学习C++——21~23静态</h1><p>static在C++中有两种含义，分为<strong>类和结构体外的静态</strong>和<strong>类和结构体内的静态</strong></p><h2 id="21-类和结构体外的静态"><a href="#21-类和结构体外的静态" class="headerlink" title="21.类和结构体外的静态"></a>21.类和结构体外的静态</h2><p>类和结构体外部的static，意味着你声明为static的符号只在当前文件内部链接，它只对它所在的翻译单元可见。有关翻译单元请看<strong>深入学习C++——6~7编译器和链接器</strong></p><p>新建一个源文件命名为<code>CStatic.cpp</code>，在<code>main.cpp</code>和<code>Cstatic.cpp</code>中同时定义一个变量和一个函数，编译器在链接阶段会报错<code>multiple definition of XXX</code>，这是因为这个变量/函数已经在另一个编译单元中定义了。所以我们不能有两个同名的全局变量/函数。其中一种修改方式是使用<code>extern</code>关键字，extern意味着它会在外部翻译单元中寻找这个变量/函数。我们把<code>main.cpp</code>中的定义加上static，再次编译无报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CStatic.cpp*/</span></span><br><span class="line"><span class="keyword">int</span> Variable = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Function in CStatic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="comment">//int Variable = 5; //multiple definition of Variable</span></span><br><span class="line"><span class="comment">//void Function() //multiple definition of `Function()&#x27;</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;Variable&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> Variable;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span>; <span class="comment">//函数默认都是extern，这里删掉extern也可以编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">std::cout &lt;&lt; Variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是使用<code>static</code>关键字。static的意思是这个变量/函数只会在这个翻译单元内部链接。这有点像在类中定义私有变量/函数，其他所有的翻译单元都不能看到这个变量/函数。链接器在全局作用域下将不会看到这个变量/函数。把<code>CStatic.cpp</code>中的变量与函数均改成静态的，编译会报错，因为他们在main中不可见，跨翻译单元是找不到他的。将main.cpp中的变量和函数修改为全局的，此时编译通过，且输出的是main中定义的变量值和函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CStatic.cpp*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Variable = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Function in CStatic&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"><span class="comment">//extern int Variable; //undefined reference to `Function()&#x27;</span></span><br><span class="line"><span class="comment">//extern void Function(); //undefined reference to `Variable&#x27;</span></span><br><span class="line"><span class="keyword">int</span> Variable = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Function in main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">std::cout &lt;&lt; Variable &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类和结构体外使用静态，意味着当你声明静态函数和静态变量时，它只会在它被声明的C++文件中被“看到”。如果在一个头文件中声明静态变量并将该头文件包含在两个不同的C++文件中，就相当于在两个翻译单元中都声明了那个变量为静态变量。（包含头文件时，编译器会复制所有头文件中的内容到C++文件中）</p><p>为什么要用static？可以类比为什么要在类中用private。当不需要变量是全局变量时，尽可能地用静态变量。因为一旦在全局作用域下声明东西的时候，编译器会跨编译单元进行链接，这个变量在任何地方都可以被使用，可能会导致一些很严重的bug。</p><p>综上，尽可能地标记函数或变量为静态的，除非你真的需要他们跨翻译单元链接。</p><h2 id="22-类和结构体内的静态"><a href="#22-类和结构体内的静态" class="headerlink" title="22.类和结构体内的静态"></a>22.类和结构体内的静态</h2><p>在类和结构体内部定义的静态变量，在类的所有实例中这个变量只有一个实例，这意味着该变量实际上将与类的所有实例共享内存。对于静态函数来说，没有实例会传递给一个静态函数。</p><p>下面用结构体举例子（类也一样，只是因为结构体默认是public的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e1;</span><br><span class="line">e1.num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Entity e2;</span><br><span class="line">e2.num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">e1.<span class="built_in">Print</span>();</span><br><span class="line">e2.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这样会输出2和5。如果将结构体内的x和y变成静态的，会报错<code>undefined reference to ‘Entity::num’</code>，因为x和y要在某个地方被定义，加上<code>int Entity::num;</code>，程序修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Entity::num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e1;</span><br><span class="line">e1.num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Entity e2;</span><br><span class="line">e2.num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">e1.<span class="built_in">Print</span>();</span><br><span class="line">e2.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时运行会输出5和5.这是因为num变量在Entity类的所有实例中只有一个实例，这意味着e1.num和e2.num指向的是相同的内存，所以<code>e1.num</code>和<code>e2.num</code>这样写是没有意义的。可以直接写成<code>Entity::num = 5</code>。这就像是在一个名为Entity的命名空间中创建了一个变量，他们实际上并不属于类，但是他们可以是private的也可以是public的，所以他们仍是类的一部分。但是在应用上来说他们其实和在命名空间中一样。</p><p>静态方法跟静态变量一样，如果将Print也改为静态的，调用时同样需要使用<code>Entity::Print();</code></p><p>但静态方法不能访问非静态变量，将num改为非静态变量，Print保持为静态方法，这时编译会报错<code>error: invalid use of member &#39;Entity::num&#39; in static member function</code>，原因是静态方法没有类实例。每个非静态方法总是会获得当前类的一个实例作为参数，这我们是看不见的，在底层通过隐藏参数发挥作用，而静态方法不会得到那个隐藏参数。类中的静态方法拿到类外面在编译的时候实际上是这个样子的，实际上传进去了一个实例参数，这样就不会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(Entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; e.num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Entity e;</span><br><span class="line">e.num = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Print</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，当你需要跨类使用变量时，类内静态变量将会派上用场。那这么说创建一个全局变量或者静态变量不也一样吗？NO！如果你有一条消息，想要在所有实例之间共享数据，把这个消息变量放在类中是有意义的，因为它在逻辑上跟这个类有关。要想组织好你的代码，最好在类中创建一个静态变量，而不是将全局或者静态变量到处乱写。</p><h2 id="23-局部静态"><a href="#23-局部静态" class="headerlink" title="23.局部静态"></a>23.局部静态</h2><p>局部静态允许我们创建一个变量，它的生存周期基本相当于整个程序的生存期，但是作用范围被限制在这个域中。来看一段程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i++;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见输出为11111。要是想将i每次递增实现输出12345，你的第一反应可能是将i改为全局变量。但是这样做会使每个人都能访问这个变量，如果要避免这个问题，可以在局部作用域下将i声明为static。这样程序也可以输出12345，与全局变量效果相同，但是此时i只是函数作用域下的局部变量。</p><p>使用局部静态的主要作用是可以使代码更干净，我们来看另一个例子。创建一个单例类（单例类是只存在一个实例的类），如果不使用静态局部作用域来创建单例类，就需要创建静态的单例实例，可能是一个指针，并返回一个引用，即为创建的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> Singleton* s_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *s_Instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用局部静态来创建，代码会变得干净很多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里如果没有static，当代码运行到函数右花括号处，即函数作用域结束时，instance就会被销毁。通过添加static，它的生存周期被延长到永远，在第一次调用Get的时候，实际上会构造一个单例实例，接下来它只会返回这个已存在的实例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——18~20类</title>
    <link href="http://www.robotsfan.com/posts/cc7823d2.html"/>
    <id>http://www.robotsfan.com/posts/cc7823d2.html</id>
    <published>2022-02-06T14:05:00.000Z</published>
    <updated>2022-02-07T08:49:29.606Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——18-19类"><a href="#深入学习C-——18-19类" class="headerlink" title="深入学习C++——18~19类"></a>深入学习C++——18~19类</h1><h2 id="18-类的基础认识"><a href="#18-类的基础认识" class="headerlink" title="18.类的基础认识"></a>18.类的基础认识</h2><p>与C语言不同，C++支持面向对象编程，因为C语言没有类、对象这些概念。</p><p>类是对数据和功能组合在一起的一种方法。如果在游戏中需要一些代表角色的东西，就需要一堆变量。如果这时有两个人物，就要把同样的代码复制两份。这样一来代码会非常混乱且重复，难以维护。使用类可以简化，创建一个叫做player的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类的本质是一个类型，可以把他当成其他变量来创建。我们使用<code>Player player;</code>创建一个新变量叫做player，类型为Player。由类这种类型构成的变量称为对象，新的对象变量称为实例。这一句所做的是实例化了一个Player对象。若需给变量赋值，使用<code>player.</code>加变量名即可访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时会报错<code>error: &#39;int Player::x&#39; is private within this context</code>，这是因为x实际上是私有成员。类中的内容有可见性这一说，默认情况下一个类中所有的东西都是私有的（private），意味着只有类中的函数才能访问这些变量。如果需要在类外访问这些变量，我们需要将其设为公有的（public）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时如果需要写一个函数来操作x和y，需要使用引用传递，因为需要修改Player对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(Player&amp; player, <span class="keyword">int</span> xa, <span class="keyword">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">player.x += xa * player.speed;</span><br><span class="line">player.y += ya * player.speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line"><span class="built_in">Move</span>(player, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类实际上也可以包含函数，类内的函数称为方法。将move函数移动到类中，此时不需要传入player对象，因为已经在Player对象中了。所有的<code>player.</code>也都不需要了，他们指的就是当前对象的变量。main函数中使用<code>player.Move(1, -1);</code>来调用方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> xa,<span class="keyword">int</span> ya)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x += xa * speed;</span><br><span class="line">        y += ya * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player player;</span><br><span class="line">player.<span class="built_in">Move</span>(player, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，类允许我们将变量分组到一个类型中，并为这些变量添加功能。类并没有为变量提供什么新功能，不能用一般代码完成的工作用类同样无法完成。类只是提高了我们维护代码的效率。</p><h2 id="19-类与结构体的对比"><a href="#19-类与结构体的对比" class="headerlink" title="19.类与结构体的对比"></a>19.类与结构体的对比</h2><p>结构体（struct）和类（class）基本上没有什么区别，只有一个关于可见度的小区别，class中默认为private，而struct中默认为public。除此之外没有任何区别，C++中存在结构体的原因是为了与C保持向后兼容性。</p><p>什么时候该用结构体？什么时候该用类？从定义上来看，如果你需要类内变量都是private的那就用class，反之用struct。不过从经验上来谈，如果只是想表示一堆数据，那就用结构体。如果需要大量功能且需要继承，那就用类。这只是个人见解，这两者只是在语义上有可见性的区别，没有严格的规定，如何使用全看个人编程风格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="类与结构体的初始化和赋值"><a href="#类与结构体的初始化和赋值" class="headerlink" title="类与结构体的初始化和赋值"></a>类与结构体的初始化和赋值</h2><p>变量的赋值和初始化是不一样的，初始化是在变量定义的时候完成的，是属于变量定义的一部分，赋值是在变量定义完成之后想改变变量值的时候所采取的操作。</p><p>下面拿结构体举例子：</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>如果结构体没有构造函数，可以用<code>指定初始化</code>与<code>顺序初始化</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有构造函数的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始化 注意在c++中，顺序不能变。</span></span><br><span class="line">MyStruct ms = &#123;.x = <span class="number">2</span>, .y = <span class="number">3</span>&#125;;</span><br><span class="line">MyStruct ms = &#123;x:<span class="number">2</span>, y:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序初始化</span></span><br><span class="line">MyStruct ms = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>C++的结构体也可以有构造函数，如果有构造函数则可以用构造函数初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有构造函数的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;x=x;</span><br><span class="line"><span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数初始化</span></span><br><span class="line"><span class="function">MyStruct <span class="title">ms</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次给每一个结构体成员变量进行赋值</span></span><br><span class="line">MyStruct ms;</span><br><span class="line">ms.x = <span class="number">2</span>;</span><br><span class="line">ms.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误！结构体变量的赋值不能采用大括号方式</span></span><br><span class="line">MyStruct ms;</span><br><span class="line">ms = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用现有结构体变量给另一个结构体变量赋值</span></span><br><span class="line">MyStruct ms = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">MyStruct ms1;</span><br><span class="line">ms1 = ms;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体初始化后默认为随机值，初始化后置空用memset</span></span><br><span class="line">MyStruct ms;</span><br><span class="line"><span class="built_in">memset</span>(&amp;ms, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ms));</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>类的内容又多又杂，将会持续更新</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——17引用</title>
    <link href="http://www.robotsfan.com/posts/55bfc346.html"/>
    <id>http://www.robotsfan.com/posts/55bfc346.html</id>
    <published>2022-02-06T08:30:00.000Z</published>
    <updated>2022-02-06T08:30:37.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——17引用"><a href="#深入学习C-——17引用" class="headerlink" title="深入学习C++——17引用"></a>深入学习C++——17引用</h1><p><strong>引用</strong>是一种引用现有变量的方式。与指针不同，指针可以创建空指针，而引用不行。引用必须引用已存在的变量。引用本身不是一个新变量，它不占用内存，没有自己的存储空间。</p><p>我们创建一个变量，并给这个变量创建一个引用。声明引用时需要指定变量类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br></pre></td></tr></table></figure><p>这里的ref就是a的别名，它本身不是一个真正的变量，ref变量实际并不存在，它只存在于代码中。</p><p>此时我们可以给ref赋值，然后输出a的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ref = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>运行程序，可以看到a的值变成了2。</p><p>下面来看一个更复杂的例子。我们创建一个变量递增函数，并在main中调用，把a作为参数传递进去，只是通过值传递给它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，可以看到a的值仍为5，并没有递增。实际上a传入Increment函数后创建了一个全新的变量value且等于a的值，其作用大致等效于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们讲了指针，自然而然可以想到：我们并不直接把a的值传进函数，而是将a的内存地址传进去，然后在函数内寻找这个内存地址上的数据并对其进行操作即可。所以程序修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>* value)</span><span class="comment">//传入一个指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//value++;//错误。这样只会递增value指针的地址，只是把一个指针递增了而已</span></span><br><span class="line"><span class="comment">//*value++;//错误。这样写操作顺序为先递增内存地址再逆向引用</span></span><br><span class="line">(*value)++;<span class="comment">//先逆向引用，再将值自增</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a);<span class="comment">//传入变量的内存地址</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行程序可以看到a的值被成功修改成了6。</p><p>有没有觉得使用指针的时候<code>*</code>和<code>&amp;</code>满天乱飞，本文讲了引用，那我们就通过另一种更为简洁的方法实现以上功能：我们可以用引用代替指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>&amp; value)</span><span class="comment">//传入一个引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;<span class="comment">//这里也不需要逆向引用*了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increment</span>(a);<span class="comment">//只需传递a即可</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，a成功地被修改成了6。</p><p>综上，指针比引用更强大，能用引用的地方也一定能用指针，但是能用引用就用引用，这样会使程序更为简洁和干净。</p><p>不过要注意，声明引用的时候也必须给引用赋值，因为它并不是一个真正的变量，不能为空。并且一旦声明了一个引用，不能改变它引用的东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = b;</span><br><span class="line"><span class="comment">// now a = 8, b = 8</span></span><br></pre></td></tr></table></figure><p>这段程序只是将b的值赋给了a，并没有改变ref引用的东西。如果想要实现这个功能只能使用指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>* ref = &amp;a;</span><br><span class="line">*ref = <span class="number">2</span>;</span><br><span class="line">ref = &amp;b;</span><br><span class="line">*ref = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// now a = 2, b = 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——44智能指针</title>
    <link href="http://www.robotsfan.com/posts/b0f9a474.html"/>
    <id>http://www.robotsfan.com/posts/b0f9a474.html</id>
    <published>2022-02-06T04:17:00.000Z</published>
    <updated>2022-02-06T04:45:10.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——44智能指针"><a href="#深入学习C-——44智能指针" class="headerlink" title="深入学习C++——44智能指针"></a>深入学习C++——44智能指针</h1><p>我们都知道使用new在堆上分配内存，使用delete释放内存，因为它不会自动释放内存。智能指针本质上是一个原始指针的包装类，当创建一个智能指针，它会调用new并为其分配内存，基于这个智能指针，这些内存会在某一时刻自动释放。下面介绍三种智能指针</p><p>使用智能指针的时候要包含memory头文件</p><h2 id="作用域指针unique-ptr"><a href="#作用域指针unique-ptr" class="headerlink" title="作用域指针unique_ptr"></a>作用域指针unique_ptr</h2><p><code>unique_ptr</code>是作用域指针，超出作用域时会被销毁，然后调用delete。<br>我们不能复制一个unique_ptr，因为如果复制一个unique_ptr，那么他们会指向同一个内存块。如果其中一个死了，它会释放那段内存，而指向同一块内存的另一个指针就会指向已经被释放的内存。</p><p>我们首先创建一个类来理解智能指针，类中只包含构造和析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Entity</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Destroyed Entity&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在特定的作用域下创建一个unique_ptr：在main中创建一对大括号，括号内即为空作用域。在里面使用unique_ptr来分配Entity：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样构造会报错，因为unique_ptr的构造函数是explicit的，需要显式调用构造函数，没有构造函数的隐式转换，所以应该：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>; <span class="comment">//正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过更推荐使用下面这种方法！原因是出于异常安全。如果构造函数碰巧抛出异常，使用make_unique会保证你最终得到的不是没有引用的悬空指针，从而造成内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以跟原始指针一样地使用智能指针，比如使用箭头操作符调用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单步调试，可以看到程序在进入作用域{时输出<code>Created Entity</code>，出作用域}时输出<code>Destroyed Entity</code>，即为智能指针的自动创建与销毁。</p><p>如果需要拷贝或共享这个指针，使得这个指针可以被传递到一个函数中或一个类中，unique_ptr将不可用。如果试图复制一个unique_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">std::unique_ptr&lt;Entity&gt; e0 = entity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会报错，因为在unique_ptr的定义中，删除了拷贝构造函数和拷贝构造操作符，因为这是不被允许的。这是为了防止你跳到大坑里，因为其中一个unique_ptr死了，这个堆分配对象的底层内存会被释放，另一个unique_ptr会指向这个不存在的内存。所以出现了共享指针shared_ptr：</p><h2 id="共享指针shared-ptr"><a href="#共享指针shared-ptr" class="headerlink" title="共享指针shared_ptr"></a>共享指针shared_ptr</h2><p>共享指针shared_ptr更牛逼一点，shared_ptr实现的方式实际上取决于编译器和你在编译器中使用的标准库，在大多数情况下，它使用的是引用计数。引用计数基本上是一种方法，可以跟踪你的指针有多少个引用，一旦引用计数达到0，它就会被删除。如果我创建了一个shared_ptr，又创建了另外一个shared_ptr来复制他，此时的引用计数就是2，当第一个shared_ptr死了，引用计数减1变成1，当最后一个shared_ptr也死了，引用计数变为0，这个指针也就会被销毁内存被释放。</p><p>但是不要这样写！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在unique_ptr中不直接调用new的原因是因为异常安全，而在shared_ptr中有所不同。因为shared_ptr需要分配另一块内存，叫做控制块，用来存储引用计数。如果使用new创建一个Entity然后传递给shared_ptr构造函数，那么它必须做两次内存分配：先做一次new Entity的分配，然后是shared_ptr的控制内存块的分配。使用make_shared就可以将两个步骤合起来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shared_ptr可以被复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">std::shared_ptr&lt;Entity&gt; entity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">std::shared_ptr&lt;Entity&gt; e0 = sharedEntity;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们更改一下main函数，创建两个作用域来演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;<span class="comment">//作用域1</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">&#123;<span class="comment">//作用域2</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">e0 = sharedEntity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时SharedEntity已经死亡，但是e0还存活（引用计数为1），所以这里没有调用析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里e0也死亡了（引用计数为0），此时调用析构函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单步调试，进入作用域1时输出<code>Created Entity</code>，此时出作用域2，并没有析构Entity，因为e0还存活，并且持有对该Entity的引用。出作用域1，输出<code>Destroyed Entity</code>，所有的引用此时都消失。</p><h2 id="弱指针weak-ptr"><a href="#弱指针weak-ptr" class="headerlink" title="弱指针weak_ptr"></a>弱指针weak_ptr</h2><p>将一个shared_ptr赋值给另一个shared_ptr时会增加引用计数，但是将一个shared_ptr赋值给一个weak_ptr时不会增加引用计数。这常用于：如果你不想要Entity的所有权，例如你在排序一个Entity列表，你不关心他们是否有效，只需要存储一个他们的引用，这时就可以使用weak_ptr。可以询问weak_ptr底层对象是否还存活，但它不会保持底层对象存活，因为它不会增加引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;<span class="comment">//作用域1</span></span><br><span class="line">std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">&#123;<span class="comment">//作用域2</span></span><br><span class="line">std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;();</span><br><span class="line">e0 = sharedEntity; <span class="comment">// 弱指针不会引用计数</span></span><br><span class="line">&#125;<span class="comment">//出作用域2的时候就调用了析构函数</span></span><br><span class="line"><span class="comment">//此时weak_ptr为一个无效指针</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>综上，使用智能指针可以使内存管理自动化，防止忘记调用delete而造成内存泄露。优先选用unique_ptr，如需在作用域之间复制共享就使用shared_ptr。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
</feed>
