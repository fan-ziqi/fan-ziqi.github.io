<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>范子琦的博客</title>
  
  
  <link href="https://www.robotsfan.com/atom.xml" rel="self"/>
  
  <link href="https://www.robotsfan.com/"/>
  <updated>2022-09-15T16:35:55.406Z</updated>
  <id>https://www.robotsfan.com/</id>
  
  <author>
    <name>Fan Ziqi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手把手教你电机FOC控制【持续更新中】</title>
    <link href="https://www.robotsfan.com/posts/d99d1c1a.html"/>
    <id>https://www.robotsfan.com/posts/d99d1c1a.html</id>
    <published>2022-09-15T16:30:00.000Z</published>
    <updated>2022-09-15T16:35:55.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手把手教你电机FOC控制"><a href="#手把手教你电机FOC控制" class="headerlink" title="手把手教你电机FOC控制"></a>手把手教你电机FOC控制</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2022.09.16 完善图片内容与代码，更新到速度闭环</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220916003234988.png" alt="image-20220916003234988" style="zoom: 25%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220916003249372.png" alt="image-20220916003249372" style="zoom: 25%;"></p><h2 id="FOC框架引入"><a href="#FOC框架引入" class="headerlink" title="FOC框架引入"></a>FOC框架引入</h2><p>三向电机，分别为UVW三向，角度互差120度。若使用BLDC控制方法，如下图每次换向增加60度，转子只能到达六个位置，所以六步换向时会有振动。使用FOC控制方法可以使转子到达任意角度，所以运行起来会更加平滑。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/ED2759D27293A18F51A49E35A2A46EB0.png" alt="ED2759D27293A18F51A49E35A2A46EB0" style="zoom:50%;"></p><p>如果想到达40度的位置，只需要在0度方向通电一段时间，在60度方向通电一段时间，再在空矢量的状态下通电一段时间（全桥000或111的位置为空矢量，空矢量的时长用来调节扭矩。后面会讲到），三段时间组成一个周期，以这个周期循环产生PWM，即可锁定至40度。若想到达其他角度，只需改变0度和60度的通电时长比例。</p><p>要想使磁场旋转起来，就需要输入正弦电压，但我们输入的是直流电，我们马上想到可以使用PWM波。通过不断改变<strong>PWM脉宽</strong>就可以模拟正弦电压，体现在电流上则为正弦电流。</p><p>下图为一个完整的FOC流程图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220418110757084.png" alt="image-20220418110757084" style="zoom: 80%;"></p><p>我们先来看正向通路：输入 $I_{d_ref}$ 和 $I_{q_ref}$ 与下文反馈通路采样得到的电流 $I_d$ 和 $I_q$ 进行PID控制输出 $U_d$ 和 $U_q$ （输入的 $I_{d_ref}$ 通常为0， $I_{q_ref}$ 前通常还需要接入一个速度PID构成速度环），再通过反Park变换转换成 $U_\alpha$ 和 $U_\beta$ ，通过SVPWM模块控制定时器产生六路互补的PWM信号，最后使用PWM信号控制全桥MOS管的通断，产生三向电压使电机转动。</p><p>再来看反馈通路：通过采样电阻采集任意两相电流，根据基尔霍夫电流定律可以算出第三相电流，将三向电流通过Clark变换转化成 $I_\alpha$ 和 $I_\beta$ ，再通过Park变换转换成 $I_d$ 和 $I_q$ ，作为反馈传入PID控制器构成电流环。</p><p>上图中的Park变换和反Park变换需要当前的角度作为输入；速度PID需要速度作为反馈。所以需要获得电机的速度与角度。角度和速度的获取方法分为有感和无感。有感方式使用霍尔元件（Hall Sensor），安装在电机上就可以检测电机磁铁的位置。无感使用观测器（observer）获得角度速度信息，本文将使用扩展卡尔曼滤波观测器（EKF），输入为  $U_\alpha$ 、 $U_\beta$ 、 $I_\alpha$ 、 $I_\beta$ 。使用无感方式不需要霍尔传感器，可以减少连接线的数量，也可以减小成本。</p><h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>为什么要使用坐标变换？电机控制大多是在控制速度/转矩，需要用PID闭环控制正弦交流电压的幅值和角度，不是很容易实现，所以通过坐标变化把正弦交流信息分解成角度信息（Q轴控制转矩）和幅值信息（D轴控制磁场）单独控制。</p><p><strong>FOC的变换中要满足等幅值变换，即变换前后幅值不变。</strong></p><p>坐标变换都分为正向变换和反向变换，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。</p><p>下面的变换均采用联立和矩阵两种形式表示，以方便使用。</p><h3 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h3><p>Clark变换实现了三向坐标系 $(a,b,c)$ 与直角坐标系 $(\alpha,\beta)$ 间的转换。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/7C602099D7A9549EDA9C24D13AB98072.png" alt="7C602099D7A9549EDA9C24D13AB98072" style="zoom: 67%;"></p><h4 id="正向Clark变换"><a href="#正向Clark变换" class="headerlink" title="正向Clark变换"></a>正向Clark变换</h4><p>Clark反变换则将两相信号转换为三相信号。已知三相坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    \begin{aligned}    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c    \end{aligned} \\    \begin{aligned}    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c    \end{aligned}\end{array}\right.</script><p>表示为矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{ccc}    1 & -\frac{1}{2}       & -\frac{1}{2} \\    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]</script><p>我们一般在电路中只采集两相电流，第三相电流可以使用基尔霍夫电流定律得出（ $I_a+I_b+I_c=0$ ），故上式也可整理为以下形式：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=\frac{3}{2}I_a \\    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}    \frac{3}{2} & 0\\    \frac{\sqrt{3}}{2} & \sqrt{3}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \end{array}\right]</script><p>由于变换前后 $I_a$ 和 $I_\alpha$ 幅值要相同，所以要进行等幅值变换，变换系数为 $\frac{2}{3}$ ，即变为</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=I_a \\    I_\beta=\frac{1}{\sqrt3}(I_a+2I_b)\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}    1 & 0\\    \frac{1}{\sqrt{3}} & \frac{2}{\sqrt{3}}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \end{array}\right]</script><p>（这里的系数在后文SVPWM里相电压的幅值与电压空间矢量之间有一个 $\frac{3}{2}$ 的系数相抵消）</p><p>MATLAB实现为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103933845.png" alt="image-20220330103933845" style="zoom: 80%;"></p><h4 id="反向Clark变换"><a href="#反向Clark变换" class="headerlink" title="反向Clark变换"></a>反向Clark变换</h4><p>反Clark变换则将三相信号转换为两相信号。根据图可以写出：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{a} =  U_{\alpha} \\U_{b} = -\frac{1}{2}U_{\alpha} + \frac{\sqrt3}{2}U_{\beta}\\U_{c} = -\frac{1}{2}U_{\alpha} - \frac{\sqrt3}{2}U_{\beta}\end{array}\right.</script><p>矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    U_{a} \\    U_{b} \\    U_{c}\end{array}\right]=\left[\begin{array}{ccc}    1  & 0       \\    -\frac{1}{2} & \frac{\sqrt{3}}{2} \\    -\frac{1}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    U_{\alpha} \\    U_{\beta}\end{array}\right]</script><p>MATLAB实现为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103915885.png" alt="image-20220330103915885" style="zoom:80%;"></p><h3 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h3><p>Park变换实现了两相坐标系 $(\alpha,\beta)$ 与转子坐标系 $(d,q)$ 间的转换，此变换可以将正弦变量线性化。其中 $d$ 指向转子中心， $q$ 指向切线方向， $\theta$ 是转子当前的角度，也就是说 $d-q$ 坐标系始终跟着转子同步旋转。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/A20BC4DCAD2986A86187F746C2EDE88A.png" alt="A20BC4DCAD2986A86187F746C2EDE88A" style="zoom: 67%;"></p><h4 id="正向Park变换"><a href="#正向Park变换" class="headerlink" title="正向Park变换"></a>正向Park变换</h4><p>则根据上图可以写出</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos\theta+I_{\beta} \sin\theta \\I_{q}=-I_{\alpha} \sin\theta+I_{\beta} \cos\theta\end{array}\right.</script><p>很明显上述变换可以用旋转矩阵来表示，使用矩阵形式可以很方便地写出：</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & \sin \theta \\    -\sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>（如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。）</p><p>MATLAB实现为</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104003922.png" alt="image-20220330104003922" style="zoom:80%;"></p><h4 id="反Park变换"><a href="#反Park变换" class="headerlink" title="反Park变换"></a>反Park变换</h4><p>根据上面的推导可以求得反Park变换</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{\alpha}=U_{d} \cos\theta-U_{q} \sin\theta \\U_{\beta}= U_{d} \sin\theta+U_{q} \cos\theta\end{array}\right.</script><p>同理，使用旋转矩阵可以求出反变换的系数矩阵：</p><script type="math/tex; mode=display">\left[\begin{array}{l}    U_{\alpha} \\    U_{\beta}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & -\sin \theta \\     \sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    U_{d} \\    U_{q}\end{array}\right]</script><p>MATLAB实现为</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103857619.png" alt="image-20220330103857619" style="zoom:80%;"></p><h3 id="MATLAB仿真"><a href="#MATLAB仿真" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h3><p>为了更清楚地仿真，这里不用矩阵形式表示，如需矩阵形式可以看我写的另一篇文章。</p><p>请注意，正向变换都是对电流进行操作的，反向变换都是对电压进行操作的。但是在这节的仿真中，把正变换和反变换连在一起，这样做没有实际意义，只是为了验证变化算法。</p><p>输入Vd为0，Vq为1，角度为由0到2pi的连续值。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103716603.png" alt="image-20220330103716603" style="zoom: 80%;"></p><p>再来看子模块内部，输入经过两个逆变换，再经过两个正变换。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330103816443.png" alt="image-20220330103816443" style="zoom:80%;"></p><p>运行查看波形（新版本MATLAB常值输入为一个圆圈）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330104412589.png" alt="image-20220330104412589" style="zoom:50%;"></p><h2 id="SVPWM"><a href="#SVPWM" class="headerlink" title="SVPWM"></a>SVPWM</h2><p>根据BLDC的六步换向，可以将一圈分为六个扇区，前文FOC引入章节已经讲过，只需要控制每个状态通电的时间就可以控制转子到达任意角度。这就是SVPWM。</p><p>SVPWM的输入为 $U_{\alpha}$ 和 $U_{\beta}$ ，输出为三向计数器的比较值。所以应该首先判断用哪两个相邻矢量，然后计算两个相邻矢量的作用时长，然后将作用时长转化成计数器的比较数值送入定时器。下面对这三个步骤进行讲解。</p><h3 id="扇区判断"><a href="#扇区判断" class="headerlink" title="扇区判断"></a>扇区判断</h3><p>三相电压可以表示为（ $U_{m}$ 为电压幅值）：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{m}cos\theta \\U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\U_c = U_{m}cos(\theta+\frac{2}{3}\pi)\end{array}</script><p>将其转换为 $\alpha-\beta$ 坐标系，可以算出</p><script type="math/tex; mode=display">\begin{array}{l}U_{\alpha} = U_{m}cos\theta \\U_{\beta} = U_{m}sin\theta\end{array}</script><p>从这个式子发现，可以从中算出角度信息从而可以判断在哪个扇区</p><script type="math/tex; mode=display">\theta = arctan(\frac{U_{\beta}}{U_{\alpha}})</script><p>由于除法和反三角函数对于MCU来说计算量比较大。我们来找一个简便算法。</p><p> $U_{\alpha}$ 是关于cos的三角函数， $U_{\beta}$ 是关于sin的三角函数，可以得到：</p><script type="math/tex; mode=display">\begin{array}{l}扇区1:& U_{\alpha} > 0&,& U_{\beta} > 0\\扇区2:& U_{\alpha} >or< 0&,& U_{\beta} > 0\\扇区3:& U_{\alpha} < 0&,& U_{\beta} > 0\\扇区4:& U_{\alpha} < 0&,& U_{\beta} < 0\\扇区5:& U_{\alpha} >or< 0&,& U_{\beta} < 0\\扇区6:& U_{\alpha} > 0&,& U_{\beta} < 0\end{array}</script><p>可以看到，通过 $U_{\beta}$ 的正负可以判断出是1/2/3扇区还是4/5/6扇区。</p><p>这个条件只将扇区分为两个部分，我们还需要几个条件来更细致地分。将每个扇区的反三角函数范围计算出来：</p><script type="math/tex; mode=display">\begin{aligned}扇区1:& tan0^{\circ} >   \frac{U_{\beta}}{U_{\alpha}} > tan60^{\circ} &\Rightarrow& 0 &>&        \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\扇区2:& tan60^{\circ} >  \frac{U_{\beta}}{U_{\alpha}} > tan120^{\circ} &\Rightarrow& \sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\扇区3:& tan120^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan180^{\circ} &\Rightarrow&-\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0        \\扇区4:& tan180^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan240^{\circ} &\Rightarrow&0        &>& \frac{U_{\beta}}{U_{\alpha}} >& \sqrt{3}  \\扇区5:& tan240^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan300^{\circ} &\Rightarrow&\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& -\sqrt{3} \\扇区6:& tan300^{\circ} > \frac{U_{\beta}}{U_{\alpha}} > tan360^{\circ} &\Rightarrow& -\sqrt{3} &>& \frac{U_{\beta}}{U_{\alpha}} >& 0\end{aligned}</script><p>观察这个结论， $U_{\beta}$ 和 $\sqrt{3}U_{\alpha}$ 似乎有关系，回顾反Clark变换， $U_{b}$ 和 $U_{c}$ 的式子就是这种关系。所以可以把上面的结论往反Clark变换上凑。看一下反Clark变换的图像，注意我们需要的关系里的 $\sqrt{3}$ 是乘在 $U_{\alpha}$ 上的，所以我们把 $U_{\beta}$ 和 $U_{\alpha}$ 反一下，对应的公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_{a} =  U_{\beta} \\U_{b} = -\frac{1}{2}U_{\beta} + \frac{\sqrt3}{2}U_{\alpha}\\U_{c} = -\frac{1}{2}U_{\beta} - \frac{\sqrt3}{2}U_{\alpha}\end{array}\right.</script><p>生成上述公式的图像，其中黄色的线为 $U_{a}$ 为 $U_{\beta}$ ，蓝色的线 $U_{b}$ 为 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，红色的线 $U_{c}$ 为 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ ，</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330145027064.png" alt="image-20220330145027064" style="zoom:50%;"></p><p>可以看到在每个扇区内总有一向大于0，两向小于0，所以 $U_{b}$ 和 $U_{c}$ 的正负可以当做判断条件之一。我们顺便还又一次得到了 $U_{\beta}$ 这个判断条件。整理一下上面的式子</p><script type="math/tex; mode=display">\begin{aligned}扇区1:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\扇区2:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\\扇区3:U_{\beta} > 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区4:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} <0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区5:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} > 0\\扇区6:U_{\beta} < 0 , \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} >0 , -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta} < 0\end{aligned}</script><p>所以通过计算 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 的正负可以判断出是1/6扇区，3/4扇区，2扇区，5扇区的哪一组。</p><p>综上，我们的判断条件有： $U_{\beta}$ 、 $\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 和 $-\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}$ 。我们分别定义：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{\beta} \\U_b = \frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\\U_c = -\frac{\sqrt3}{2}U_{\alpha} - \frac{1}{2}U_{\beta}\end{array}</script><p>综合这三个条件就可以判断是在哪个扇区 。那么有没有一种算法可以将这一堆判断数值化并转换成1~6的数字呢？可以用下面的公式：</p><script type="math/tex; mode=display">N=A+2B+4C</script><p>式中A代表 $U_a$ 的正负，B代表 $U_b$ 的正负，C代表 $U_c$ 的正负，大于0为1，小于0为0。最后转换出来的的N即为1~6的数字：</p><script type="math/tex; mode=display">\begin{array}{c}扇区 & 1 & 2 & 3 & 4 & 5 & 6 & \\N   & 3 & 1 & 5 & 4 & 6 & 2 &\end{array}</script><p>至此，我们成功完成了扇区判断。</p><h3 id="计算相邻矢量作用时长"><a href="#计算相邻矢量作用时长" class="headerlink" title="计算相邻矢量作用时长"></a>计算相邻矢量作用时长</h3><p>控制相邻矢量作用时长就可以控制转子到达任意方向，下面进行分析。</p><h4 id="六个矢量的大小"><a href="#六个矢量的大小" class="headerlink" title="六个矢量的大小"></a>六个矢量的大小</h4><p>六个MOS管可以产生8种状态</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152650462.png" alt="image-20220330152650462" style="zoom:50%;"></p><p>设上开下合为0（电流从O往对应的向流），上合下开为1（电流从对应的向往O流），表示其中的六个矢量。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152634407.png" alt="image-20220330152634407" style="zoom:50%;"></p><p>放在一张图中即为：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330152741018.png" alt="image-20220330152741018" style="zoom:50%;"></p><p>还有两个零矢量（000和111），无电流，不产生磁场。</p><p>对于100的状态，可以等效为下面的电路图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220330154344462.png" alt="image-20220330154344462" style="zoom: 25%;"></p><p>可以计算出电机中三个相电压（每相相对于电机中间连接点的电压）</p><script type="math/tex; mode=display">\begin{aligned}U_{AN} &=U_{A}-U_{N}=\frac{2}{3} U_{d c} \\U_{BN} &=U_{B}-U_{N}=-\frac{1}{3} U_{d c} \\U_{CN} &=U_{C}-U_{N}=-\frac{1}{3} U_{d c}\end{aligned}</script><p>同理可以计算其他所有方向矢量的相电压，可以看出，六个矢量的大小均为 $\frac{2}{3} U_{d c}$ ，即<strong>SVPWM相电压幅值为 $\frac{2}{3} U_{d c}$</strong> </p><h4 id="电压利用率"><a href="#电压利用率" class="headerlink" title="电压利用率"></a>电压利用率</h4><p>电压利用率等于合成矢量的电压除以母线电压。下面在复平面计算合成矢量的电压 $U_{out}$ ：</p><script type="math/tex; mode=display">U_{out} = U_a +U_{b}\cdot e^{j\cdot \frac{2}{3}\pi}+U_{c}\cdot e^{j\cdot (-\frac{2}{3}\pi)}</script><p>根据欧拉公式可以推导出：</p><script type="math/tex; mode=display">e^{jx}=cosx+jsinx</script><p>又因为三相电压与相电压幅值之间的关系：</p><script type="math/tex; mode=display">\begin{array}{l}U_a = U_{m}cos\theta \\U_b = U_{m}cos(\theta-\frac{2}{3}\pi) \\U_c = U_{m}cos(\theta+\frac{2}{3}\pi)\end{array}</script><p>带入可以计算出 $U_{out}$ ：</p><script type="math/tex; mode=display">U_{out}=\frac{3}{2}U_m\cdot e^{j\theta}</script><p>合成矢量的电压是相电压幅值的 $\frac{3}{2}$ 倍，而SVPWM相电压幅值 $U_m$ 为 $\frac{2}{3} U_{d c}$ ，所以</p><script type="math/tex; mode=display">U_{out}=U_{dc}</script><p>即<strong>合成矢量的电压等于母线电压</strong>。所以<strong>SVPWM的电压利用率是100%</strong>。</p><h4 id="SVPWM输出电压是马鞍波"><a href="#SVPWM输出电压是马鞍波" class="headerlink" title="SVPWM输出电压是马鞍波"></a>SVPWM输出电压是马鞍波</h4><p>由于中间连接点N的点位 是浮动的，为三角波，而相电压是每相相对于电机中间连接点N的电压，所以相电压不是一个正弦波，而是一个正弦波与一个三角波叠加而成的，即为马鞍波。网图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/d94c427b1d664ffe9b585d58e60482f6.jpg" alt="d94c427b1d664ffe9b585d58e60482f6" style="zoom:50%;"></p><h4 id="矢量作用时长"><a href="#矢量作用时长" class="headerlink" title="矢量作用时长"></a>矢量作用时长</h4><p>合成矢量的电压是所在扇区两个矢量与空矢量不同时长的组合，其中 $T_N$ 为空矢量作用时长：</p><script type="math/tex; mode=display">U_{out}=U_x\frac{T_x}{T_s}+U_y\frac{T_y}{T_s}+U_N\frac{T_N}{T_s}</script><p>由于SVPWM的输入是 $U_{\alpha}$ 和 $U_{\beta}$ ，但是要控制 $T_x$ 和 $T_y$ ，所以要找到他们的对应关系。</p><p>对于第一个扇区，将 $U_{out}$ 在 $\alpha-\beta$ 坐标系中表示：</p><script type="math/tex; mode=display">\begin{array}{l}U_\alpha=|U_x|\frac{T_x}{T_s}+|U_y|\frac{T_y}{T_s}cos60^{\circ}\\U_\beta=|U_y|\frac{T_y}{T_s}sin60^{\circ}\end{array}</script><p>其中 $|U_x|$ 和 $|U_y|$ 根据前面的计算均为 $\frac{2}{3} U_{d c}$ ，可以解出：</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\end{array}</script><p>同理，可以计算出所有六个扇区：</p><p>第二扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\end{array}</script><p>第三扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}U_\beta\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\end{array}</script><p>第四扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\end{array}</script><p>第五扇区</p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)\end{array}</script><p>第六扇区 </p><script type="math/tex; mode=display">\begin{array}{l}T_x=\frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha+\frac{1}{2}U_\beta)\\T_y=\frac{\sqrt{3}T_S}{U_{dc}}(-U_\beta)\end{array}</script><p>六个扇区中都有相同的项，其中包含前文判断扇区所用的 $U_1$ 、 $U_2$ 、 $U_3$ 。直接把前面已经计算过的变量拿过来使用，大大减少了计算量。式中的 $\frac{\sqrt{3}T_S}{U_{dc}}$ 为调制比，定义：</p><script type="math/tex; mode=display">\begin{array}{l}U_{mr} = \frac{\sqrt{3}T_S}{U_{dc}} \\X= \frac{\sqrt{3}T_S}{U_{dc}}U_\beta=U_{mr}U_1\\Y= \frac{\sqrt{3}T_S}{U_{dc}}(\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_2\\Z= \frac{\sqrt{3}T_S}{U_{dc}}(-\frac{\sqrt{3}}{2}U_\alpha-\frac{1}{2}U_\beta)=U_{mr}U_3\end{array}</script><p>可以将六个扇区表示为：</p><script type="math/tex; mode=display">\begin{array}{c}& T_x & T_y  \\扇区1&  Y  &  X  \\扇区2& -Y  & -Z  \\扇区3&  X  &  Z  \\扇区4& -X  & -Y  \\扇区5&  Z  &  Y  \\扇区6& -Z  & -X  \\\end{array}</script><p>注意：当非零矢量作用时间 $Tx+Ty&gt;Ts$ ，需要进行过饱和处理：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}T_{x}=\frac{T_{x}}{T_{x}+T_{y}} T_{s} \\T_{y}=\frac{T_{y}}{T_{x}+T_{y}} T_{s}\end{array}\right.</script><h3 id="定时器比较值计算"><a href="#定时器比较值计算" class="headerlink" title="定时器比较值计算"></a>定时器比较值计算</h3><p>我们前文算出来的 $T_x$ 和 $T_y$ 以秒为单位，在单片机中使用定时器控制MOS管的通断需要配置比较值，所以需要把 $T_x$ 和 $T_y$ 转换为三个互补的定时器比较值 $T_1$ 、 $T_2$ 和 $T_3$ 。</p><p>定时器应设置为中心对齐模式，若为向上计数，计数器会从0开始计数到最大值，再反向从最大值计数到0；向下计数反之。故只需要控制前半个周期的比较值就可以产生相对中心对称的PWM波。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/CB0D861C81399F86BFB03E925F9AF8AC.png" alt="CB0D861C81399F86BFB03E925F9AF8AC" style="zoom:50%;"></p><p>为了减少MOS管的开关损耗，提高其使用寿命，应尽量减少MOS管的开关次数。在一个扇区内切换状态的时候，合理使用零矢量可以保证每次切换只改变一个MOS管。</p><p>先来看第一扇区，以每次只改变一个MOS管为原则，则切换顺序为：</p><script type="math/tex; mode=display">000 \to 100 \to 110 \to 111 \to 110 \to 100 \to 000</script><p>可以看到，切换顺序构成了一个环路。在一个周期内我们需要控制三段作用时长：</p><script type="math/tex; mode=display">T_s=T_x+T_y+T_N</script><p>六个MOS需要产生六路PWM来控制他们的状态。由于上下半桥是互补的，所以只需要生成三个PWM：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331151522966.png" alt="image-20220331151522966" style="zoom:50%;"></p><p>由于是中心对齐模式，所以只需要控制半个周期的时长 $\frac{T_x}{2}$ 和 $\frac{T_y}{2}$ 。在半个周期内 $T_N$ 出现了两次，分别为000和111，在半个周期内将这两段时间平均分配。即为 $\frac{T_S-T_x-T_y}{4}$ 。</p><p>这样就可以计算三个定时器的比较值 $T_1$ 、 $T_2$ 和 $T_3$ ：</p><script type="math/tex; mode=display">\begin{array}{l}T_1= \frac{T_S-T_x-T_y}{4}\\T_2=T_1+\frac{T_x}{2}\\T_3=T_2+\frac{T_y}{2}\end{array}</script><p>同理，可以计算出全部六个扇区的切换顺序，这里计算过程不再赘述。由图像和计算结果可以分析出，无论在哪个扇区中，三个定时器切换的图像都是由上图中三个方波构成，三个图像排列组合也正好就是六个扇区的组合方式。故为了方便程序运行，将六个扇区的定时器比较值归纳如下：</p><p>设</p><script type="math/tex; mode=display">\begin{array}{l}T_a= \frac{T_S-T_x-T_y}{4}\\T_b=T_a+\frac{T_x}{2}\\T_c=T_b+\frac{T_y}{2}\end{array}</script><p>此时六个扇区可以表示为：</p><script type="math/tex; mode=display">\begin{array}{c}  & 扇区1 & 扇区2 & 扇区3 & 扇区4 & 扇区5 & 扇区6 & \\T1& T_a & T_b & T_c & T_c & T_b & T_a &\\T2& T_b & T_a & T_a & T_b & T_c & T_c &\\T3& T_c & T_c & T_b & T_a & T_a & T_b &\end{array}</script><p>也就是说编程时只需要计算 $T_a$ 、 $T_b$ 和 $T_c$ ，通过判断就可以得到对应扇区的比较值。</p><p>至此，SVPWM输出比较值 $T_1$ 、 $T_2$ 、 $T_3$ ，互补得到六个比较值，输入到定时器，输出三路PWM。</p><h4 id="MATLAB仿真-1"><a href="#MATLAB仿真-1" class="headerlink" title="MATLAB仿真"></a>MATLAB仿真</h4><p>假设需要产生10Khz的PWM波，则一个周期为0.0001秒。若单片机主频为180Mhz，预分频系数为100-1，由下面计算公式：（其中 $ARR$ 是计数值， $PSC$ 是预分频值）</p><script type="math/tex; mode=display">Fpwm(Hz) = \frac{主频(M)}{(ARR+1)*(PSC+1)}</script><p>180,000,000/(18,000*100)=10,000Hz，则定时器的计数值应设置为18000-1。</p><p>在模型中设定 $Udc$ 为24， $Tpwm$ 为18000。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163919487.png" alt="image-20220331163919487" style="zoom:50%;"></p><p>在foc子模块中，将park反变换的输出输入到SVPWM模块：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331163836635.png" alt="image-20220331163836635" style="zoom: 67%;"></p><p>SVPWM模块代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[T1,T2,T3,sector]</span> = <span class="title">fcn</span><span class="params">(Ualpha,Ubeta,Udc,Tpwm)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">sector = single(<span class="number">0</span>);</span><br><span class="line">T1 = single(<span class="number">0</span>);</span><br><span class="line">T2 = single(<span class="number">0</span>);</span><br><span class="line">T3 = single(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第一步：扇区判断</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ua = Ubeta;</span><br><span class="line">Ub = (<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line">Uc = (-<span class="built_in">sqrt</span>(<span class="number">3</span>)*Ualpha - Ubeta)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% 计算判断扇区所用的ABC的值</span></span><br><span class="line">A=single(<span class="number">0</span>);B=single(<span class="number">0</span>);C=single(<span class="number">0</span>);N=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(Ua&gt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ua&lt;<span class="number">0</span>)</span><br><span class="line">    A = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Ub&gt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Ub&lt;<span class="number">0</span>)</span><br><span class="line">    B = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span>(Uc&gt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">elseif</span>(Uc&lt;<span class="number">0</span>)</span><br><span class="line">    C = single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算判断扇区所用的N的值</span></span><br><span class="line">N = A + <span class="number">2</span>*B + <span class="number">4</span>*C;</span><br><span class="line"><span class="comment">% 扇区判断</span></span><br><span class="line"><span class="keyword">switch</span> (N)   </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        sector = single(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        sector = single(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        sector = single(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        sector = single(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        sector = single(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        sector = single(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：计算相邻矢量作用时长</span></span><br><span class="line"><span class="comment">% 计算调制比</span></span><br><span class="line">Umr = <span class="built_in">sqrt</span>(<span class="number">3</span>)*Tpwm/Udc;</span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">X = Umr * Ua;</span><br><span class="line">Y = Umr * Ub;</span><br><span class="line">Z = Umr * Uc;</span><br><span class="line"><span class="comment">% 分扇区计算Tx和Ty的值</span></span><br><span class="line">Tx=single(<span class="number">0</span>);Ty=single(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        Tx = Y; Ty = X;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        Tx = -Y; Ty = -Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        Tx = X; Ty = Z;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        Tx = -X; Ty = -Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        Tx = Z; Ty = Y;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        Tx = -Z; Ty = -X;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：定时器比较值计算</span></span><br><span class="line"><span class="comment">% 干啥用的？</span></span><br><span class="line"><span class="keyword">if</span> Tx+Ty &gt; Tpwm</span><br><span class="line">    Tx = Tx/(Tx+Ty);</span><br><span class="line">    Ty = Ty/(Tx+Ty);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Tx = Tx;</span><br><span class="line">    Ty = Ty;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算三个临时变量</span></span><br><span class="line">Ta = (Tpwm-Tx-Ty)/<span class="number">4.0</span>;</span><br><span class="line">Tb = Ta+Tx/<span class="number">2.0</span>;</span><br><span class="line">Tc = Tb+Ty/<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">% 分扇区计算定时器比较值T1、T2和T3的值</span></span><br><span class="line"><span class="keyword">switch</span> (sector)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        T1 = Ta; T2 = Tb; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        T1 = Tb; T2 = Ta; T3 = Tc;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">        T1 = Tc; T2 = Ta; T3 = Tb;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">        T1 = Tc; T2 = Tb; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">        T1 = Tb; T2 = Tc; T3 = Ta;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span></span><br><span class="line">        T1 = Ta; T2 = Tc; T3 = Tb;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到，定时器比较值为马鞍波</p><p><img src="/posts/Users\fanziqi\AppData\Roaming\Typora\typora-user-images\image-20220331165323898.png" alt="image-20220331165323898" style="zoom: 50%;"></p><p>扇区为从1到6的循环</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220331165348883.png" alt="image-20220331165348883" style="zoom:50%;"></p><h2 id="电流闭环"><a href="#电流闭环" class="headerlink" title="电流闭环"></a>电流闭环</h2><p>经过前文的反Park变换、SVPWM、定时器与全桥，输入的 $U_{d}$ 和 $U_{q}$ 最终转换为三相电压输出到电机。如果需要让电机以设定的电流值运行，就需要使用PI控制器闭环控制电流。但三相交流电流是不太容易实现闭环控制的，所以我们选择对直流电流 $I_{d}$ 和 $I_{q}$ 进行闭环控制。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220418111545651.png" alt="image-20220418111545651" style="zoom: 67%;"></p><p>PI控制器输入目标参考电流 $I_{d_{ref}}$ 和 $I_{q_{ref}}$ ，输出 $U_{d}$ 和 $U_{q}$ ，现在还缺少反馈量 $I_{d}$ 和 $I_{q}$ ，这就需要用到前文讲到的Park与Clark正变换。安装采样电阻，用单片机的ADC采集全桥上任意两相的电流，通过基尔霍夫电流定律可计算第三相的电流，通过Clark变换计算出 $I_{\alpha}$ 和 $I_{\beta}$ ，再通过Park变换计算出反馈量 $I_{d}$ 和 $I_{q}$ 。</p><p>对于PI控制器参数的设定，以下为一个参考值（但还是需要自行调整）：</p><script type="math/tex; mode=display">\begin{array}{c}  & P & I &\\d& K_{pd}=\alpha L_d & K_{Id}=\alpha R\\q& K_{pq}=\alpha L_q & K_{Iq}=\alpha R\end{array}</script><p>其中 $\alpha$ 的取值为：（其中 $\tau$ 为电机的时间常数）</p><script type="math/tex; mode=display">\alpha = \frac{2\pi}{\tau} \\\tau = min\left\{\frac{L_d}{R},\frac{L_q}{R}\right\}</script><p>电机分为表贴电机和内嵌式电机，表贴式电机的永磁体贴在转子表面，内嵌式电机的永磁体安装在转子内。我们常用的电机都是表贴电机，对于表贴电机， $L_d=L_q=L$ ，则可以得到PI控制器的参考参数：</p><script type="math/tex; mode=display">K_{p}=2\pi R \\K_{I}=2\pi \frac{R^2}{L}</script><h2 id="角度和速度的获取"><a href="#角度和速度的获取" class="headerlink" title="角度和速度的获取"></a>角度和速度的获取</h2><h3 id="有感（HALL）"><a href="#有感（HALL）" class="headerlink" title="有感（HALL）"></a>有感（HALL）</h3><p>霍尔传感器分为60度和120度</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/1C13C24117669CA4C27767785618F5F9.png" alt="1C13C24117669CA4C27767785618F5F9" style="zoom:50%;"></p><p>画一下转一圈三个霍尔传感器的波形</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/C18D380D267A0837CAFBC98D96941EA6.png" alt="C18D380D267A0837CAFBC98D96941EA6" style="zoom:50%;"></p><p>可以看到，这两种排列方式除了组合方式不同，其他都一样。</p><p>单片机通过输入捕获采集三路高低电平的跳变，通过对三路信号进行异或，则转一圈可以进6次中断，进入中断后检测IO电平就可以知道电机对应角度。但现在一圈只能获取到6个固定的角度值，无法获取到如80度这个角度。这时可以对速度进行积分得到角度，速度的获取可以通过查询60-120之间定时器的计数值来获得。但是转到80度的时候没办法获取到120度时候的定时器计数值就无法获取当前段的速度，这时可以用前一段的速度近似为当前段的速度。</p><h3 id="无感（EKF）"><a href="#无感（EKF）" class="headerlink" title="无感（EKF）"></a>无感（EKF）</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>前面的有感部分，是在电机上安装霍尔传感器，引出三根线到单片机通过输入捕获算出当前角度，再与预设角度完成角度闭环。</p><p>而无感控制则不需要霍尔传感器，只需要三根UVW线输出到电机即可，去掉了霍尔传感器和三根线，节省了成本；有些使用场合无法使用霍尔传感器，则需要使用无感，比如空调压缩机，内部充满了润滑油，无法安装霍尔传感器；有些时候有感算法或硬件出现问题也可以切换至无感，防止系统闸机，比如汽车运行中霍尔传感器突然坏了，为了使整个系统正常运行，就可以临时切换到无感。上述这些都是无感控制的优点。无感控制现在已经越来越普及，空调、洗衣机、高端风扇、汽车都在用无感控制。</p><h4 id="状态观测器"><a href="#状态观测器" class="headerlink" title="状态观测器"></a>状态观测器</h4><p>观测器有很多种，扩展卡尔曼滤波观测器、滑膜观测器、龙伯格观测器、自适应观测器、磁链观测器等。其中扩展卡尔曼滤波观测器的低速性能比较好，所以本文重点讨论EKF。</p><p>状态观测器实质上就是用数学方法建立一个可以模拟真实被控对象的模型，用这个模型来得知一些无法通过测量得到的状态量。对于电机系统来说，如果没有传感器去测量电机的转速和转子位置，那么就可以通过搭建状态观测器来估算电机的转子和转子位置，这就是基于状态观测器的电机的无传感器控制。</p><p>但是使用这种方法建立的观测器有着诸多问题：</p><ol><li>抗干扰能力差：加入扰动或负载，此时的状态观测器很难保持正确的响应而导致输出错误或者系统崩溃；</li><li>存在误差：误差主要存在与系统误差和测量误差<ol><li>系统误差：在建模的时候电机的参数不可能完全精确，在建模的时候造成误差。</li><li>测量误差：观测器需要电流作为输入，而电流的采集就会存在误差。</li></ol></li></ol><p>所以为了解决以上问题，需要给状态观测器增加反馈，通过反馈来修正状态观测器的输出，让观测器尽可能的去贴近真实的电机。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/017fc22e045b4488a08db81c18a6590f.png" alt="在这里插入图片描述"></p><h5 id="状态空间表示"><a href="#状态空间表示" class="headerlink" title="状态空间表示"></a>状态空间表示</h5><p>线性系统的状态空间方程为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\dot x = Ax+Bu\\y=Hx\end{array}\right.</script><p>永磁同步电机的方程：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}U_\alpha = Ri_\alpha + L_s \frac{di_\alpha}{dt} - \omega_e \psi_f sin\theta\\U_\beta = Ri_\beta + L_s \frac{di_\beta}{dt} + \omega_e \psi_f cos\theta\end{array}\right.</script><p>上述方程的含义为：将每一相抽象为一个电阻，一个电感和一个反电动势的串联，则每一相的电压为前面三项压降之和（反电动势为速度乘磁链）。方程中的电阻R、电感L、和磁链flux为电机的固有参数，电流可以通过采样电阻得到，只剩下了角度和转速，将电机方程转化为状态空间表达：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\frac{d i_\alpha}{dt} = -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta + \frac{1}{L_s}U_\alpha \\\frac{d i_\beta}{dt} = -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta + \frac{1}{L_s}U_\beta \\\frac{d \omega_e}{dt} = 0 \\\frac{d \theta}{dt} = \omega_e\end{array}\right.</script><h5 id="矩阵化表示"><a href="#矩阵化表示" class="headerlink" title="矩阵化表示"></a>矩阵化表示</h5><p>接下来我们将上面的式子整理成矩阵形式，首先确认状态变量分别为 $ \dot{i_\alpha},\dot{i_\beta},\dot{\omega_e},\dot{\theta}$ ，则有：</p><script type="math/tex; mode=display">\begin{aligned}\dot{x}=\begin{bmatrix} \dot{i_\alpha} \\ \dot{i_\beta} \\ \dot{\omega_e} \\ \dot{\theta} \\\end{bmatrix}\quadx=\begin{bmatrix} i_\alpha \\ i_\beta \\ \omega_e \\ \theta \\\end{bmatrix}\end{aligned}</script><p>输入 $u$ ，对于电机来说就是电压，我们选择 $\alpha-\beta$ 坐标系：</p><script type="math/tex; mode=display">\begin{aligned}u=\begin{bmatrix} U_\alpha \\ U_\beta \\\end{bmatrix}\end{aligned}</script><p>输出矩阵 $y$ 为通过采样电阻测得的电流：</p><script type="math/tex; mode=display">\begin{aligned}y=\begin{bmatrix} i_\alpha \\ i_\beta \\\end{bmatrix}\end{aligned}</script><p>则 $H$ 和 $B$ 矩阵就可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}H=\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\\end{bmatrix}\quadB=\begin{bmatrix} \frac{1}{L_s} & 0 \\ 0 & \frac{1}{L_s} \\ 0 & 0 \\ 0 & 0 \\\end{bmatrix}\end{aligned}</script><p>此时矩阵形式的表示为：</p><script type="math/tex; mode=display">\begin{aligned}\begin{bmatrix}i_{\alpha} \\\dot{i}_{\beta} \\\dot{\omega} \\\dot{\theta}\end{bmatrix} & = \begin{bmatrix}-\frac{R}{L_{S}} i_{\alpha}+\frac{1}{L_{s}} \omega_{e} \psi_{f} \sin \theta \\-\frac{R}{L_{S}} i_{\beta}-\frac{1}{L_{s}} \omega_{e} \psi_{f} \cos \theta \\0 \\\omega_{e}\end{bmatrix}+\begin{bmatrix}\frac{1}{L_{s}} & 0 \\0 & \frac{1}{L_{s}} \\0 & 0 \\0 & 0\end{bmatrix}\begin{bmatrix}u_{\alpha} \\u_{\beta}\end{bmatrix}\\\begin{bmatrix}i_{\alpha} \\i_{\beta}\end{bmatrix} & = \begin{bmatrix}1 & 0 & 0 & 0 \\0 & 1 & 0 & 0\end{bmatrix}\begin{bmatrix}i_{\alpha} \\i_{\beta} \\\omega_{e} \\\theta\end{bmatrix}\end{aligned}</script><p>对比状态空间表示，无法显式地表示出线性的 $Ax$ ，因为电机系统不是线性的，所以用 $f(x)$ 这一非线性项替代这一项。 $f(x)$ 定义为：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=\begin{bmatrix} -\frac{R}{L_s}i_\alpha + \frac{1}{L_s}\omega_e\psi_f sin\theta \\ -\frac{R}{L_s}i_\beta - \frac{1}{L_s}\omega_e\psi_f cos\theta \\ 0 \\ \omega_e \\\end{bmatrix}\end{aligned}</script><p>则此时的状态空间方程变为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\dot x = f(x)+Bu\\y=Hx\end{array}\right.</script><h4 id="扩展卡尔曼滤波器"><a href="#扩展卡尔曼滤波器" class="headerlink" title="扩展卡尔曼滤波器"></a>扩展卡尔曼滤波器</h4><p>关于卡尔曼滤波器的知识请看这篇文章：<a href="https://www.robotsfan.com/posts/b4727fbe.html">手撕卡尔曼滤波器</a></p><p>扩展卡尔曼滤波器（Extend Kalman Filter），简称EKF。带“扩展”二字，是因为卡尔曼滤波器只能处理线性系统，而电机是一个非线性，强耦合的系统，使用扩展卡尔曼滤波器可以处理这种非线性系统。</p><p>前文的状态空间方程中 $f(x)$ 是非线性的，如果想对非线性系统进行卡尔曼滤波，需要对其线性化（Linearization），泰勒级数展开是将非线性系统线性化的一种方法。将 $f(x)$ 泰勒级数展开并取前两项：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=f(x_0)+\frac{\partial f(x)}{\partial x}(x-x_0)\end{aligned}</script><p>对 $f(x)$ 求偏导：</p><script type="math/tex; mode=display">\begin{aligned}F = \frac{\partial f(x)}{\partial x}=\begin{bmatrix}-\frac{R}{L_{S}} & 0 & \frac{\psi_{f} \sin \theta}{L_{S}} & \frac{\omega_{e} \psi_{f} \cos \theta}{L_{S}} \\0 & -\frac{R}{L_{S}} & -\frac{\psi_{f} \cos \theta}{L_{S}} & \frac{\omega_{e} \psi_{f} \sin \theta}{L_{S}} \\0 & 0 & 0 & 0 \\0 & 0 & 1 & 0\end{bmatrix}\end{aligned}</script><p>此时状态空间方程变为：</p><script type="math/tex; mode=display">\dot{x}=f(x_{0})+F(x-x_{0})+B u</script><p>状态方程是建立在连续系统的基础上，需要将其转化成离散化系统后，才能在微控制器中实现卡尔曼滤波状态观测器。在离散化系统中， $\dot{x}=\frac{x_{k}-x_{k-1}}{\Delta t}$ ，则状态空间方程表示为：</p><script type="math/tex; mode=display">\begin{aligned}\frac{x_{k}-x_{k-1}}{\Delta t}  &= f(x_{k-1})+B u_{k-1}\\x_{k}&=x_{k-1}+(f(x_{k-1})+B u_{k-1}) \Delta t\\&=(I+F\Delta t)x_{k-1}+B u_{k-1}\Delta t\end{aligned}</script><p>令 $A=(I+F\Delta t)$ ，扩展卡尔曼滤波器的流程为以下五步：</p><ul><li><p>预测</p><ol><li><p>计算预估值</p><p>$\hat{x}_k^-=\hat{x}_{k-1}+(f(x_{k-1})+B u_{k-1}) \Delta t$</p></li><li><p>计算误差协方差</p><p>$P_k^-=(I+F\Delta t)P_{k-1}(I+F\Delta t)^T+Q$</p></li></ol></li><li><p>校正</p><ol><li><p>计算卡尔曼增益</p><p>$K_k=P_k^-H^T(HP_k^-H^T+R)^{-1}$</p></li><li><p>修正预估值</p><p>$\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)$ </p></li></ol></li></ul><ol><li><p>更新误差协方差，用于下一次计算</p><p>$P_k=(I-K_kH)P_k^-$ </p></li></ol><p>上面的五个方程中， $\Delta t$ 为采样时间， $Q$ 为模型误差， $R$ 为测量误差</p><p>在MATLAB中建立EKF观测器，需要建立全局变量x和P用于保存每一次迭代的值给下一次迭代使用：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x_posteriori</span>  = <span class="title">fcn</span><span class="params">(Ialpha,Ibeta,Ualpha,Ubeta,Ls,Rs,Flux)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> x;</span><br><span class="line"><span class="keyword">global</span> P;</span><br><span class="line"></span><br><span class="line">R=[<span class="number">0.02</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.02</span>];</span><br><span class="line">Q=[<span class="number">0.01</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.01</span>];</span><br><span class="line">Time=<span class="number">0.0001</span>;</span><br><span class="line"></span><br><span class="line">u=[Ualpha;Ubeta];</span><br><span class="line">y=[Ialpha;Ibeta];</span><br><span class="line">H=[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">B=[<span class="number">1</span>/Ls,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>/Ls;<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">F=[-Rs/Ls,<span class="number">0</span>,Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls,x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>,-Rs/Ls,-Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls,x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">f=[-Rs*Ialpha/Ls+x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">sin</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;-Rs*Ibeta/Ls-x(<span class="number">3</span>,<span class="number">1</span>)*Flux*<span class="built_in">cos</span>(x(<span class="number">4</span>,<span class="number">1</span>))/Ls;<span class="number">0</span>;x(<span class="number">3</span>,<span class="number">1</span>)];</span><br><span class="line"><span class="comment">% 计算预估值</span></span><br><span class="line">x_prior=x+(f+B*u)*Time;</span><br><span class="line"><span class="comment">% 计算误差协方差</span></span><br><span class="line">A=(<span class="built_in">eye</span>(<span class="number">4</span>)+F*Time);</span><br><span class="line">P_prior=A*P*A&#x27;+Q;</span><br><span class="line"><span class="comment">% 计算卡尔曼增益</span></span><br><span class="line">K=(P_prior*H&#x27;)/(H*P_prior*H&#x27;+R);</span><br><span class="line"><span class="comment">% 修正预估值</span></span><br><span class="line">x_posteriori=x_prior+K*(y-H*x_prior);</span><br><span class="line"><span class="comment">% 更新误差协方差</span></span><br><span class="line">P_posteriori=(<span class="built_in">eye</span>(<span class="number">4</span>)-K*H)*P_prior;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x_posteriori(<span class="number">4</span>,<span class="number">1</span>)&gt;(<span class="number">2</span>*<span class="built_in">pi</span>)</span><br><span class="line">    x_posteriori(<span class="number">4</span>,<span class="number">1</span>)=x_posteriori(<span class="number">4</span>,<span class="number">1</span>)-(<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x=x_posteriori;</span><br><span class="line">P=P_posteriori;</span><br></pre></td></tr></table></figure><p>调整R矩阵和Q矩阵至最优，查看观测器效果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220416201249667.png" alt="image-20220416201249667" style="zoom:50%;"></p><p>蓝色为观测角度，黄色为真实角度。可以看到经过很短时间的迭代，观测器就已经可以很好地预测电机角度，至此完成了EKF无感算法。</p><h2 id="速度闭环"><a href="#速度闭环" class="headerlink" title="速度闭环"></a>速度闭环</h2><p>前文电流闭环精准地控制了电机电流从而控制转矩，但要想精确地控制电机的速度就需要进行速度闭环。速度闭环是在电流闭环的外环，控制Id=0，通过前面有感或无感获取到的速度与速度参考作比较，通过PID控制Iq的值。</p><p>对于速度闭环PID，一班只是用PD控制。 $K_p$ 和 $K_d$ 的理论计算值为：</p><script type="math/tex; mode=display">K_P=\frac{\beta J}{1.5P\psi_f}\\K_I=\beta K_P</script><p>其中 $\beta$ 是速度环的带宽，一般为50rad/s； $J$ 为电机转动惯量，是电机的固有参数； $P$ 是电机的极对数； $\psi_f$ 是电机的磁链。</p><p>由于有观测器的存在，观测器的参数对速度环参数也会有影响，所以以上计算只是理论值，实际参数需要在理论值的基础上通过观察点击运行效果进行调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="https://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="https://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>使用Clion开发Qt</title>
    <link href="https://www.robotsfan.com/posts/113f8d22.html"/>
    <id>https://www.robotsfan.com/posts/113f8d22.html</id>
    <published>2022-09-08T05:00:00.000Z</published>
    <updated>2022-09-08T04:54:13.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用Clion开发Qt"><a href="#使用Clion开发Qt" class="headerlink" title="使用Clion开发Qt"></a>使用Clion开发Qt</h1><h2 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h2><p>参照下图勾选</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908111317127.png" alt="image-20220908111317127" style="zoom:50%;"></p><h2 id="配置Clion"><a href="#配置Clion" class="headerlink" title="配置Clion"></a>配置Clion</h2><p>新建Qt项目，并选择Qt CMake路径</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908120325486.png" alt="image-20220908120325486" style="zoom:50%;"></p><p>配置工具链</p><p>新建一个工具链并重命名，选择工具集，选择与下图一样的调试器</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908120845598.png" alt="image-20220908120845598" style="zoom:50%;"></p><p>添加Qt Designer工具，用于打开<code>*.ui</code>文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908121211672.png" alt="image-20220908121211672" style="zoom:50%;"></p><p>添加UIC工具，用于生成<code>ui_qwmainwind.h</code>文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908121628482.png" alt="image-20220908121628482" style="zoom:50%;"></p><p>添加环境变量</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908123829879.png" alt="image-20220908123829879" style="zoom:50%;"></p><p>运行</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124126507.png" alt="image-20220908124126507"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>创建UI类</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124511476.png" alt="image-20220908124511476" style="zoom:50%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124618160.png" alt="image-20220908124618160" style="zoom:50%;"></p><p>此时打开<code>mainwind.cpp</code>看到头文件<code>#include &quot;ui_MainWind.h&quot;</code>报错，这是因为需要使用UIC工具生成这个文件。</p><p>右键使用Qt Designer打开<code>mainwind.ui</code>就可以进行可视化设计</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908124824449.png" alt="image-20220908124824449" style="zoom:50%;"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908125226609.png" alt="image-20220908125226609" style="zoom:50%;"></p><p>右键使用Qt UIC打开<code>mainwind.ui</code>生成代码</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908125126022.png" alt="image-20220908125126022" style="zoom:50%;"></p><p>可以看到已成功生成<code>ui_MainWind.h</code>，且<code>mainwind.cpp</code>中不再报错。</p><p>在<code>main.cpp</code>中添加以下代码进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">MainWindow mainWindow;</span><br><span class="line">mainWindow.<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> QApplication::<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功输出</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220908125153526.png" alt="image-20220908125153526" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技能" scheme="https://www.robotsfan.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Qt" scheme="https://www.robotsfan.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>使用CLion开发STM32</title>
    <link href="https://www.robotsfan.com/posts/ea0a6855.html"/>
    <id>https://www.robotsfan.com/posts/ea0a6855.html</id>
    <published>2022-06-15T10:00:00.000Z</published>
    <updated>2022-06-16T03:56:06.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用CLion开发STM32"><a href="#使用CLion开发STM32" class="headerlink" title="使用CLion开发STM32"></a>使用CLion开发STM32</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h3><p>正常安装即可。<a href="https://www.st.com/en/development-tools/stm32cubemx.html">下载链接</a></p><h3 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h3><p>点击下载安装器。<a href="https://osdn.net/projects/mingw/releases/">下载链接</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165444739.png" alt="image-20220615165444739" style="zoom:50%;"></p><p>选择安装</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165549003.png" alt="image-20220615165549003" style="zoom:50%;"></p><p>改变一下路径</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165640045.png" alt="image-20220615165640045" style="zoom:50%;"></p><p>等待下载完成后点击<code>Continue</code>进入下一步，勾选<code>Basic Setup</code>里的全部组件，点击<code>Apply Changes</code>下载。过程会很漫长，请耐心等待。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170342076.png" alt="image-20220615170342076" style="zoom:50%;"></p><p>配置环境变量，在Path里添加<code>MinGW</code>的<code>bin</code>文件夹：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165848575.png" alt="image-20220615165848575" style="zoom:50%;"></p><p>打开命令行，输入<code>gcc -v</code>，出现类似下图信息即为安装成功</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170030477.png" alt="image-20220615170030477" style="zoom:50%;"></p><h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><p>下载最新版本。<a href="http://gnutoolchains.com/arm-eabi/openocd/">下载链接</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615165310091.png" alt="image-20220615165310091" style="zoom:50%;"></p><p>下载后解压，将文件夹改名为<code>OpenOCD</code>并放置到一个目录，这个目录将在下文中Clion中配置。</p><h3 id="arm-none-eabi-gcc"><a href="#arm-none-eabi-gcc" class="headerlink" title="arm-none-eabi-gcc"></a>arm-none-eabi-gcc</h3><p>下载zip格式的。<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">下载链接</a></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170148180.png" alt="image-20220615170148180" style="zoom:50%;"></p><p>下载后解压，放置到一个目录，这个目录将在下文中Clion中配置。</p><p>配置环境变量，在Path里添加所在文件夹的<code>bin</code>文件夹：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170758145.png" alt="image-20220615170758145" style="zoom:50%;"></p><p>打开命令行，输入<code>arm-none-eabi-gcc -v</code>，出现类似下图信息即为安装成功</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615170651597.png" alt="image-20220615170651597" style="zoom:50%;"></p><h3 id="Clion"><a href="#Clion" class="headerlink" title="Clion"></a>Clion</h3><p>Clion可以去Jetbrain下载，学生可以免费使用。下载安装好之后配置工具链，添加如下图的路径</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171359479.png" alt="image-20220615171359479" style="zoom:50%;"></p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>新建STM32CubeMX项目</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171646399.png" alt="image-20220615171646399" style="zoom:50%;"></p><p>选择用CubeMX打开</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171831417.png" alt="image-20220615171831417" style="zoom:50%;"></p><p>更换芯片型号</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171943646.png" alt="image-20220615171943646" style="zoom:50%;"></p><p>将项目名改成前文Clion创建的工程名，将IDE改成<code>STM32CubeIDE</code>，然后点击生成代码，弹出是否overwrite选择yes</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615172307277.png" alt="image-20220615172307277" style="zoom:50%;"></p><p>代码生成好之后点击Close，回到Clion，会弹出来这个对话框，这里先选择取消，后面再添加。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615172412994.png" alt="image-20220615172412994" style="zoom:50%;"></p><p>打开设置，确定一下cmake为以下配置：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615171523025.png" alt="image-20220615171523025" style="zoom:50%;"></p><p>点击锤子按钮编译，如以上配置无误即可生成<code>hex</code>及<code>bin</code></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615172739473.png" alt="image-20220615172739473" style="zoom:50%;"></p><p>对于一个项目，不可避免地会用到第三方库或者自己创建的<code>.c/.h</code>文件，也就是需要修改<code>CmakeList</code>文件。但这里的<code>CMakelist</code>开头写明了<code>#此文件从模板自动生成! 请勿更改!</code>，其原因为在每一次使用CubeMX生成代码时此文件会被覆盖，用户的代码将不会被保存。所以需要修改模板文件<code>CMakeLists_template.txt</code>。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/CMakeLists_template.png" alt="CMakeLists_template" style="zoom:50%;"></p><p>如上图所示，需要增加头文件及编译文件。对于我们新增的编译文件，可以新增一个<code>MY_SOURCE</code>并在<code>add_executable</code>中添加<code>$&#123;MY_SOURCES&#125;</code>，可以避免修改原模板。</p><p>file里的<code>GLOB_RECURSE</code>意思是对该目录下的所有子文件进行递归添加。而<code>GLOB</code>则不进行递归，只在当前文件夹下查找。可以根据需求选择用哪种。<code>*.*</code>为通配符，意为添加文件夹下的所有文件。</p><h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h2><p>如使用STlink进行烧录，需要添加配置文件。在项目根目录下新建一个<code>stlink.cfg</code>，添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source [find interface/stlink-v2.cfg]</span><br><span class="line">transport select hla_swd</span><br><span class="line">source [find target/stm32f1x.cfg]</span><br><span class="line">adapter speed 10000</span><br></pre></td></tr></table></figure><p>若使用的不是STM32F1或者不是STlink仿真器，可以到OpenOCD安装目录的<code>share\openocd\scripts</code>下寻找对应的配置。芯片在<code>target</code>文件下，仿真器在<code>interface</code>文件夹下。</p><p>然后点击编辑配置</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615174236352.png" alt="image-20220615174236352"></p><p>添加刚刚的配置文件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615174323763.png" alt="image-20220615174323763" style="zoom:50%;"></p><p>然后点击三角形烧录固件</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220615174411604.png" alt="image-20220615174411604"></p><h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><p>调试的时候点击寄存器，没加载svd文件是看不到的，这个文件在keil中可以找到</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220616104531509.png" alt="image-20220616104531509" style="zoom:50%;"></p><p>路径如下：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220616104707730.png" alt="image-20220616104707730" style="zoom:50%;"></p><p>然后全选即可显示。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>实测默认的代码优化会造成许多问题。修改模板文件<code>CMakeLists_template.txt</code>，优化等级均改为<code>-O0</code>：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220616113849054.png" alt="image-20220616113849054" style="zoom:50%;"></p><p>然后在Cubemx中重新生成代码以刷新Cmakelist文件。</p><h2 id="重定向printf"><a href="#重定向printf" class="headerlink" title="重定向printf"></a>重定向printf</h2><p>与在keil5中重定义<code>fputs()</code>函数不一样，在GCC编译器中需要重定义的是<code>__io_putchar(int ch)</code>。</p><p>在main中添加如下代码并引入头文件<code>#include &lt;stdio.h&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1 , (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后即可使用<code>printf</code>函数。且此段代码在Keil和Clion中均可正常编译运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技能" scheme="https://www.robotsfan.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="STM32" scheme="https://www.robotsfan.com/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>MPC——模型预测控制</title>
    <link href="https://www.robotsfan.com/posts/fe8d7b17.html"/>
    <id>https://www.robotsfan.com/posts/fe8d7b17.html</id>
    <published>2022-06-01T13:00:00.000Z</published>
    <updated>2022-06-01T13:03:07.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m1.jpg" alt="m1"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m2.jpg" alt="m2"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m3.jpg" alt="m3"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/m4.jpg" alt="m4"></p><p>代码：</p><p><code>MPC_Test.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 清屏</span></span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"><span class="comment">% 第一步，定义状态空间矩阵</span></span><br><span class="line"><span class="comment">% 定义状态矩阵 A, n*n 矩阵</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">0.1</span>; <span class="number">-1</span> <span class="number">2</span>];</span><br><span class="line">n = <span class="built_in">size</span>(A,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义输入矩阵 B, n*p 矩阵</span></span><br><span class="line">B = [<span class="number">0.2</span> <span class="number">1</span>;<span class="number">0.5</span> <span class="number">2</span>];</span><br><span class="line">p = <span class="built_in">size</span>(B,<span class="number">2</span>);</span><br><span class="line"><span class="comment">% 定义Q矩阵，n*n 矩阵</span></span><br><span class="line">Q = [<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 定义F矩阵，n*n 矩阵</span></span><br><span class="line">F = [<span class="number">100</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 定义R矩阵，p*p 矩阵</span></span><br><span class="line">R = [<span class="number">1</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0.1</span>];</span><br><span class="line"><span class="comment">% 定义step数量k</span></span><br><span class="line">k_steps = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 定义矩阵 X_K， n*k 矩 阵</span></span><br><span class="line">X_K = <span class="built_in">zeros</span>(n,k_steps);</span><br><span class="line"><span class="comment">% 初始状态变量值， n*1 向量</span></span><br><span class="line">X_K(:,<span class="number">1</span>) = [<span class="number">20</span>;<span class="number">-20</span>];</span><br><span class="line"><span class="comment">% 定义输入矩阵 U_K， p*k 矩阵</span></span><br><span class="line">U_K = <span class="built_in">zeros</span>(p,k_steps);</span><br><span class="line"><span class="comment">% 定义预测区间K</span></span><br><span class="line">N = <span class="number">5</span>;</span><br><span class="line"><span class="comment">% Call MPC_Matrices 函数 求得 E,H矩阵</span></span><br><span class="line">[E,H] = MPC_Matrices(A,B,Q,R,F,N);</span><br><span class="line"><span class="comment">% 计算每一步的状态变量的值</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : k_steps</span><br><span class="line">    <span class="comment">% 求得U_K(:,k)</span></span><br><span class="line">    U_K(:,k) = Prediction(X_K(:,k),E,H,N,p);</span><br><span class="line">    <span class="comment">% 计算第k+1步时状态变量的值</span></span><br><span class="line">    X_K(:,k+<span class="number">1</span>) = (A*X_K(:,k) + B*U_K(:,k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 绘制状态变量和输入的变化</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(X_K,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(X_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>)</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(U_K,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">plot</span>(U_K(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>MPC_Matrices.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[E,H]</span> = <span class="title">MPC_Matrices</span><span class="params">(A,B,Q,R,F,N)</span></span></span><br><span class="line">    n=<span class="built_in">size</span>(A,<span class="number">1</span>); <span class="comment">% A是n*n矩阵,得到n</span></span><br><span class="line">    p=<span class="built_in">size</span>(B,<span class="number">2</span>); <span class="comment">% B是n*p矩阵,得到p</span></span><br><span class="line">    M=[<span class="built_in">eye</span>(n);<span class="built_in">zeros</span>(N*n,n)]; <span class="comment">% 初始化M矩阵,M矩阵是(N+1)n*n的,</span></span><br><span class="line">                             <span class="comment">% 它上面是n*n个&quot;I&quot;,这一步先把下半部分写成0</span></span><br><span class="line">    C=<span class="built_in">zeros</span>((N+<span class="number">1</span>)*n,N*p); <span class="comment">% 初始化C矩阵,这一步令它有(N+1)n*NP个0</span></span><br><span class="line">    <span class="comment">% 定义M和C</span></span><br><span class="line">    tmp=<span class="built_in">eye</span>(n); <span class="comment">% 定义一个n*n 的 I 矩阵</span></span><br><span class="line">    <span class="comment">% 更新Ｍ和C</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N <span class="comment">% 循环,i从1到N</span></span><br><span class="line">        rows =<span class="built_in">i</span>*n+(<span class="number">1</span>:n); <span class="comment">%定义当前行数,从i*n开始，共n行</span></span><br><span class="line">        C(rows,:)=[tmp*B,C(rows-n, <span class="number">1</span>:<span class="keyword">end</span>-p)]; <span class="comment">%将c矩阵填满</span></span><br><span class="line">        tmp= A*tmp; <span class="comment">%每一次将tmp左乘一次A</span></span><br><span class="line">        M(rows,:)=tmp; <span class="comment">%将M矩阵写满</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 定义Q_bar和R_bar</span></span><br><span class="line">    Q_bar = kron(<span class="built_in">eye</span>(N),Q);</span><br><span class="line">    Q_bar = <span class="built_in">blkdiag</span>(Q_bar,F);</span><br><span class="line">    R_bar = kron(<span class="built_in">eye</span>(N),R);</span><br><span class="line">    <span class="comment">% 计算G,E,H</span></span><br><span class="line">    G=M&#x27;*Q_bar*M; <span class="comment">% G: n*n</span></span><br><span class="line">    E=C&#x27;*Q_bar*M; <span class="comment">% E: NP*n</span></span><br><span class="line">    H=C&#x27;*Q_bar*C+R_bar; <span class="comment">% NP*NP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Prediction.m</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u_k</span>= <span class="title">Prediction</span><span class="params">(x_k,E,H,N,p)</span></span></span><br><span class="line">    U_k = <span class="built_in">zeros</span>(N*p,<span class="number">1</span>); <span class="comment">% NP x 1</span></span><br><span class="line">    U_k = quadprog(H,E*x_k);</span><br><span class="line">    u_k = U_k(<span class="number">1</span>:p,<span class="number">1</span>); <span class="comment">% 取第一个结果</span></span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/dafaah.png" alt="dafaah" style="zoom:50%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="控制" scheme="https://www.robotsfan.com/categories/%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="控制" scheme="https://www.robotsfan.com/tags/%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>ROS2——教你写新版Launch文件</title>
    <link href="https://www.robotsfan.com/posts/7a5950c4.html"/>
    <id>https://www.robotsfan.com/posts/7a5950c4.html</id>
    <published>2022-05-04T10:30:00.000Z</published>
    <updated>2022-05-05T05:05:06.758Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ROS2——教你写新版Launch文件"><a href="#ROS2——教你写新版Launch文件" class="headerlink" title="ROS2——教你写新版Launch文件"></a>ROS2——教你写新版Launch文件</h1><h2 id="为什么需要launch"><a href="#为什么需要launch" class="headerlink" title="为什么需要launch"></a>为什么需要launch</h2><p>如需启动一个节点，只需要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run package-name execute-name</span><br></pre></td></tr></table></figure><p>但如果需要启动多个节点，一个一个启动需要开很多终端输入很多条命令，所以可以使用launch文件批量启动。</p><h2 id="如何编写launch文件"><a href="#如何编写launch文件" class="headerlink" title="如何编写launch文件"></a>如何编写launch文件</h2><p>在ROS1中launch文件是一种格式以<code>.launch</code>结尾的xml文档；而在ROS2中推荐使用Python方式编写launch文件，此时的launch文件是一种格式以<code>.launch.py</code>结尾的Python脚本。</p><h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>对于一个基础的启动节点的launch文件，需要引用以下库，然后创建一个名为做<code>generate_launch_description</code>的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_launch_description</span>():</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p><strong>下文中未注明的均在<code>generate_launch_description()</code>函数中进行操作。</strong></p><p>创建<code>LaunchDescription</code>的对象<code>ld</code>（名字任意）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld = LaunchDescription()</span><br></pre></td></tr></table></figure><p>然后创建一个<code>Actions.Node</code>对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example-node = Node(</span><br><span class="line">    package=<span class="string">&#x27;package-name&#x27;</span>, <span class="comment">#节点所在的功能包</span></span><br><span class="line">    namespace=<span class="string">&#x27;package-namespace&#x27;</span>, <span class="comment">#命名空间。如果存在同名节点，这一选项会有用</span></span><br><span class="line">    executable=<span class="string">&#x27;execute-name/script-name.py&#x27;</span>, <span class="comment">#表示要运行的可执行文件名或脚本名字.py</span></span><br><span class="line">    parameters=[&#123;<span class="string">&#x27;parameter-name&#x27;</span>: parameter-value&#125;], <span class="comment">#参数</span></span><br><span class="line">    arguments=[<span class="string">&#x27;-xxx&#x27;</span>, xxx,  <span class="string">&#x27;-xxx&#x27;</span>, xxx ], <span class="comment">#启动参数</span></span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span>, <span class="comment">#用于将话题信息打印到屏幕</span></span><br><span class="line">    name=<span class="string">&#x27;node-name&#x27;</span> <span class="comment">#表示启动后的节点名，可以没有</span></span><br><span class="line">    remappings=[ <span class="comment">#重映射</span></span><br><span class="line">        (<span class="string">&#x27;/xxx/xxx-new&#x27;</span>, <span class="string">&#x27;/xxx/xxx-old&#x27;</span>),</span><br><span class="line">]</span><br><span class="line">)</span><br><span class="line">example-node2 = Node(</span><br><span class="line">......</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将上面所有的Node对象加入<code>ld</code>，然后返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ld.add_action(example-node)</span><br><span class="line">ld.add_action(example-node2)</span><br><span class="line"><span class="keyword">return</span> launch_description</span><br></pre></td></tr></table></figure><h3 id="调用shell命令"><a href="#调用shell命令" class="headerlink" title="调用shell命令"></a>调用shell命令</h3><p>需要添加头文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> ExecuteProcess</span><br></pre></td></tr></table></figure><p>使用<code>ExecuteProcess</code>调用shell命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example_cmd = ExecuteProcess(</span><br><span class="line">    cmd=[<span class="string">&#x27;some-cmd&#x27;</span>, <span class="string">&#x27;some-cmd&#x27;</span>], <span class="comment">#命令，用逗号隔开</span></span><br><span class="line">    additional_env=&#123;<span class="string">&#x27;EXAMPLE_PATH&#x27;</span>: path&#125;, <span class="comment">#可以添加临时的环境变量</span></span><br><span class="line">    output=<span class="string">&#x27;screen&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(example_cmd)</span><br></pre></td></tr></table></figure><h3 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h3><p>使用<code>FindPackageShare</code>获取package路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch_ros.substitutions <span class="keyword">import</span> FindPackageShare</span><br><span class="line">......</span><br><span class="line">package-name = ‘example-package’</span><br><span class="line">package-path = FindPackageShare(package = package-name).find(package-name) </span><br></pre></td></tr></table></figure><p>或者使用<code>get_package_share_directory</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ament_index_python.packages <span class="keyword">import</span> get_package_share_directory</span><br><span class="line">......</span><br><span class="line">package-name = ‘example-package’</span><br><span class="line">package-path = get_package_share_directory(package-name),</span><br></pre></td></tr></table></figure><h3 id="连接路径"><a href="#连接路径" class="headerlink" title="连接路径"></a>连接路径</h3><h4 id="使用join"><a href="#使用join" class="headerlink" title="使用join"></a>使用join</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">...</span><br><span class="line"><span class="comment">#文件</span></span><br><span class="line">file-name = <span class="string">&#x27;example-file.xxx&#x27;</span></span><br><span class="line"><span class="comment">#字符串前加`f`表示可以在字符串里面使用用花括号括起来的变量和表达式，如定义好的`file-name`</span></span><br><span class="line">file-path = os.path.join(package-path, <span class="string">f&#x27;example-folder/<span class="subst">&#123;file-name&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment">#或者使用逗号隔开</span></span><br><span class="line">file-path = os.path.join(package-path, <span class="string">&#x27;example-folder&#x27;</span>, file-name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#路径</span></span><br><span class="line"><span class="built_in">dir</span>-path = os.path.join(package-path, <span class="string">&#x27;example-folder/&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="使用替换"><a href="#使用替换" class="headerlink" title="使用替换"></a>使用替换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> PathJoinSubstitution</span><br><span class="line">...</span><br><span class="line">PathJoinSubstitution([</span><br><span class="line">    FindPackageShare(<span class="string">&#x27;example-package&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;example-folder&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;example-file.xxx&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="改变参数"><a href="#改变参数" class="headerlink" title="改变参数"></a>改变参数</h3><p>一般需要用到以下两个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> LaunchConfiguration</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> DeclareLaunchArgument</span><br></pre></td></tr></table></figure><p><code>LaunchConfiguration</code>用于在变量中存储启动参数的值并将它们传递给所需的操作，允许我们在launch文件的任何部分获取启动参数的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example-cfg = LaunchConfiguration(<span class="string">&#x27;arg-name&#x27;</span>, default=<span class="string">&#x27;true&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>DeclareLaunchArgument</code>用于定义可以从上述启动文件或控制台传递的启动参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example-arg = DeclareLaunchArgument(</span><br><span class="line">    <span class="string">&#x27;arg-name&#x27;</span>,</span><br><span class="line">    default_value=<span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;some description&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(example-arg)</span><br></pre></td></tr></table></figure><h3 id="启动另一个launch文件"><a href="#启动另一个launch文件" class="headerlink" title="启动另一个launch文件"></a>启动另一个launch文件</h3><p>假设已经存在很多的单独的launch文件用于启动不同的功能，如果需要同时启动这些launch文件，可以使用<code>IncludeLaunchDescription</code>在launch文件中嵌套启动launch文件，这样可以提高复用率。</p><p>需要以下两个头文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> IncludeLaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.launch_description_sources <span class="keyword">import</span> PythonLaunchDescriptionSource</span><br></pre></td></tr></table></figure><p>使用<code>IncludeLaunchDescription</code>嵌套launch文件，其中同样可以使用上文所述的传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">another-launch = IncludeLaunchDescription(</span><br><span class="line">    PythonLaunchDescriptionSource(</span><br><span class="line">    os.path.join(launch_file_dir, <span class="string">&#x27;launch-file-name.launch.py&#x27;</span>)</span><br><span class="line">    ),</span><br><span class="line">    launch_arguments=&#123;<span class="string">&#x27;arg-name&#x27;</span>: example-arg&#125;.items()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ld.add_action(another-launch)</span><br></pre></td></tr></table></figure><h3 id="在另一个launch文件中使用参数"><a href="#在另一个launch文件中使用参数" class="headerlink" title="在另一个launch文件中使用参数"></a>在另一个launch文件中使用参数</h3><p>这是一个困扰了我两天的，比较麻烦的简单问题。我们来看一个实例：这个launch文件有一个字符串格式的路径作为参数，其中的<code>robot_state_publisher</code>需要传入<code>robot_description</code>作为参数，而这个参数需要使用<code>open()</code>，也就是需要那个路径参数。我们自然而然会想到使用<code>LaunchConfiguration</code>，但是当你试图获取<code>urdf_path_cfg</code>的时候会发现这根本不是一个字符串。具体解决方案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> DeclareLaunchArgument</span><br><span class="line"><span class="keyword">from</span> launch.substitutions <span class="keyword">import</span> LaunchConfiguration</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> launch.actions <span class="keyword">import</span> OpaqueFunction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launch_setup</span>(<span class="params">context, *args, **kwargs</span>):</span></span><br><span class="line">    use_sim_time_cfg = LaunchConfiguration(<span class="string">&#x27;use_sim_time&#x27;</span>)</span><br><span class="line">    urdf_path_cfg = LaunchConfiguration(<span class="string">&#x27;urdf_path&#x27;</span>)</span><br><span class="line">    urdf_path = urdf_path_cfg.perform(context)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[92m&#x27;</span> + <span class="string">&quot;robot_state_publisher: Use urdf dir: &quot;</span> + urdf_path + <span class="string">&#x27;\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(urdf_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infp:</span><br><span class="line">        robot_desc = infp.read()</span><br><span class="line"></span><br><span class="line">    robot_state_publisher_node = Node(</span><br><span class="line">        package=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        executable=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        name=<span class="string">&#x27;robot_state_publisher&#x27;</span>,</span><br><span class="line">        output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">        parameters=[&#123;</span><br><span class="line">            <span class="string">&#x27;use_sim_time&#x27;</span>: use_sim_time_cfg,</span><br><span class="line">            <span class="string">&#x27;robot_description&#x27;</span>: robot_desc</span><br><span class="line">        &#125;]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        robot_state_publisher_node,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_launch_description</span>():</span></span><br><span class="line"></span><br><span class="line">    ld = LaunchDescription()</span><br><span class="line"></span><br><span class="line">    use_sim_time_arg = DeclareLaunchArgument(</span><br><span class="line">        <span class="string">&#x27;use_sim_time&#x27;</span>,</span><br><span class="line">        default_value=<span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">        description=<span class="string">&#x27;Use simulation (Gazebo) clock if true&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    urdf_path_arg = DeclareLaunchArgument(</span><br><span class="line">        <span class="string">&#x27;urdf_path&#x27;</span>,</span><br><span class="line">        default_value=<span class="string">&#x27;robot.urdf&#x27;</span>,</span><br><span class="line">        description=<span class="string">&#x27;urdf_path&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ld.add_action(urdf_path_arg)</span><br><span class="line">    ld.add_action(use_sim_time_arg)</span><br><span class="line">    ld.add_action(OpaqueFunction(function=launch_setup))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ld</span><br></pre></td></tr></table></figure><p>这种写法我个人认为极其不优雅，但是确实能解决实际问题。</p><p>强烈建议ROS加入获取参数内容的方法！！！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="ROS机器人学习" scheme="https://www.robotsfan.com/categories/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ROS" scheme="https://www.robotsfan.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>手撕卡尔曼滤波器</title>
    <link href="https://www.robotsfan.com/posts/b4727fbe.html"/>
    <id>https://www.robotsfan.com/posts/b4727fbe.html</id>
    <published>2022-04-14T14:36:00.000Z</published>
    <updated>2022-04-15T12:12:19.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手撕卡尔曼滤波器"><a href="#手撕卡尔曼滤波器" class="headerlink" title="手撕卡尔曼滤波器"></a>手撕卡尔曼滤波器</h1><p>卡尔曼滤波器（Kalman Filter），从字面意思上来看，“Filter滤波器”一词并不能很好地体现其特性。卡尔曼滤波器用一句话来说就是“Optimal Recursive Data-Processing Algorithm”，即为“最优化 递归 数字处理 算法”，它更像是一种观测器，而不是一般意义上的滤波器。卡尔曼滤波器的应用非常广泛，尤其是在导航中。它的广泛应用是因为世界中存在大量的不确定性，当我们描述一个系统时，这个不确定性主要体现在三个方面：</p><ol><li>不存在完美的数学模型</li><li>系统的扰动不可控，也很难建模</li><li>测量传感器存在误差</li></ol><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>下面看一个例子，多次用同一把尺子测量同一枚硬币的直径，用 $z_k$ 表示第k次的测量结果。由于种种误差，测量得到：</p><script type="math/tex; mode=display">\begin{aligned}z_1=50.1mm \\z_2=50.4mm \\z_3=50.2mm\end{aligned}</script><p>此时如果要估计真实结果，自然而然地会想到取平均值。用 $\hat{x}_k$ 表示第k次的估计值，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\hat{x}_k &= \frac{1}{k}(z_1+z_2+\cdots+z_k)\\          &= \frac{1}{k}(z_1+z_2+\cdots+z_{k-1}) + \frac{1}{k}(z_k)\\          &= \frac{k-1}{k}\frac{1}{k-1}(z_1+z_2+\cdots+z_{k-1}) + \frac{1}{k}(z_k)\\          &= \frac{k-1}{k}\hat{x}_{k-1} + \frac{1}{k}(z_k)\\          &= \hat{x}_{k-1} + \frac{1}{k}(z_k-\hat{x}_{k-1})\end{aligned}</script><p>上式中，第三行 $\frac{1}{k-1}(z_1+z_2+\cdots+z_{k-1})$ 就是 $k-1$ 次的平均值 $\hat{x}_{k-1}$ </p><p>观察最后一行结论，$k\uparrow, \frac{1}{k-1}\to0,\hat{x}_k\to\hat{x}_{k-1}$ ，也就是说，随着k的增加，此时拥有了大量的数据，对估计的结果就比较有信心了，测量的结果就不是很重要了。相反，如果k比较小， $\frac{1}{k-1}$ 就会比较大，测量结果 $z_k$ 就会起到很大的作用，尤其是测量结果和估计值差距比较大的时候。</p><p>令 $K_k=\frac{1}{k-1}$ ，则此时公式可以表示为：</p><script type="math/tex; mode=display">\hat{x}_k = \hat{x}_{k-1} + K_k(z_k-\hat{x}_{k-1})</script><p>上式表示的含义为：当前的估计值 = 上一次的估计值 + 系数 * ( 当前测量值 - 上一次的估计值 ) ，其中的 $K_k$ 就是卡尔曼增益/因数（Kalman Gain），通过这个公式可以看出，新的估计值 $\hat{x}_k$ 与上一次的估计值 $\hat{x}_{k-1}$ 有关，上一次的又与上上次的有关，这就是一种递归思想（Recursive），这也是卡尔曼滤波器的优势，他不需要追溯很久以前的数据，只需要上一次的就可以。下面来讨论一下这个 $K_k$ ：</p><p>引入两个误差：</p><ol><li>估计误差 $e_{EST}$ （e代表误差error，EST代表估计estimate）</li><li>测量误差 $e_{MEA}$ （e代表误差error，MEA代表测量measurement）</li></ol><p>则 $K_k$ 可以表示为</p><script type="math/tex; mode=display">K_k = \frac{e_{EST_{k-1}}}{e_{EST_{k-1}}+e_{MEA_{k}}}</script><p>这个公式是卡尔曼滤波中的核心公式，具体的推导后文会讲到。下面对这个公式进行讨论。在k时刻，</p><ol><li>当 $e_{EST_{k-1}} \gg e_{MEA_{k}}$ ， $K_k\rightarrow1$ ，此时 $\hat{x}_k = z_k$ ，这说明当第k-1次的估计误差远大于第k次的测量误差时，第k次的估计值很趋近于测量值。（估计的误差大，测量的误差小，更信任测量值）</li><li>当 $e_{EST_{k-1}} \ll e_{MEA_{k}}$ ， $K_k\rightarrow 0$ ，此时 $\hat{x}_k = \hat{x}_{k-1}$ ，这说明当第k-1次的估计误差远小于第k次的测量误差时，第k次的估计值很趋近于测量值。（估计的误差小，测量的误差大，更信任估计值）</li></ol><p>运用以上知识，解决一个实际问题可以分为三步：</p><ol><li>计算卡尔曼增益 $K_k$ ，公式见前文</li><li>计算估算值 $\hat{x}_k$ ，公式见前文</li><li>更新估计误差 $e_{EST_{k}} = (1-K_k)e_{EST_{k-1}}$ ，此公式推导见后文。</li></ol><p>再看前文测量硬币直径的例子，实际长度 $x=50mm$ ，对于第一次测量：</p><script type="math/tex; mode=display">\begin{aligned}\hat{x}_0=40mm \\e_{EST_{0}}=5mm \\z_1=51mm\\e_{MEA_{k}}=3mm\end{aligned}</script><p>估计值是是随便估计的一个值；估计误差随便给一个数；测量值是实际测量得到的；由于测量工具不变，测量误差是一个恒定值。接下来进行递归：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220414223222370.png" alt="image-20220414223222370"></p><p>蓝色是测量值 $z_k$ ，红色为估计值 $\hat{x}_k$ ，可以看到经过反复迭代，估计值越来越接近实际值。这就是卡尔曼滤波器的递归思想。</p><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h3><p>下面举例说明数据融合（Data Fusion）</p><p>分别用两个称称一个东西，得到两个结果，分别为</p><script type="math/tex; mode=display">\begin{aligned}z_1=30mm \\z_2=32mm \end{aligned}</script><p>两个称都有误差，两个称的标准差（Standard Deviation）分别为：</p><script type="math/tex; mode=display">\begin{aligned}\sigma_1=2g \\\sigma_2=4g \end{aligned}</script><p>他们均符合正态分布/高斯分布（Natural/Gaussin Distribution）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415103427679.png" alt="image-20220415103427679"></p><p>如果用这两个结果去估计真实值 $\hat{z}=?$ ，可以用到上一节的思想，则</p><script type="math/tex; mode=display">\begin{array}{c}\hat{z} = z_{1} + K(z_2-z_{1}),k\in[0,1] \\k=0,\hat{z}=z_1\\ k=1,\hat{z}=z_2\end{array}</script><p>求k使得 $\sigma_{\hat{z}}$ 最小，也就是使得方差 $Var(\hat{z})$ 最小</p><script type="math/tex; mode=display">\begin{aligned}\sigma_{\hat{z}}^2&=Var(\hat{z})\\                &=Var(z_1 + K(z_2-z_1))\\                &=Var(z_1 -Kz_1+ Kz_2)\\                &=Var((1-K)z_1+ Kz_2)\\                &=Var((1-K)z_1)+Var(Kz_2)\\                &=(1-K)^2Var(z_1)+K^2Var(z_2)\\                &=(1-K)^2\sigma_1^2+K^2\sigma_2^2\\\end{aligned}</script><p>可以看到，第四行中 $(1-K)z_1$ 和 $Kz_2$ 是互相独立的，因为两个称的结果不会互相影响，所以由于方差的性质可以写成两个独立的方差。要求这个式子的最小值，就要对K求导并令导数等于0。可以解出K：</p><script type="math/tex; mode=display">\begin{array}{c}\frac{d\sigma_{\hat{z}}^2}{dK}=0\\-2(1-K)\sigma_1^2+2K\sigma_2^2=0\\K=\frac{\sigma_1^2}{\sigma_1^2+\sigma_2^2}=\frac{2^2}{2^2+4^2}=0.2\end{array}</script><p>将K带入上面的式子，得到 $\hat{z}=30.4$ 。此时为最优解。计算此时的标准差 $\sigma_{\hat{z}}=1.79$ ，绘出正态分布图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415105843056.png" alt="image-20220415105843056"></p><p>得到比两个图形更高更瘦的图形，这个过程就叫数据融合。</p><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><p>协方差矩阵（Covarince Matrix）是把方差和协方差在一个矩阵中表示出来，体现了变量间的联动关系。下面举例说明：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415121131214.png" alt="image-20220415121131214"></p><p>令身高为x，体重为y，年龄为z，分别计算平均值，方差和协方差（拿x举例）：</p><script type="math/tex; mode=display">\begin{aligned}\sigma_x^2&=\frac{1}{3}((179-180.3)^2\\&\qquad+(187-180.3)^2\\&\qquad+(175-180.3)^2)\\&=24.89\\\sigma_x\sigma_y&=\frac{1}{3}((179-180.3)(74-75)\\&\qquad+(187-180.3)(80-75)\\&\qquad+(175-180.3)(71-75))\\&=18.7=\sigma_y\sigma_x\end{aligned}</script><p>观察协方差的每一项，如果两个括号内都为负数，相乘为正数；两个括号内都为正数，相乘仍为正数；但一正一负相乘得到负数。所以最后加在一起的结果如果是正数，说明这两个变量的变化方向是一样的；如果是负数，说明这两个变量的变化方向是相反的。</p><p>协方差矩阵表示形式为：</p><script type="math/tex; mode=display">P = \begin{bmatrix}    \sigma_x^2 & \sigma_x\sigma_y & \sigma_x\sigma_z \\    \sigma_y\sigma_x & \sigma_y^2 & \sigma_y\sigma_z \\    \sigma_z\sigma_x & \sigma_z\sigma_y & \sigma_z^2  \end{bmatrix}</script><p>如果需要编程实现，可以通过以下方法求得P（其中a为过渡矩阵）</p><script type="math/tex; mode=display">\begin{aligned}a & = \begin{bmatrix}    x_1 & y_1 & z_1 \\    x_2 & y_2 & z_2 \\    x_3 & y_3 & z_3  \end{bmatrix}-\frac{1}{3}\begin{bmatrix}    1 & 1 & 1 \\    1 & 1 & 1 \\    1 & 1 & 1  \end{bmatrix}\begin{bmatrix}    x_1 & y_1 & z_1 \\    x_2 & y_2 & z_2 \\    x_3 & y_3 & z_3  \end{bmatrix}\\P & = \frac{1}{3}a^Ta\end{aligned}</script><p>多取一些数据，得到协方差矩阵，可以利用协方差矩阵分析各个数据之间的关系；</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415113508938.png" alt></p><p>从协方差矩阵中可以看到，对角线上的数为方差，这些数据比较大，说明了这些变量之间跨度比较大。剩下的数据为协方差，体重和身高的协方差比较大，说明他们是正相关的，身高增加体重也增加；而年龄和其余两者的协方差比较小，说明他们之间的相关性比较小。</p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><p>状态空间表达（State Space Representation），现代控制理论就是以状态空间方程为基础的。以弹簧振动阻尼系统为例：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220415113931219.png" alt="image-20220415113931219"></p><p>动态方程表达式为：</p><script type="math/tex; mode=display">m\ddot{x}+B\dot{x}+kx=F</script><p>将F定义为u，也就是系统的输入（Input）。将其转化成状态空间表达形式，定义两个状态（State）变量 $x_1=x$ ， $x_2=\dot{x}$ ，则</p><script type="math/tex; mode=display">\begin{aligned}\dot{x_1}&=x_2\\\dot{x_2}&=\ddot{x}\\         &=\frac{1}{m}u-\frac{B}{m}\dot{x}-\frac{k}{m}x\\         &=\frac{1}{m}u-\frac{B}{m}x_2-\frac{k}{m}x_1\end{aligned}</script><p>这样就用两个一阶微分方程表达出来了。定义两个测量（Meansurement）变量，位置 $z_1=x=x_1$ ，速度 $z_2=\dot{x}=x_2$ </p><p>将上面的式子改写成矩阵形式：</p><script type="math/tex; mode=display">\begin{aligned}\begin{bmatrix}    \dot{x_1} \\    \dot{x_2} \end{bmatrix} & = \begin{bmatrix}    0            & 1 \\  -\frac{k}{m} & -\frac{B}{m}\end{bmatrix}\begin{bmatrix}    x_1 \\    x_2 \end{bmatrix}+\begin{bmatrix}    0 \\    \frac{1}{m} \end{bmatrix}u\\\begin{bmatrix}    z_1 \\    z_2 \end{bmatrix} & = \begin{bmatrix}    1 & 0 \\  0 & 1\end{bmatrix}\begin{bmatrix}    x_1 \\    x_2 \end{bmatrix}\end{aligned}</script><p>归纳出状态空间的表达形式：</p><script type="math/tex; mode=display">\begin{array}{l}\dot{x}(t)=Ax(t)+Bu(t)\\z(t)=Hx(t)\end{array}</script><p>这是一种连续的表达形式， $\dot{x}(t)$ 为x对时间的导数，体现了x随时间的变化。</p><p>如果写成离散形式(本节不深入讲解离散型，只做了解)，其中下标 $k-1,k,k+1$ 里面的1代表一个时间单位，即为采样时间（Sample Time），这种形式体现了上一步到这一步的一种变化：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=Ax_{k-1}+Bu_{k-1}\\z_k=Hx_k\end{array}</script><p>如果增加一些开头提到的不确定性，其中 $w_{k-1}$ 为过程噪音（Process Noise）， $v_k$ 为测量噪音（Meansurement Noise）：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_k=Hx_k+v_k\end{array}</script><p>也就是说当估计结果 $x_k$ 不准确，测量结果 $z_k$ 也不准确的情况下，如何估计一个精确的 $\hat{x}_k$ ？这就是卡尔曼滤波器所要解决的问题。</p><h2 id="卡尔曼增益数学推导"><a href="#卡尔曼增益数学推导" class="headerlink" title="卡尔曼增益数学推导"></a>卡尔曼增益数学推导</h2><p>在上文的状态空间方程中， $x_k$ 为状态变量，A为状态矩阵，B为控制矩阵， $u_k$ 为控制， $w_{k-1}$ 为过程噪音， $v_k$ 为测量噪音，其中噪声是不可测的，是系统不确定性的表现。但过程噪声可以假设其符合正态分布 $P(w)\sim N(0,Q)$ ，其中0为期望，Q为协方差矩阵：</p><script type="math/tex; mode=display">\begin{aligned}Q&=E(ww^T)\\ &=E\left(         \begin{bmatrix}            w_1 \\            w_2          \end{bmatrix}         \begin{bmatrix}            w_1 & w_2           \end{bmatrix}     \right)\\ &=E\left(         \begin{bmatrix}            w_1^2  & w_1w_2\\            w_2w_1 & w_2^2         \end{bmatrix}     \right)\\ &=     \begin{bmatrix}       E(w_1^2)  & E(w_1w_2)\\       E(w_2w_1) & E(w_2^2)     \end{bmatrix}\\ &=     \begin{bmatrix}        \sigma_{w_1}^2 & \sigma_{w_1}\sigma_{w_2} \\        \sigma_{w_2}\sigma_{w_1} & \sigma_{w_2}^2     \end{bmatrix}\end{aligned}</script><p>通过Q这个协方差矩阵可以表示出过程噪声的方差，亦可以表示出过程噪声之间的关系。</p><p>对于测量噪声也同样认为符合正态分布 $P(v)\sim N(0,R)$ ， $R=E(vv^T)$ 同样为协方差矩阵，形同Q。</p><p>但建模的时候噪音是不知道的，所以我们只能测得除掉噪声其余的项，表示为 $\hat{x}_k^-$ ，这是一个估计值所以要加一个hat。此时我们没有做任何处理，只是根据上面的式子去掉噪声得来，所以在上面加一个负号，代表先验估计。</p><script type="math/tex; mode=display">\begin{array}{l}\hat{x}_k^-=A\hat{x}_{k-1}+Bu_{k-1}\\z_k=Hx_k \to \hat{x}_{k_{mea}}=H^{-1}z_k\end{array}</script><p>上式中第一行 $\hat{x}_k^-$ 为算出来的结果，第二行 $\hat{x}_{k_{mea}}$ 为测出来的结果，但他们都不具备测量噪声这一项，他们都是不太准确的。这时可以运用卡尔曼滤波器通过两个不太准确的结果得到一个准确的结果。</p><p>回忆之前数据融合的概念，对于最终的估计值， $\hat{x}_k$ （后验估计） 可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}\hat{x}_k=\hat{x}_k^- + G(H^{-1}z_k-\hat{x}_k^-),G\in[0,1]\\\end{array}</script><ul><li>当 $G=0$ ， $\hat{x}_k=\hat{x}_k^-$ ，此时更相信计算结果</li><li>当 $G=1$ ， $\hat{x}_k=H^{-1}z_k$ ，此时更相信测量结果</li></ul><p>在许多教材中会令 $G=K_kH$ ，卡尔曼滤波器可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-),K_k\in[0,H^{-1}]\\\end{array}</script><ul><li><p>当 $K_k=0$ ， $\hat{x}_k=\hat{x}_k^-$ ，此时更相信计算结果</p></li><li><p>当 $K_k=H^{-1}$ ， $\hat{x}_k=H^{-1}z_k$ ，此时更相信测量结果</p></li></ul><p>接下来的目标就是<strong>寻找 $K_k$ ，使得误差最小</strong>，也就是说使得估计值 $\hat{x}_k$ 趋近于实际值 $x_k$ 。很明显， $K_k$ 的取值与<strong>计算误差</strong>和<strong>测量误差</strong>息息相关，当测量误差特别大时会更相信计算出来的结果，当计算误差特别大时会更相信测量出来的结果。</p><p>令误差 $e_k=x_k-\hat{x}_k$ ，其同样符合正态分布 $P(e_k)\sim N(0,P)$ </p><script type="math/tex; mode=display">\begin{aligned}P=E(ee^T)=     \begin{bmatrix}        \sigma_{e_1}^2 & \sigma_{e_1}\sigma_{e_2} \\        \sigma_{e_2}\sigma_{e_1} & \sigma_{e_2}^2     \end{bmatrix}\end{aligned}</script><p>如果新估计出的 $x_k$ 距离实际值越小，说明误差的方差越小，说明越接近期望值0。而方差之和为P的迹 $tr(P)=\sigma_{e_1}^2+\sigma_{e_2}^2$ ，所以要想让方差最小，接下来的目标就变成了选取合适的 $K_k$ ，使得协方差<strong>矩阵P的迹最小</strong></p><script type="math/tex; mode=display">\begin{aligned}P&=E\left(ee^T\right)\\ &=E\left( \left(x_k-\hat{x}_k\right)\left(x_k-\hat{x}_k\right)^T \right)\end{aligned}</script><p>下面求 $x_k-\hat{x}_k$ ，其中的 $z_k$ 是真实测量的结果，所以 $z_k=Hx_k+v_k$ 。因为 $e_k=x_k-\hat{x}_k$ ，所以可以定义先验误差 $e_k^-=x_k-\hat{x}_k^-$ </p><script type="math/tex; mode=display">\begin{aligned}x_k-\hat{x}_k&=x_k-(\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-))\\&=(I-K_kH)(x_k-\hat{x}_k^-)-K_kv_k \\&=(I-K_kH)e_k^--K_kv_k\end{aligned}</script><p>前文提到， $e_k^-$ 和 $e_k^-$ 的方差都是0，且令先验误差的协方差矩阵 $P_k^-=E(e_k^-{e_k^-}^T)$ 。此时第k步的 $P_k$ 可以整理为</p><script type="math/tex; mode=display">\begin{aligned}P_k&=E\left( \left(x_k-\hat{x}_k\right)\left(x_k-\hat{x}_k\right)^T \right)\\ &=E\left( \left(\left(I-K_kH\right)e_k^--K_kv_k\right)\left(\left(I-K_kH\right)e_k^--K_kv_k\right)^T \right)\\ &=P_k^--K_kHP_k^--(K_kHP_k^-)^T+K_kHP_k^-H^TK_k^T+K_kRK_k^T\end{aligned}</script><p>此时可以计算 $P_k$ 的迹</p><script type="math/tex; mode=display">\begin{aligned}tr(P_k)&=tr(P_k^-)-2tr(K_kHP_k^-)+tr(K_kHP_k^-H^TK_k^T)+tr(K_kRK_k^T)\end{aligned}</script><p>寻找k使得 $tr(P_k)$ 有最小值，对k求导并寻找极值点（求导法则略）</p><script type="math/tex; mode=display">\begin{aligned}\frac{dtr(P_k)}{dk}=0-2(HP_k^-)^T+2K_kHP_k^-H^T+2K_kR=0\\\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}\\\end{aligned}</script><p>至此，我们推出的 $K_k$ 就是卡尔曼增益。这也是卡尔曼滤波器中最核心的公式。</p><p>其中的R是测量噪声的协方差矩阵，R的大小代表了测量噪声方差的大小，也就是 测量噪声的大小。分析 $K_k$ ：</p><ul><li>当R很大， $K_k\to0$ ， $\hat{x}_k=\hat{x}_k^-$ ，此时更相信计算结果</li><li>当R很小， $K_k=\frac{P_k^-H^T}{HP_k^-H^T}=H^{-1},\hat{x}_k=H^{-1}z_k$ ，此时更相信测量结果</li></ul><h2 id="误差协方差矩阵数学推导"><a href="#误差协方差矩阵数学推导" class="headerlink" title="误差协方差矩阵数学推导"></a>误差协方差矩阵数学推导</h2><p>现在来推导卡尔曼增益 $K_k$ 中的先验误差的协方差矩阵 $P_k^-$ 。</p><p>根据前文的结论，我们可以得到真实值 $x_k$ ，先验估计 $\hat{x}_k^-$ ，后验估计 $\hat{x}_k$ ，卡尔曼增益 $K_k$ </p><script type="math/tex; mode=display">\begin{aligned}x_k & = Ax_{k-1}+Bu_{k-1}+w_{k-1}\\\hat{x}_k^- & = A\hat{x}_{k-1}+Bu_{k-1}\\\hat{x}_k & = \hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)\\K_k & = \frac{P_k^-H^T}{HP_k^-H^T+R}\end{aligned}</script><p>根据 $P_k^-$ 的定义， $P_k^-=E(e_k^-{e_k^-}^T)$ ，其中误差为真实值减估计值，</p><script type="math/tex; mode=display">\begin{aligned}e_k^-&=x_k-\hat{x}_k^-\\     &=Ax_{k-1}+Bu_{k-1}+w_{k-1}-A\hat{x}_{k-1}-Bu_{k-1}\\     &=A(x_{k-1}-\hat{x}_{k-1}^-)+w_{k-1}\\     &=Ae_{k-1}+w_{k-1}\end{aligned}</script><p>则 $P_k^-$ 可以整理为：</p><script type="math/tex; mode=display">\begin{aligned}P_k^-&=E(e_k^-{e_k^-}^T)\\     &=E\left( (Ae_{k-1}+w_{k-1})(Ae_{k-1}+w_{k-1})^T \right)\\     &=AE(e_{k-1}^-{e_{k-1}^-}^T)A^T+E(w_{k-1}^-{w_{k-1}^-}^T)\\     &=AP_{k-1}A^T+Q\end{aligned}</script><p>根据上式就可以利用卡尔曼滤波器估计状态变量的值了。分为以下步骤</p><ul><li><p>预测</p><ol><li><p>先验估计</p><p> $\hat{x}_k^-=A\hat{x}_{k-1}+Bu_{k-1}$</p></li><li><p>先验误差协方差矩阵</p><p> $P_k^-=AP_{k-1}A^T+Q$</p></li></ol></li><li><p>校正</p><ol><li><p>卡尔曼增益</p><p> $K_k=\frac{P_k^-H^T}{HP_k^-H^T+R}$</p></li><li><p>后验估计</p><p> $\hat{x}_k=\hat{x}_k^- + K_k(z_k-H\hat{x}_k^-)$</p></li></ol></li></ul><p>根据以上四步就可以得到最优估计值，也就是后验估计值 $\hat{x}_k$ 。</p><p>先验误差协方差矩阵 $P_k^-$ 中包含上一次的 $P_{k-1}^-$ 项，每次矫正厚需要更新先验误差协方差矩阵。将卡尔曼增益带入可以求得：</p><script type="math/tex; mode=display">\begin{aligned}P_k&=P_k^--K_kHP_k^--(K_kHP_k^-)^T+K_kHP_k^-H^TK_k^T+K_kRK_k^T\\   &=(I-K_kH)P_k^-\end{aligned}</script><p>所以第五步为</p><ol><li><p>更新先验误差协方差</p><p>$P_k=(I-K_kH)P_k^-$ </p></li></ol><p>以上就是完整的卡尔曼滤波器的五个公式。</p><p>可以看到，每次预测都会用到上一次的结果，所以在最开始要赋予初值 $\hat{x}_0$ 和 $P_0$ ，初值的选取会在下文提及。</p><h2 id="扩展卡尔曼滤波"><a href="#扩展卡尔曼滤波" class="headerlink" title="扩展卡尔曼滤波"></a>扩展卡尔曼滤波</h2><p>前文讲到，卡尔曼滤波器在线性系统里可以得到最优估计值。对于非线性系统，可以将其线性化再进行处理，这种滤波器叫做扩展卡尔曼滤波器（Extend Kalman Filter），简称EKF。</p><p>线性系统可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=Ax_{k-1}+Bu_{k-1}+w_{k-1}\\z_k=Hx_k+v_k\end{array}</script><p>而非线性系统，无法用线性的状态空间方程表达，而是可以表示为：</p><script type="math/tex; mode=display">\begin{array}{l}x_k=f(x_{k-1},u_{k-1},w_{k-1})\\z_k=h(x_k,v_k)\end{array}</script><p>其中f为过程方程，h为测量方程，这是两个非线性的表达形式。注意无论是线性还是非线性，误差v和w都是符合正态分布的。但正态分布的随机变量通过非线性系统以后就不再是正态分布的了。所以如果还想对非线性系统进行卡尔曼滤波，需要对其线性化（Linearization），用泰勒级数展开，不赘述过程只给出结论：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=f(x_0)+\frac{\partial f}{\partial x}(x-x_0)\end{aligned}</script><p>如果需要线性化一个系统，需要找到一个点（Operating Point），在这个点附近进行线性化。对于非线性系统来说最好的线性化的点就是它的真实点，但由于系统有误差，无法知道真实值，所以无法在真实点进行线性化，所以过程方程 $f(x_k)$ 只能<strong>在 $\hat{x}_{k-1}$ 附近</strong>，也就是k-1时刻（上一次）的后验估计附近进行线性化。</p><p>由于不知道误差 $w_{k-1}$ 是多少，所以将其假设为0，定义 $f(\hat{x}_{k-1},u_{k-1},0)=\tilde x_k$ ，可以得到</p><script type="math/tex; mode=display">\begin{aligned}x_k & = f(\hat{x}_{k-1},u_{k-1},0)+A_k(x_{k-1}-\hat{x}_{k-1})+W_kw_{k-1}\\A_k &= \frac{\partial f}{\partial x}|_{\hat{x}_{k-1},u_{k-1}}\qquad W_k  = \frac{\partial f}{\partial w}|_{\hat{x}_{k-1},u_{k-1}}\end{aligned}</script><p>例：</p><script type="math/tex; mode=display">\begin{aligned}x_1&=x_1+sinx_2=f_1\\x_2&=x_1^2=f_2\\A_k&=\frac{\partial f}{\partial x}|_{\hat{x_1}_{k-1},\hat{x_2}_{k-1}}\\&=\begin{bmatrix}    \frac{\partial f_1}{\partial x_1} & \frac{\partial f_1}{\partial x_2} \\  \frac{\partial f_2}{\partial x_1} & \frac{\partial f_2}{\partial x_2}\end{bmatrix}|_{\hat{x_1}_{k-1},\hat{x_2}_{k-1}}\\&=\begin{bmatrix}    1 & cosx_2 \\  2x_1 & 0\end{bmatrix}|_{\hat{x_1}_{k-1},\hat{x_2}_{k-1}}\\&=\begin{bmatrix}    1 & cos\hat{x_2}_{k-1} \\  2\hat{x_1}_{k-1} & 0\end{bmatrix}\end{aligned}</script><p>可以看出，A矩阵随着K的变化而变化，所以每次要重新计算A矩阵。</p><p>同理对于测量方程， $z_k$ <strong>在 $\tilde x_k$ 附近</strong>进行线性化。由于不知道误差 $v_k$ ，所以将其假设为0，定义 $h(\hat{x}_k,0)=\tilde z_k$ </p><script type="math/tex; mode=display">\begin{aligned}z_k&=h(\tilde x,0)+H_k(x_k-\tilde{x}_k)+V_kv_k\\H_k&=\frac{\partial h}{\partial x}|_{\hat{x}_k}\qquad V_k=\frac{\partial h}{\partial v}|_{\hat{x}_k}\\\end{aligned}</script><p>这样就把非线性系统线性化了：</p><script type="math/tex; mode=display">\begin{aligned}x_k&=\tilde x_k+A_k(x_{k-1}-\hat{x}_{k-1})+W_kw_{k-1}\\z_k&=\tilde z_k+H(x_k-\tilde{x}_k)+Vv_k\end{aligned}</script><p>其中的 $W_kw_{k-1}$ 和 $Vv_k$ 也都是正态分布（ $WQW^T$ 相当于矩阵中W的平方）：</p><script type="math/tex; mode=display">\begin{aligned}P(w) &\sim N(0,R)\\P(Ww_{k-1}) &\sim N(0,WQW^T)\\P(Vv_k) &\sim N(0,VRV^T)\end{aligned}</script><p>将卡尔曼滤波器的线性化部分替换成对应非线性的部分，就可以得到扩展卡尔曼滤波器的五个公式：</p><ul><li><p>预测</p><ol><li><p>先验估计</p><p> $\hat{x}_k^-=f(\hat{x}_{k-1},u_{k-1},0)$</p></li><li><p>先验误差协方差矩阵</p><p> $P_k^-=AP_{k-1}A^T+WQW^T$</p></li></ol></li><li><p>校正</p><ol><li><p>卡尔曼增益</p><p> $K_k=\frac{P_k^-H^T}{HP_k^-H^T+VRV^T}$</p></li><li><p>后验估计</p><p> $\hat{x}_k=\hat{x}_k^- + K_k(z_k-h(\hat{x}_k,0))$ </p></li></ol></li></ul><ol><li><p>更新先验误差协方差</p><p> $P_k=(I-K_kH)P_k^-$ </p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="https://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="https://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>FOC控制原理——Clark变换和Park变换</title>
    <link href="https://www.robotsfan.com/posts/9532f19e.html"/>
    <id>https://www.robotsfan.com/posts/9532f19e.html</id>
    <published>2022-03-23T08:25:00.000Z</published>
    <updated>2022-03-23T08:32:26.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FOC控制原理——Clark变换和Park变换"><a href="#FOC控制原理——Clark变换和Park变换" class="headerlink" title="FOC控制原理——Clark变换和Park变换"></a>FOC控制原理——Clark变换和Park变换</h1><h2 id="Clark变换"><a href="#Clark变换" class="headerlink" title="Clark变换"></a>Clark变换</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Clark变换就是把三向坐标系变成直角坐标系</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153620081.png" alt="image-20220323153620081"></p><p>已知三向坐标系 $(I_a,I_b,I_c)$ ，这三个基向量不是正交的，所以可以将其正交化为一个直角坐标系，命名为 $\alpha-\beta$ 坐标系，变换公式为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    \begin{aligned}    I_\alpha&=I_a-I_b\text{cos}60-I_c\text{cos}60 \\            &=I_a-\frac{1}{2}I_b-\frac{1}{2}I_c    \end{aligned} \\    \begin{aligned}    I_\beta&=I_b\text{cos}30-I_c\text{cos}30 \\           &=\frac{\sqrt3}{2}I_b-\frac{\sqrt3}{2}I_c    \end{aligned}\end{array}\right.</script><p>可以将其整理成矩阵形式：</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{ccc}    1 & -\frac{1}{2}       & -\frac{1}{2} \\    0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2}\end{array}\right]\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]</script><p>由基尔霍夫电流定律， $I_a+I_b+I_c=0$ ，故也可整理为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}    I_\alpha=\frac{3}{2}I_a \\    I_\beta=\frac{\sqrt3}{2}I_a+\sqrt3I_b\end{array}\right.</script><p>反Clark变换则将三向信号转换为两向信号，根据上式可以解得</p><script type="math/tex; mode=display">\left[\begin{array}{c}    I_{a} \\    I_{b} \\    I_{c}\end{array}\right]=\left[\begin{array}{ccc}    \frac{2}{3}  & 0       \\    -\frac{1}{3} & \frac{1}{\sqrt{3}} \\    -\frac{1}{3} & -\frac{1}{\sqrt{3}}\end{array}\right]\left[\begin{array}{c}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>也可通过计算Clark变换常数矩阵的伪逆来确定反Clark变换的常数矩阵（使用MATLAB中的 <code>pinv()</code>函数）</p><h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323152939436.png" alt="image-20220323152939436"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323150553068.png" alt="image-20220323150553068"></p><p>通过图像可以看到，输入信号的幅值为1，经过Clark变换后的图像幅值变为1.5，即变为 $\frac{3}{2}$ 倍；进行反Clark变换后幅值又变为1.5，即变为 $\frac{2}{3}$ 倍。所以要进行等幅值变换。修改仿真：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323153007076.png" alt="image-20220323153007076"></p><p>可以看到，经过等幅值变换后，幅值统一为1。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323151818659.png" alt="image-20220323151818659"></p><h2 id="Park变换"><a href="#Park变换" class="headerlink" title="Park变换"></a>Park变换</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Park变换可以将正弦变量线性化</p><p>将 $\alpha-\beta$ 坐标系旋转 $\theta$ 度变为 $d-q$ 坐标系， $d$ 指向转子中心， $q$ 指向切线方向，其中 $\theta$ 是转子当前的角度。如下图</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/v2-d15d057327992a5c50016aea5bb7201b_1440w.jpg" alt="img"></p><p>也就是说 $d-q$ 坐标系始终跟着转子旋转。</p><p>则可以写出</p><script type="math/tex; mode=display">\left\{\begin{array}{l}I_{d}=I_{\alpha} \cos (\theta)+I_{\beta} \sin (\theta) \\I_{q}=-I_{\alpha} \sin (\theta)+I_{\beta} \cos (\theta)\end{array}\right.</script><p>整理成矩阵形式</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & \sin \theta \\    -\sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]</script><p>所以如果 $d$ 轴为0，则功率全部输出在 $q$ 轴上。</p><p>同理，可以求得反Park变换</p><script type="math/tex; mode=display">\left[\begin{array}{l}    I_{\alpha} \\    I_{\beta}\end{array}\right]=\left[\begin{array}{cc}     \cos \theta & -\sin \theta \\     \sin \theta & \cos \theta\end{array}\right]\left[\begin{array}{l}    I_{d} \\    I_{q}\end{array}\right]</script><h3 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>在Clark变换和等幅值变换的基础上添加Park变换</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160805870.png" alt="image-20220323160805870"></p><p>关注Park部分</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220323160942614.png" alt="image-20220323160942614"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电机" scheme="https://www.robotsfan.com/categories/%E7%94%B5%E6%9C%BA/"/>
    
    
    <category term="FOC" scheme="https://www.robotsfan.com/tags/FOC/"/>
    
  </entry>
  
  <entry>
    <title>机器人动力学——拉格朗日法</title>
    <link href="https://www.robotsfan.com/posts/c0ff5b54.html"/>
    <id>https://www.robotsfan.com/posts/c0ff5b54.html</id>
    <published>2022-03-15T12:30:00.000Z</published>
    <updated>2022-03-15T12:35:41.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="机器人动力学——拉格朗日法"><a href="#机器人动力学——拉格朗日法" class="headerlink" title="机器人动力学——拉格朗日法"></a>机器人动力学——拉格朗日法</h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p>机器人动力学所用到的运动学方程是一组具有下列形式的二阶微分方程组</p><script type="math/tex; mode=display">\tau = M ( \theta ) \ddot { \theta } + h ( \theta , \dot { \theta } ) \label{1}</script><p>式中，对于所有关节均为驱动关节的开式运动链，广义坐标 $\theta \in \mathbb{R}^{n}$ 表示关节变量；广义力 $\tau \in \mathbb{R}^{n}$ 表示力或力矩，如果 $\theta_i$ 是旋转关节，则 $\tau_i$ 对应力矩；如果 $\theta_i$ 为平动关节，则 $\tau_i$ 对应力； $M ( \theta )\in \mathbb{R}^{n\times{n}}$ 是一个对称且正定的质量矩阵；$h ( \theta , \dot { \theta })\in \mathbb{R}^{n}$ 是将向心力、科里奥利力、重力和摩擦力等集合在一起的力向量，该向量取决于 $\theta$ 和 $ \dot { \theta}$ 这两个变量。</p><p>运动学同样区分正运动学和逆运动学，正向动力学问题是在给定状态变量 $( \theta , \dot { \theta })$ 以及关节力和力矩的前提下确定机器人的加速度 $\ddot { \theta }$ ，即</p><script type="math/tex; mode=display">\ddot { \theta } = M ^ { - 1 } ( \theta ) ( \tau - h ( \theta , \dot { \theta } ) )</script><p>逆动力学问题则是找到对应于机器人状态和期望加速度的关节力和力矩$\tau$，即式 $\eqref{1}$ </p><p>机器人的动力学方程通常可以通过<strong>牛顿-欧拉公式</strong>或<strong>拉格朗日动力学公式</strong>得到。对于简单结构的机器人，如3自由度或自由度更少的情形，拉格朗日形式不仅在概念上十分优雅，并且在实际中非常有效。但对于自由度数目更多的机器人来讲，其计算可能会很快变得烦琐。</p><p>下文将讨论拉格朗日动力学公式</p><h2 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h2><p>力学系统的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 定义为整个系统的动能 ${ \cal K } ( q , \dot { q } )$ 减去势能 ${ \cal P } ( q )$ ，式中的—组独立坐标 $q \in \mathbb{R}^{n}$ 用来描述系统的位形（这个坐标 $q$ 被称为广义坐标）</p><script type="math/tex; mode=display">{ \cal L } ( q , \dot { q } ) = { \cal K } ( q , \dot { q } ) - { \cal P } ( q )</script><p>运动方程现在可以用拉格朗日函数表示如下（推导过程略，详见动力学教材）</p><script type="math/tex; mode=display">f = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { q } } - \frac { \partial { \cal L } } { \partial q }</script><p>这个方程也称为<strong>含外力的欧拉-拉格朗日方程</strong>（在标准形式的欧拉-拉格朗日方程中，外力 $f$ 等于零）</p><h2 id="2R-开链机器人举例"><a href="#2R-开链机器人举例" class="headerlink" title="$2R$ 开链机器人举例"></a>$2R$ 开链机器人举例</h2><p>下面以在重力作用下的—个 $2R$ 开链机器人为例推导动力学方程，如下图所示</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220315193736585.png" alt="image-20220315193736585" style="zoom:80%;"></p><p>将关节坐标 $\theta =(\theta_{1},\theta_{2})$ 选做广义坐标，广义力 $\tau =(\tau_{1},\tau_{2})$ 则对应于关节力矩（因为 $\tau^T\dot{\theta}$ 对应于功率）。本例中的拉格朗日函数 ${ \cal L } ( q , \dot { q } )$ 可以写成如下分量形式:</p><script type="math/tex; mode=display">\mathcal{L}(\theta, \dot{\theta})=\sum_{i=1}^{2}\left(\mathcal{K}_{i}-\mathcal{P}_{i}\right)</script><p>则欧拉-拉格朗日方程可以写成如下分量形式（ $\tau$ 为关节力和力矩向量）:</p><script type="math/tex; mode=display">\tau_i = \frac { d } { d t } \frac { \partial { \cal L } } { \partial \dot { \theta_i } } - \frac { \partial { \cal L } } { \partial \theta_i } \qquad i = 1,2  \label{6}</script><p>下面我们需要计算两杆的动能和势能（认为两杆各自的质量 $\mathrm { m }1$ 和 $\mathrm { m }2$ 均集中于各杆末端）</p><p>连杆1质心的位置和速度:</p><script type="math/tex; mode=display">\begin{array}{l}{\left[\begin{array}{l}x_{1} \\y_{1}\end{array}\right]=\left[\begin{array}{c}L_{1} \cos \theta_{1} \\L_{1} \sin \theta_{1}\end{array}\right]} \\{\left[\begin{array}{c}\dot{x}_{1} \\\dot{y}_{1}\end{array}\right]=\left[\begin{array}{r}-L_{1} \sin \theta_{1} \\L_{1} \cos \theta_{1}\end{array}\right] \dot{\theta}_{1}}\end{array}</script><p>连杆2质心的位置和速度:</p><script type="math/tex; mode=display">\begin{array}{l}{\left[\begin{array}{l}x_{2} \\y_{2}\end{array}\right]=\left[\begin{array}{c}L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\end{array}\right]} \\{\left[\begin{array}{l}\dot{x}_{2} \\\dot{y}_{2}\end{array}\right]=\left[\begin{array}{rr}-L_{1} \sin \theta_{1}-L_{2} \sin \left(\theta_{1}+\theta_{2}\right) & -L_{2} \sin \left(\theta_{1}+\theta_{2}\right) \\L_{1} \cos \theta_{1}+L_{2} \cos \left(\theta_{1}+\theta_{2}\right) & L_{2} \cos \left(\theta_{1}+\theta_{2}\right)\end{array}\right]\left[\begin{array}{l}\dot{\theta}_{1} \\\dot{\theta}_{2}\end{array}\right] }\end{array}</script><p>由 $\mathcal{K} =\frac{1}{2} \mathfrak{m} v^2 = \frac{1}{2} \mathfrak{m}(\dot{x}^2 + \dot{y}^2)$ ，连杆的动能项 ${ \cal K }_1$ 和 ${ \cal K }_2$ 分别为</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{K}_{1} &=\frac{1}{2} \mathfrak{m}_{1}\left(\dot{x}_{1}^{2}+\dot{y}_{1}^{2}\right) \\&=\frac{1}{2} \mathfrak{m}_{1} L_{1}^{2} \dot{\theta}_{1}^{2} \\\mathcal{K}_{2} &=\frac{1}{2} \mathfrak{m}_{2}\left(\dot{x}_{2}^{2}+\dot{y}_{2}^{2}\right) \\&=\frac{1}{2} \mathfrak{m}_{2}\left(\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \dot{\theta}_{1}^{2}+2\left(L_{2}^{2}+L_{1} L_{2} \cos \theta_{2}\right) \dot{\theta}_{1} \dot{\theta}_{2}+L_{2}^{2} \dot{\theta}_{2}^{2}\right)\end{aligned}</script><p>势能只取决于高度，即 $y$ 坐标。由 $\mathcal{P} = \mathfrak{m} g y$ ，连杆的势能项 ${ \cal P }_1$ 和 ${ \cal P }_2$ 分别为</p><script type="math/tex; mode=display">\begin{array}{l}\mathcal{P}_{1}=\mathfrak{m}_{1} g y_{1}=\mathfrak{m}_{1} g L_{1} \sin \theta_{1} \\\mathcal{P}_{2}=\mathfrak{m}_{2} g y_{2}=\mathfrak{m}_{2} g\left(L_{1} \sin \theta_{1}+L_{2} \sin \left(\theta_{1}+\theta_{2}\right)\right)\end{array}</script><p>将动能项与势能项带入拉格朗日函数 $\eqref{6}$ 即可得到平面 $2R$ 运动链的动力学方程:</p><script type="math/tex; mode=display">\left\{\begin{aligned}\tau_{1}=&\left(\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right)\right) \ddot{\theta}_{1} \\&+\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{2}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\&+\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right), \\\tau_{2}=& \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \ddot{\theta}_{1}+\mathfrak{m}_{2} L_{2}^{2} \ddot{\theta}_{2}+\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2} \\&+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) .\end{aligned}\right.</script><p>可以看到，即使是一个简单的 $2R$ 机器人，其逆运动学方程也十分复杂。对上述各项进行整理，得到如下形式的方程:</p><script type="math/tex; mode=display">\tau=M(\theta) \ddot{\theta}+\underbrace{c(\theta, \dot{\theta})+g(\theta)}_{h(\theta, \dot{\theta})}</script><p>式中</p><script type="math/tex; mode=display">\begin{aligned}M(\theta) &=\left[\begin{array}{cc}\mathfrak{m}_{1} L_{1}^{2}+\mathfrak{m}_{2}\left(L_{1}^{2}+2 L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) \\\mathfrak{m}_{2}\left(L_{1} L_{2} \cos \theta_{2}+L_{2}^{2}\right) & \mathfrak{m}_{2}L_{2}^{2} \\\end{array}\right] \\c(\theta, \dot{\theta}) &=\left[\begin{array}{c}-\mathfrak{m}_{2} L_{1} L_{2} \sin \theta_{2}\left(2 \dot{\theta}_{1} \dot{\theta}_{2}+\dot{\theta}_{2}^{2}\right) \\\mathfrak{m}_{2} L_{1} L_{2} \dot{\theta}_{1}^{2} \sin \theta_{2}\end{array}\right] \\g(\theta) &=\left[\begin{array}{c}\left(\mathfrak{m}_{1}+\mathfrak{m}_{2}\right) L_{1} g \cos \theta_{1}+\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right) \\\mathfrak{m}_{2} g L_{2} \cos \left(\theta_{1}+\theta_{2}\right)\end{array}\right]\end{aligned}</script><p>式中 <strong>$M(\theta)$ 为对称正定的质量矩阵</strong>， <strong>$c(\theta, \dot{\theta})$ 为速度乘积项，包含科里奥利和向心力矩的向量</strong>，其中包含 $\dot{\theta}^2$ 的二次项称为向心项，包含 $\dot{\theta}_{i} \dot{\theta}_{j}(i \ne j)$ 的二次项则称为科里奥利项。 <strong>$g(\theta)$ 为重力项</strong> ，因为此处势能仅来自重力，若末端有弹簧，弹簧也会贡献势能。这些揭示了运动方程是 $\ddot{\theta}$ 的线性函数、 $\dot{\theta}$ 的二次函数、 $\theta$ 的三角函数。上述结论不仅适用于 $2R$ 型机器人，对于包含转动关节的串联运动链也同样适用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="机器人学" scheme="https://www.robotsfan.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
    
    
    <category term="机器人学" scheme="https://www.robotsfan.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>树莓派使用串口</title>
    <link href="https://www.robotsfan.com/posts/dab7fbfc.html"/>
    <id>https://www.robotsfan.com/posts/dab7fbfc.html</id>
    <published>2022-03-15T12:30:00.000Z</published>
    <updated>2022-03-18T12:01:10.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树莓派使用串口"><a href="#树莓派使用串口" class="headerlink" title="树莓派使用串口"></a>树莓派使用串口</h1><p>树莓派默认将 serial0 映射到 外接GPIO的15、16脚。默认将 serial1 映射到 BT蓝牙上。所以如果想要将 ttyAMA0映射到外部 GPIO上，只需要禁用蓝牙，并将 serial0 和serial1 他们链接的对象互换。</p><p>但树莓派4B的更改方式与旧版本不同，终端输入<code>ls -l /dev/serial*</code>，发现只有serial1-&gt;ttyAMA0，没有serial0也没有ttyS0，更没有二者的映射。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>不要去修改<code>config.txt</code>里的配置！！！</strong>网上很多教程<strong>误人子弟</strong>，此文件开头就明确声明了禁止修改，用户的修改均要放置到<code>usercfg.txt</code>中！打开<code>config.txt</code>可以看到这个文件引用了<code>syscfg.txt</code>，这个文件里面写了<code>enable_uart=0</code>，也就是说即便在<code>config.txt</code>中修改了<code>enable_uart=1</code>，下面还是会被重新赋值为<code>enable_uart=0</code>。而<code>usercfg.txt</code>是在<code>syscfg.txt</code>后引用的，所以用户的修改项会覆盖上面的所有配置。</p><p>正确方法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /boot/firmware</span><br><span class="line">sudo vi usercfg.txt</span><br></pre></td></tr></table></figure><p>在里面添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enable_uart=1</span><br><span class="line">dtoverlay=disable-bt</span><br></pre></td></tr></table></figure><p>保存，然后禁用跟蓝牙有关的开机启动项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> bluetooth</span><br></pre></td></tr></table></figure><p>重启树莓派</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>然后再次<code>ls -l /dev/serial*</code>就可以看到正确的映射关系</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="小技能" scheme="https://www.robotsfan.com/categories/%E5%B0%8F%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="树莓派" scheme="https://www.robotsfan.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV文档矫正</title>
    <link href="https://www.robotsfan.com/posts/c780224b.html"/>
    <id>https://www.robotsfan.com/posts/c780224b.html</id>
    <published>2022-03-14T02:30:00.000Z</published>
    <updated>2022-03-14T02:27:16.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV文档矫正"><a href="#OpenCV文档矫正" class="headerlink" title="OpenCV文档矫正"></a>OpenCV文档矫正</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>将一个斜着拍摄的文档矫正成正的，如图所示：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_origin.jpg" alt="opencv-wendang-image_origin"></p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image_output.jpg" alt="opencv-wendang-image_output"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>读取原始图像，若图像太大可以先进行缩放处理，并获取原始图像的宽和高</li><li>对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</li><li>找到最大的轮廓，并提取角点<ol><li>进行降噪处理：检测轮廓面积，只保留大于阈值面积的轮廓</li><li>计算每个轮廓的周长，使用DP算法计算出轮廓点的个数，规则为周长*0.02</li><li>找到图像中面积最大的，且角点为4的轮廓</li></ol></li><li>将找到的四个角点排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角<ol><li>将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</li><li>将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</li><li>重新排列四个角点</li></ol></li><li>进行透视变换<ol><li>根据变换前及变换后的四个角点，创建变换矩阵</li><li>根据变换矩阵对图像进行透视变换</li></ol></li><li>若透视变换后有一些毛边，按需要进行裁剪，裁剪后重新调整比例<ol><li>创建一个矩形用来裁剪，并设定四周裁剪5像素</li><li>裁剪后重新调整图像宽高</li></ol></li><li>显示变换后图像</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码中均有详细注释，请仔细阅读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些定义</span></span><br><span class="line">Mat image_origin,     <span class="comment">// 原始图像</span></span><br><span class="line">image_gray,       <span class="comment">// 灰度处理后的图像</span></span><br><span class="line">image_blur,       <span class="comment">// 高斯模糊处理后的图像</span></span><br><span class="line">image_canny,      <span class="comment">// 边缘检测后的图像</span></span><br><span class="line">image_dilate,     <span class="comment">// 膨胀后的图像</span></span><br><span class="line">image_erode,      <span class="comment">// 腐蚀后的图像</span></span><br><span class="line">image_preprocess, <span class="comment">// 预处理后的图像</span></span><br><span class="line">image_trans,      <span class="comment">// 透视变换后的图像</span></span><br><span class="line">image_crop;      <span class="comment">// 裁剪后的图像</span></span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; origin_points,  <span class="comment">// 重新排列前的角点</span></span><br><span class="line">  reorder_points; <span class="comment">// 重新排列后的角点</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> origin_width = <span class="number">0</span>, origin_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：预处理，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line"><span class="comment"> * 输入：图像，是否显示(0-不显示 1-显示每一步处理后的图像 2-只显示最终图像)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PreProcess</span><span class="params">(<span class="keyword">const</span> Mat&amp; image, <span class="keyword">int</span> display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 灰度处理</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, image_gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(image_gray, image_blur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边缘检测(边缘检测前对图像进行一次高斯模糊)</span></span><br><span class="line"><span class="built_in">Canny</span>(image_blur, image_canny, <span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 膨胀和腐蚀(有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀)</span></span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(image_canny, image_dilate, kernel);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="comment">//erode(image_dilate, image_erode, kernel);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示预处理效果</span></span><br><span class="line"><span class="keyword">if</span>(display == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;灰度处理后的图像&quot;</span>, image_gray);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯模糊后的图像&quot;</span>, image_blur);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;边缘检测后的图像&quot;</span>, image_canny);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;膨胀后的图像&quot;</span>, image_dilate);</span><br><span class="line"><span class="comment">//imshow(&quot;腐蚀后的图像&quot;, image_erode);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(display == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;预处理后的图像&quot;</span>, image_dilate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image_dilate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：找到面积最大的轮廓</span></span><br><span class="line"><span class="comment"> * 输入：源图像</span></span><br><span class="line"><span class="comment"> * 输出：最大轮廓的四个角点数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">GetMaxContour</span><span class="params">(<span class="keyword">const</span> Mat&amp; img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment"> * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment"> * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * findContours找到轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment"> * 取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment"> * 取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment"> * 取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment"> * 取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment"> * 取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment"> * 取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment"> * 取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment"> * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * drawContours绘出轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours</span></span><br><span class="line"><span class="comment"> * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="comment">//// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//drawContours(image, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">corners_contours</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; biggest_contours;</span><br><span class="line"><span class="keyword">double</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检测轮廓面积</span></span><br><span class="line"><span class="keyword">double</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设图像中有噪声，需要将其过滤，只保留面积大于1000的轮廓</span></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line"><span class="keyword">double</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], corners_contours[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到图像中面积最大的，且角点为4的轮廓</span></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; max_area &amp;&amp; corners_contours[i].<span class="built_in">size</span>() == <span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drawContours(image_origin, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">biggest_contours = &#123; corners_contours[i][<span class="number">0</span>],corners_contours[i][<span class="number">1</span>] ,corners_contours[i][<span class="number">2</span>] ,corners_contours[i][<span class="number">3</span>] &#125;;</span><br><span class="line">max_area = contour_area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 只绘制角点之间的边框线，Debug用，取消注释可以看到检测出的所有边界框</span></span><br><span class="line"><span class="comment">//drawContours(image_origin, corners_contours, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(image_origin, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最大的轮廓</span></span><br><span class="line"><span class="keyword">return</span> biggest_contours;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：绘制一些点</span></span><br><span class="line"><span class="comment"> * 输入：点集，颜色</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPoints</span><span class="params">(vector&lt;Point&gt; points, <span class="keyword">const</span> Scalar&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(image_origin, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line"><span class="built_in">putText</span>(image_origin, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：重新排列四个角点的顺序</span></span><br><span class="line"><span class="comment"> * 最终顺序为： 0  1</span></span><br><span class="line"><span class="comment"> *   2  3</span></span><br><span class="line"><span class="comment"> *   数组中为左上角-右上角-左下角-右下角</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">ReorderPoints</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Point&gt; newPoints;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenCV中左上顶点为(0,0)，右为x轴正向，下为y轴正向。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将每个点的xy坐标值相加(x+y)，左上角的点的坐标和应该是最小的，右下角的点的坐标和应该是最大的</span></span><br><span class="line">sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line"><span class="comment">// 将每个点的xy坐标值相减(x-y)，左下角的点的坐标差应该是最小的，右上角的点的坐标差应该是最大的</span></span><br><span class="line">subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新排列</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 0 和的最小值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 1 差的最大值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">// 2 差的最小值</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">// 3 和的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数功能：</span></span><br><span class="line"><span class="comment"> * 输入：源图像，四个角点的集合(角点的顺序为，左上角-右上角-左下角-右下角)，输出的宽，输出的高</span></span><br><span class="line"><span class="comment"> * 输出：透视变换后的图像</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Mat <span class="title">PerspectiveTrans</span><span class="params">(<span class="keyword">const</span> Mat&amp; img, vector&lt;Point&gt; points, <span class="keyword">float</span> width, <span class="keyword">float</span> height )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 前面经过重新排列，四个角点的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="comment">// 变换后的四个角点</span></span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;width,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,height&#125;,&#123;width,height&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line"><span class="built_in">warpPerspective</span>(img, image_trans, matrix, <span class="built_in">Point</span>(width, height));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image_trans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.读取原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/image_origin.jpg&quot;</span>;</span><br><span class="line">image_origin = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 若图像太大可以先进行缩放处理</span></span><br><span class="line"><span class="comment">//resize(image_origin, image_origin, Size(), 0.5, 0.5);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原始图像的宽和高</span></span><br><span class="line">origin_width  = image_origin.<span class="built_in">size</span>().width;</span><br><span class="line">origin_height = image_origin.<span class="built_in">size</span>().height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。</span></span><br><span class="line">image_preprocess = <span class="built_in">PreProcess</span>(image_origin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找到最大的轮廓，并提取角点</span></span><br><span class="line">origin_points = <span class="built_in">GetMaxContour</span>(image_preprocess);</span><br><span class="line"><span class="comment">//DrawPoints(origin_points, Scalar(0, 0, 255)); // 红色</span></span><br><span class="line"><span class="comment">// 此时发现，角点的顺序不固定，为了后面进行透视变换时与代码中变换后点集的顺序相同，需要将其排列成一个固定的顺序，排列后的顺序为：左上角-右上角-左下角-右下角</span></span><br><span class="line">reorder_points = <span class="built_in">ReorderPoints</span>(origin_points);</span><br><span class="line"><span class="comment">//DrawPoints(reorder_points, Scalar(0, 255, 0)); //绿色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.透视变换</span></span><br><span class="line">image_trans = <span class="built_in">PerspectiveTrans</span>(image_origin, reorder_points, origin_width, origin_height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换后有一些毛边，若需要可以进行裁剪</span></span><br><span class="line"><span class="comment">// 四周裁剪5像素</span></span><br><span class="line"><span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 创建一个矩形用来裁剪</span></span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, origin_width - (<span class="number">2</span> * cropVal), origin_height - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">image_crop = <span class="built_in">image_trans</span>(roi);</span><br><span class="line"><span class="comment">// 裁剪后重新调整比例</span></span><br><span class="line"><span class="built_in">resize</span>(image_crop, image_crop, <span class="built_in">Size</span>(origin_width, origin_height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.显示并输出变换后图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;源图像&quot;</span>, image_origin);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;最终图像&quot;</span>, image_crop);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;res/image_output.jpg&quot;</span>, image_crop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/opencv-wendang-image.jpg" alt="opencv-wendang-image"></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV直方图均衡化</title>
    <link href="https://www.robotsfan.com/posts/ab9acae.html"/>
    <id>https://www.robotsfan.com/posts/ab9acae.html</id>
    <published>2022-03-11T02:35:00.000Z</published>
    <updated>2022-03-11T02:28:34.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV直方图均衡化"><a href="#OpenCV直方图均衡化" class="headerlink" title="OpenCV直方图均衡化"></a>OpenCV直方图均衡化</h1><p>直方图均衡化，是对图像进行非线性拉伸，使得一定范围内像素值的数量的大致相同。这样原来直方图中的封顶部分对比度得到了增强，而两侧波谷的对比度降低，输出的直方图是一个较为平坦的分段直方图。<strong>直方图均衡化适用于增强直方图呈尖峰分布的图像。</strong></p><h2 id="几种图片的的直方图均衡化处理效果"><a href="#几种图片的的直方图均衡化处理效果" class="headerlink" title="几种图片的的直方图均衡化处理效果"></a>几种图片的的直方图均衡化处理效果</h2><h3 id="欠曝"><a href="#欠曝" class="headerlink" title="欠曝"></a>欠曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140221839.png" alt="image-20220308140221839"></p><h3 id="过曝"><a href="#过曝" class="headerlink" title="过曝"></a>过曝</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140259367.png" alt="image-20220308140259367"></p><p>从上面两个图片可以看到，直方图均衡化对于背景和前景都太亮或者太暗的图像效果较好，而且这是一个可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图。但缺点是直方图均衡化对处理的数据不加选择，它可能会增加背景噪声的对比度并且降低有用信号的对比度；变换后图像的灰度级减少，某些细节消失；某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。</p><p>下面再贴一张Luna的处理图：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308140434486.png" alt="image-20220308140434486"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直方图均衡化</span></span><br><span class="line"><span class="function">Mat <span class="title">Histogramequalization</span><span class="params">(Mat src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> R[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> G[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> rows = src.rows;</span><br><span class="line"><span class="keyword">int</span> cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> sum = rows * cols;</span><br><span class="line"><span class="comment">//统计直方图的RGB分布</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]]++;</span><br><span class="line">G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]]++;</span><br><span class="line">R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建直方图的累计分布方程，用于直方图均衡化</span></span><br><span class="line"><span class="keyword">double</span> val[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">val[<span class="number">0</span>] += B[i];</span><br><span class="line">val[<span class="number">1</span>] += G[i];</span><br><span class="line">val[<span class="number">2</span>] += R[i];</span><br><span class="line">B[i] = val[<span class="number">0</span>] * <span class="number">255</span> / sum;</span><br><span class="line">G[i] = val[<span class="number">1</span>] * <span class="number">255</span> / sum;</span><br><span class="line">R[i] = val[<span class="number">2</span>] * <span class="number">255</span> / sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归一化直方图</span></span><br><span class="line"><span class="function">Mat <span class="title">dst</span><span class="params">(rows, cols, CV_8UC3)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">dst.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = B[src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]];</span><br><span class="line">dst.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = G[src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]];</span><br><span class="line">dst.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = R[src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat luna = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Luna——原始图像&quot;</span>, luna);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Luna——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(luna));</span><br><span class="line"></span><br><span class="line">Mat guobao = <span class="built_in">imread</span>(<span class="string">&quot;./guobao.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;过曝光——原始图像&quot;</span>, guobao);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;过曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(guobao));</span><br><span class="line"></span><br><span class="line">Mat qianbao = <span class="built_in">imread</span>(<span class="string">&quot;./qianbao.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——原始图像&quot;</span>, qianbao);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;欠曝光——直方图均衡化&quot;</span>, <span class="built_in">Histogramequalization</span>(qianbao));</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV滤波算法</title>
    <link href="https://www.robotsfan.com/posts/8b4c19c3.html"/>
    <id>https://www.robotsfan.com/posts/8b4c19c3.html</id>
    <published>2022-03-11T02:30:00.000Z</published>
    <updated>2022-03-11T02:28:34.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV滤波算法"><a href="#OpenCV滤波算法" class="headerlink" title="OpenCV滤波算法"></a>OpenCV滤波算法</h1><h2 id="三种滤波的优缺点对比"><a href="#三种滤波的优缺点对比" class="headerlink" title="三种滤波的优缺点对比"></a>三种滤波的优缺点对比</h2><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯滤波适合有高斯噪声的图片。能够很好的抑制图像输入时随机引入的噪声，将像素点跟邻域像素看作是一种高斯分布的关系，它的操作是将图像和一个高斯核进行卷积操作。但是不能很好地抑制椒盐噪声。</p><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>中值滤波适合有椒盐噪声的图片。将窗口函数里面的所有像素进行排序取得中位数来代表该窗口中心的像素值，对椒盐噪声和脉冲噪声的抑制效果特别好，同时又能保留边缘细节。但是不能很好地抑制高斯噪声。</p><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>把每个像素都用周围的8个像素来做均值操作，幅值近似相等且随机分布在不同位置上，这样可以平滑图像，速度较快，算法简单。但是无法去掉噪声，只能微弱的减弱它。对于椒盐噪声，中值滤波是选择适当的点来替代污染点的值，所以处理效果好，由于椒盐噪声的均值不为0，所以均值滤波不能很好地去除噪声点。</p><h2 id="三种滤波算法对不同噪声的处理"><a href="#三种滤波算法对不同噪声的处理" class="headerlink" title="三种滤波算法对不同噪声的处理"></a>三种滤波算法对不同噪声的处理</h2><p><strong>给经过灰度处理的图像分别加入椒盐噪声、高斯噪声和椒盐高斯噪声，分别使用高斯滤波、中值滤波和均值滤波对图像进行滤波，下面为运行后的效果图：</strong></p><h3 id="添加椒盐噪声"><a href="#添加椒盐噪声" class="headerlink" title="添加椒盐噪声"></a>添加椒盐噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132251591.png" alt="image-20220308132251591"></p><h3 id="添加高斯噪声"><a href="#添加高斯噪声" class="headerlink" title="添加高斯噪声"></a>添加高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132404182.png" alt="image-20220308132404182"></p><h3 id="添加椒盐噪声和高斯噪声"><a href="#添加椒盐噪声和高斯噪声" class="headerlink" title="添加椒盐噪声和高斯噪声"></a>添加椒盐噪声和高斯噪声</h3><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308132459737.png" alt="image-20220308132459737"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//生成高斯噪声</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">generate_gause_noise</span><span class="params">(<span class="keyword">double</span> mu, <span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义小值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epsilon = numeric_limits&lt;<span class="keyword">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> z0, z1;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">flag = !flag;</span><br><span class="line"><span class="comment">//flag为假构造高斯随机变量X</span></span><br><span class="line"><span class="keyword">if</span> (!flag)</span><br><span class="line"><span class="keyword">return</span> z1 * sigma + mu;</span><br><span class="line"><span class="keyword">double</span> u1, u2;</span><br><span class="line"><span class="comment">//构造随机变量</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">u1 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">u2 = <span class="built_in">rand</span>() * (<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">&#125; <span class="keyword">while</span> (u1 &lt;= epsilon);</span><br><span class="line"><span class="comment">//flag为真构造高斯随机变量</span></span><br><span class="line">z0 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">cos</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line">z1 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">sin</span>(<span class="number">2</span> * CV_PI*u2);</span><br><span class="line"><span class="keyword">return</span> z0*sigma + mu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为图像加入高斯噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_gause_noise</span><span class="params">(Mat&amp; image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> channels = image.<span class="built_in">channels</span>();</span><br><span class="line"><span class="keyword">int</span> rowsNumber = image.rows;</span><br><span class="line"><span class="keyword">int</span> colsNumber = image.cols*channels;</span><br><span class="line"><span class="comment">//推断图像的连续性</span></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">isContinuous</span>())</span><br><span class="line">&#123;</span><br><span class="line">colsNumber *= rowsNumber;</span><br><span class="line">rowsNumber = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsNumber; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colsNumber; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加入高斯噪声</span></span><br><span class="line"><span class="keyword">int</span> val = image.ptr&lt;uchar&gt;(i)[j] + <span class="built_in">generate_gause_noise</span>(<span class="number">3</span>, <span class="number">0.8</span>) * <span class="number">32</span>;</span><br><span class="line"><span class="keyword">if</span> (val &lt; <span class="number">0</span>)</span><br><span class="line">val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (val&gt;<span class="number">255</span>)</span><br><span class="line">val = <span class="number">255</span>;</span><br><span class="line">image.ptr&lt;uchar&gt;(i)[j] = (uchar)val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加椒盐噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_salt_noise</span><span class="params">(Mat&amp; image, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line"><span class="comment">// 灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;uchar&gt;(j, i) = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 彩色图像</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">rand</span>() % image.cols;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">rand</span>() % image.rows;</span><br><span class="line"><span class="comment">// 灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC1)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;uchar&gt;(j, i) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 彩色图像</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (image.<span class="built_in">type</span>() == CV_8UC3)</span><br><span class="line">&#123;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">image.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">median_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> start = win_size/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line">vector&lt;uchar&gt; model;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; int(src.at&lt;uchar&gt;(i, j)) &lt;&lt; endl;</span></span><br><span class="line">model.<span class="built_in">push_back</span>(src.at&lt;uchar&gt;(i, j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(model.<span class="built_in">begin</span>(), model.<span class="built_in">end</span>());     <span class="comment">//采用快速排序进行</span></span><br><span class="line">src.at&lt;uchar&gt;(m, n) = model[win_size*win_size/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mean_flitter</span><span class="params">(Mat&amp; src, <span class="keyword">int</span> win_size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> start = win_size / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line">sum += src.at&lt;uchar&gt;(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum / win_size / win_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成高斯模板</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; <span class="built_in">gause_template</span>(<span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> xcore = size / <span class="number">2</span>, ycore = size / <span class="number">2</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">float</span> base = <span class="number">1.0</span> / <span class="number">2</span> / CV_PI / sigma / sigma;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; size; x++) &#123;</span><br><span class="line">vector&lt;<span class="keyword">float</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; size; y++) &#123;</span><br><span class="line"><span class="keyword">float</span> t1 = (<span class="built_in">pow</span>(x - xcore, <span class="number">2</span>) + <span class="built_in">pow</span>(y - ycore, <span class="number">2</span>)) / <span class="number">2.0</span> / sigma / sigma;</span><br><span class="line"><span class="keyword">float</span> temp = base*<span class="built_in">exp</span>(-t1);</span><br><span class="line">v.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gause_filter</span><span class="params">(Mat&amp; src, <span class="keyword">float</span> sigma, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = <span class="built_in">gause_template</span>(sigma,size);</span><br><span class="line"><span class="keyword">int</span> rows = src.rows, cols = src.cols;</span><br><span class="line"><span class="keyword">int</span> start = size / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = start; m &lt;rows - start; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = start; n &lt; cols - start; n++) &#123;</span><br><span class="line"><span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -start + m; i &lt;= start + m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -start + n; j &lt;= start + n; j++) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; gaussTem[i - m + start][j - n + start] &lt;&lt; endl;</span></span><br><span class="line">sum += src.at&lt;uchar&gt;(i, j)*gaussTem[i-m+start][j-n+start];  <span class="comment">//重点理解！！！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">src.at&lt;uchar&gt;(m, n) = <span class="built_in">uchar</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Flitter my_flitter;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;./luna.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//灰度处理</span></span><br><span class="line"><span class="built_in">cvtColor</span>(src, src,COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;灰度处理过的原始图像&quot;</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">//椒盐噪声</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加椒盐噪声</span></span><br><span class="line">Mat src_add_salt_noise;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_add_salt_noise, CV_8UC1);</span><br><span class="line">my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_noise, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐噪声&quot;</span>, src_add_salt_noise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line">Mat Trans_Median = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line">Mat Trans_Mean = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Mat Trans_Gause = src_add_salt_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯噪声</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加高斯噪声</span></span><br><span class="line">Mat src_add_gause_noise;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_add_gause_noise, CV_8UC1);</span><br><span class="line">my_flitter.<span class="built_in">add_gause_noise</span>(src_add_gause_noise);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;添加高斯噪声&quot;</span>, src_add_gause_noise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line">Mat Trans_Median = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line">Mat Trans_Mean = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Mat Trans_Gause = src_add_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//椒盐+高斯噪声</span></span><br><span class="line">&#123;</span><br><span class="line">Mat src_add_salt_and_gause_noise;</span><br><span class="line">src.<span class="built_in">convertTo</span>(src_add_salt_and_gause_noise, CV_8UC1);</span><br><span class="line"><span class="comment">//添加椒盐噪声</span></span><br><span class="line">my_flitter.<span class="built_in">add_salt_noise</span>(src_add_salt_and_gause_noise, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">//添加高斯噪声</span></span><br><span class="line">my_flitter.<span class="built_in">add_gause_noise</span>(src_add_salt_and_gause_noise);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;添加椒盐+高斯噪声&quot;</span>, src_add_salt_and_gause_noise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line">Mat Trans_Median = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">median_flitter</span>(Trans_Median,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——中值滤波&quot;</span>, Trans_Median);</span><br><span class="line"></span><br><span class="line"><span class="comment">//均值滤波</span></span><br><span class="line">Mat Trans_Mean = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">mean_flitter</span>(Trans_Mean, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——均值滤波&quot;</span>, Trans_Mean);</span><br><span class="line"></span><br><span class="line"><span class="comment">//高斯滤波</span></span><br><span class="line"><span class="keyword">float</span> sigma = <span class="number">0.84089642</span>; <span class="keyword">int</span> size = <span class="number">7</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">float</span>&gt;&gt; gaussTem = my_flitter.<span class="built_in">gause_template</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : gaussTem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; std::fixed &lt;&lt; c &lt;&lt; <span class="built_in">setw</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Mat Trans_Gause = src_add_salt_and_gause_noise.<span class="built_in">clone</span>();</span><br><span class="line">my_flitter.<span class="built_in">gause_filter</span>(Trans_Gause, <span class="number">0.8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;椒盐+高斯噪声——高斯滤波 Sigma=1&quot;</span>, Trans_Gause);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>透视变换MATLAB仿真，OpenCV验证</title>
    <link href="https://www.robotsfan.com/posts/bc853aec.html"/>
    <id>https://www.robotsfan.com/posts/bc853aec.html</id>
    <published>2022-03-11T02:25:00.000Z</published>
    <updated>2022-03-11T02:28:34.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="透视变换MATLAB仿真，OpenCV验证"><a href="#透视变换MATLAB仿真，OpenCV验证" class="headerlink" title="透视变换MATLAB仿真，OpenCV验证"></a>透视变换MATLAB仿真，OpenCV验证</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220311102049452.png" alt="image-20220311102049452"></p><h2 id="Matlab仿真"><a href="#Matlab仿真" class="headerlink" title="Matlab仿真"></a>Matlab仿真</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原图像的四个顶点分别左乘变换矩阵，并对其归一化。然后使用一个矩形将这个四边形框在内，矩形的选取规则为：左下顶点为所有xy的最小值，右上顶点为所有xy的最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 原图像F的四个顶点坐标</span></span><br><span class="line">x0y0 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line">xnyn = [<span class="number">640</span>;<span class="number">480</span>;<span class="number">1</span>];</span><br><span class="line">x0yn = [<span class="number">0</span>;<span class="number">480</span>;<span class="number">1</span>];</span><br><span class="line">xny0 = [<span class="number">640</span>;<span class="number">0</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 变换矩阵</span></span><br><span class="line">A = [<span class="number">6.01</span> <span class="number">-1.65</span> <span class="number">537</span>;<span class="number">0.188</span> <span class="number">2.88</span> <span class="number">554</span>;<span class="number">0.000584</span> <span class="number">-0.000620</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 计算透视变换后图像的四个顶点坐标</span></span><br><span class="line">toushi_x0y0 = (A * x0y0) / (A(<span class="number">3</span>,<span class="number">1</span>) * x0y0(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * x0y0(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_xnyn = (A * xnyn) / (A(<span class="number">3</span>,<span class="number">1</span>) * xnyn(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * xnyn(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_x0yn = (A * x0yn) / (A(<span class="number">3</span>,<span class="number">1</span>) * x0yn(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * x0yn(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">toushi_xny0 = (A * xny0) / (A(<span class="number">3</span>,<span class="number">1</span>) * xny0(<span class="number">1</span>,<span class="number">1</span>) + A(<span class="number">3</span>,<span class="number">2</span>) * xny0(<span class="number">2</span>,<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 画图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 原图像（黑色）</span></span><br><span class="line"><span class="built_in">plot</span>(x0y0(<span class="number">1</span>,<span class="number">1</span>),x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(x0yn(<span class="number">1</span>,<span class="number">1</span>),x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(xnyn(<span class="number">1</span>,<span class="number">1</span>),xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(xny0(<span class="number">1</span>,<span class="number">1</span>),xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;k*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([x0y0(<span class="number">1</span>,<span class="number">1</span>),x0yn(<span class="number">1</span>,<span class="number">1</span>)],[x0y0(<span class="number">2</span>,<span class="number">1</span>),x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([x0yn(<span class="number">1</span>,<span class="number">1</span>),xnyn(<span class="number">1</span>,<span class="number">1</span>)],[x0yn(<span class="number">2</span>,<span class="number">1</span>),xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([xnyn(<span class="number">1</span>,<span class="number">1</span>),xny0(<span class="number">1</span>,<span class="number">1</span>)],[xnyn(<span class="number">2</span>,<span class="number">1</span>),xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([xny0(<span class="number">1</span>,<span class="number">1</span>),x0y0(<span class="number">1</span>,<span class="number">1</span>)],[xny0(<span class="number">2</span>,<span class="number">1</span>),x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 变换后图像（蓝色）</span></span><br><span class="line"><span class="built_in">plot</span>(toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;b*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>)],[toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>)],[toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">1</span>,<span class="number">1</span>)],[toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>)],[toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用一个矩形框起来（绿色）</span></span><br><span class="line">all_x = [toushi_x0y0(<span class="number">1</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">1</span>,<span class="number">1</span>),toushi_xny0(<span class="number">1</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">1</span>,<span class="number">1</span>)];</span><br><span class="line">all_y = [toushi_x0y0(<span class="number">2</span>,<span class="number">1</span>),toushi_x0yn(<span class="number">2</span>,<span class="number">1</span>),toushi_xny0(<span class="number">2</span>,<span class="number">1</span>),toushi_xnyn(<span class="number">2</span>,<span class="number">1</span>)];</span><br><span class="line">new_x0y0 = [<span class="built_in">min</span>(all_x);<span class="built_in">min</span>(all_y)]</span><br><span class="line">new_x0yn = [<span class="built_in">min</span>(all_x);<span class="built_in">max</span>(all_y)];</span><br><span class="line">new_xnyn = [<span class="built_in">max</span>(all_x);<span class="built_in">max</span>(all_y)]</span><br><span class="line">new_xny0 = [<span class="built_in">max</span>(all_x);<span class="built_in">min</span>(all_y)];</span><br><span class="line"><span class="built_in">plot</span>(new_x0y0(<span class="number">1</span>,<span class="number">1</span>),new_x0y0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_x0yn(<span class="number">1</span>,<span class="number">1</span>),new_x0yn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_xnyn(<span class="number">1</span>,<span class="number">1</span>),new_xnyn(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(new_xny0(<span class="number">1</span>,<span class="number">1</span>),new_xny0(<span class="number">2</span>,<span class="number">1</span>),<span class="string">&#x27;g*&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_x0y0(<span class="number">1</span>,<span class="number">1</span>),new_x0yn(<span class="number">1</span>,<span class="number">1</span>)],[new_x0y0(<span class="number">2</span>,<span class="number">1</span>),new_x0yn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_x0yn(<span class="number">1</span>,<span class="number">1</span>),new_xnyn(<span class="number">1</span>,<span class="number">1</span>)],[new_x0yn(<span class="number">2</span>,<span class="number">1</span>),new_xnyn(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_xnyn(<span class="number">1</span>,<span class="number">1</span>),new_xny0(<span class="number">1</span>,<span class="number">1</span>)],[new_xnyn(<span class="number">2</span>,<span class="number">1</span>),new_xny0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">line([new_xny0(<span class="number">1</span>,<span class="number">1</span>),new_x0y0(<span class="number">1</span>,<span class="number">1</span>)],[new_xny0(<span class="number">2</span>,<span class="number">1</span>),new_x0y0(<span class="number">2</span>,<span class="number">1</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%输出G的尺寸</span></span><br><span class="line">delta_x = <span class="built_in">max</span>(all_x) - <span class="built_in">min</span>(all_x)</span><br><span class="line">delta_y = <span class="built_in">max</span>(all_y) - <span class="built_in">min</span>(all_y)</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>运行代码，输出图像，下图中<strong>黑色矩形</strong>为原图像F，<strong>蓝色矩形</strong>为透视变换后的图像，<strong>绿色矩形</strong>是用矩形框起来的最终图像G：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220308173653334.png" alt="image-20220308173653334" style="zoom:67%;"></p><p>同时MATLAB控制台输出<strong>delta_x = 3.7003e+03</strong>，<strong>delta_y = 2.2660e+03</strong></p><p>也就是说经过透视变换后的图像G的尺寸为<strong>3700.3*2266</strong></p><h2 id="OpenCV验证"><a href="#OpenCV验证" class="headerlink" title="OpenCV验证"></a>OpenCV验证</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>随便选取一张图片，将其拉伸到640*480，再对其进行上述变换矩阵指定的透视变换，最后输出图片。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伸缩图片至640*480</span></span><br><span class="line">Mat imgResize;</span><br><span class="line"><span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">640</span>,<span class="number">480</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变换前与变换后的顶点坐标</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">640</span>,<span class="number">480</span>&#125;,&#123;<span class="number">0</span>,<span class="number">480</span>&#125;,&#123;<span class="number">640</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">537.0f</span>,<span class="number">554.0f</span>&#125;,&#123;<span class="number">3337.2f</span>,<span class="number">1911.2f</span>&#125;,&#123;<span class="number">-363.0f</span>,<span class="number">2756.8</span>&#125;,&#123;<span class="number">3190.8</span>,<span class="number">490.9</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line">Mat imgWarp;</span><br><span class="line"><span class="built_in">warpPerspective</span>(imgResize, imgWarp, matrix, <span class="built_in">Size</span>(<span class="number">4000</span>, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记原始图像位置</span></span><br><span class="line"><span class="built_in">rectangle</span>(imgWarp, <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">Point</span>(<span class="number">640</span>, <span class="number">480</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line"><span class="built_in">putText</span>(imgWarp, <span class="string">&quot;Origin Image&quot;</span>, <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>), FONT_HERSHEY_COMPLEX, <span class="number">2</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出变换后图像</span></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;res/output.jpg&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>下图中左上角为原始图像（合并显示有点麻烦所以只画了一个跟原始图像一样大的白色矩形代替）</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/output.jpg" alt="output" style="zoom:67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</title>
    <link href="https://www.robotsfan.com/posts/b5b2ecfc.html"/>
    <id>https://www.robotsfan.com/posts/b5b2ecfc.html</id>
    <published>2022-03-11T02:00:00.000Z</published>
    <updated>2022-03-11T02:28:34.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"><a href="#OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道" class="headerlink" title="OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道"></a>OpenCV实现彩色图片的读取，进行RGB通道分离，并转化为HSV通道</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RGB_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mat RGB_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line"><span class="function">Mat* <span class="title">Set_RGB_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line"><span class="function">Mat <span class="title">Get_R</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_G</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_B</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> RGB_Color_Channels[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//HSV类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSV_Channels</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mat HSV_Color_Channels[<span class="number">3</span>]; <span class="comment">//私有成员，禁止外部访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//外部修改接口</span></span><br><span class="line"><span class="function">Mat* <span class="title">Set_HSV_Color_Channels</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//仅读取，禁止外部修改</span></span><br><span class="line"><span class="function">Mat <span class="title">Get_V</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_S</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Get_H</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> HSV_Color_Channels[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//彩色图片的读取</span></span><br><span class="line">Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//RGB三通道分离并显示</span></span><br><span class="line">RGB_Channels my_rgb;</span><br><span class="line"><span class="built_in">split</span>(image,my_rgb.<span class="built_in">Set_RGB_Color_Channels</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;R&quot;</span>,my_rgb.<span class="built_in">Get_R</span>());</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;G&quot;</span>,my_rgb.<span class="built_in">Get_G</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;B&quot;</span>,my_rgb.<span class="built_in">Get_B</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//RGB转HSV</span></span><br><span class="line">Mat image_hsv;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, image_hsv, COLOR_BGR2HSV_FULL);</span><br><span class="line"><span class="comment">//HSV三通道分离并显示</span></span><br><span class="line">HSV_Channels my_hsv;</span><br><span class="line"><span class="built_in">split</span>(image_hsv,my_hsv.<span class="built_in">Set_HSV_Color_Channels</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;RGB&quot;</span>,image);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;H&quot;</span>,my_hsv.<span class="built_in">Get_H</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;S&quot;</span>,my_hsv.<span class="built_in">Get_S</span>());</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;V&quot;</span>,my_hsv.<span class="built_in">Get_V</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/8f0ffc2404d1a1957390a20f6bb47673.png" alt="image-20220302161619338"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记</title>
    <link href="https://www.robotsfan.com/posts/404e593e.html"/>
    <id>https://www.robotsfan.com/posts/404e593e.html</id>
    <published>2022-03-09T09:30:00.000Z</published>
    <updated>2022-03-09T09:18:02.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><h2 id="1-导入图像视频和网络摄像头"><a href="#1-导入图像视频和网络摄像头" class="headerlink" title="1 导入图像视频和网络摄像头"></a>1 导入图像视频和网络摄像头</h2><p>首先包含三个常用的头文件和IO库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后需要使用命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h3 id="1-1-图像"><a href="#1-1-图像" class="headerlink" title="1.1 图像"></a>1.1 图像</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 首先需要定义图像文件路径，使用string类型来存储</span></span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">    <span class="comment">// 用Mat类型读取图像</span></span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;图像&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 使用waitKey进行一个延时，否则图像会立即关闭。0为无穷大，即不会关闭。</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-视频"><a href="#1-2-视频" class="headerlink" title="1.2 视频"></a>1.2 视频</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 首先需要定义视频文件路径，使用string类型来存储</span></span><br><span class="line">string path = <span class="string">&quot;res/test_video.mp4&quot;</span>;</span><br><span class="line"><span class="comment">// 构造VideoCapture类型对象</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line"><span class="comment">// 单帧图像</span></span><br><span class="line">Mat img;</span><br><span class="line"><span class="comment">// 对于视频来说需要捕获所有帧并显示，所以需要while循环。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 读取一帧图像</span></span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"><span class="comment">// 显示图像</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;视频&quot;</span>, img);</span><br><span class="line"><span class="comment">// 这时需要延时，否则视频非常快</span></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视频结束后会抛出错误（无法读取文件），原因为视频结束后没有图像送入img所以报错。</p><h3 id="1-3-摄像头"><a href="#1-3-摄像头" class="headerlink" title="1.3 摄像头"></a>1.3 摄像头</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 摄像头不需要路径，需要输入相机的ID号，剩下的和读取视频一样</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line">Mat img;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;摄像头&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基本函数"><a href="#2-基本函数" class="headerlink" title="2 基本函数"></a>2 基本函数</h2><p>前文包含的头文件<code>#include &lt;opencv2/imgproc.hpp&gt;</code>就是图像处理的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">Mat imgGray;</span><br><span class="line"><span class="comment">// “convert”，即为转换图像的颜色空间，这里将彩色图想转换为灰度图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line"></span><br><span class="line">Mat imgBlur;</span><br><span class="line"><span class="comment">// 添加高斯模糊(7*7)</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line"></span><br><span class="line">Mat imgCanny;</span><br><span class="line"><span class="comment">// 边缘检测，通常在边缘检测前对图像进行一次高斯模糊(可以自行对比有什么区别)</span></span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时进行边缘检测的时候，没有被完全填充，或者无法正确检测，可以用膨胀和腐蚀</span></span><br><span class="line">Mat imgDil, imgErode;</span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgDil);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Erode&quot;</span>, imgErode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122257889.png" alt="image-20220309122257889"></p><h2 id="3-对图像进行伸缩和剪裁"><a href="#3-对图像进行伸缩和剪裁" class="headerlink" title="3 对图像进行伸缩和剪裁"></a>3 对图像进行伸缩和剪裁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/test_image.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伸缩</span></span><br><span class="line">Mat imgResize;</span><br><span class="line"><span class="comment">// 使用size方法查看图像尺寸</span></span><br><span class="line">cout &lt;&lt; img.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 可以调整成具体的大小</span></span><br><span class="line"><span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(<span class="number">400</span>,<span class="number">600</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Resize Size()&quot;</span>, imgResize);</span><br><span class="line"><span class="comment">// 也可以调整缩放比例fxfy</span></span><br><span class="line"><span class="built_in">resize</span>(img, imgResize, <span class="built_in">Size</span>(),<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Resize &quot;</span>, imgResize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裁剪</span></span><br><span class="line">Mat imgCrop;</span><br><span class="line"><span class="comment">// 矩形数据类型，前两个参数为剪裁起点（左上角 x = 0, y = 0），后两个参数为宽和高</span></span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(<span class="number">200</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"><span class="comment">// 使用刚刚定义的矩形对图像进行裁剪</span></span><br><span class="line">imgCrop = <span class="built_in">img</span>(roi);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122213509.png" alt="image-20220309122213509"></p><h2 id="4-绘制形状和文字"><a href="#4-绘制形状和文字" class="headerlink" title="4 绘制形状和文字"></a>4 绘制形状和文字</h2><p>下文中，使用Point()定义一个点，使用Scalar()定义一个标量（颜色）</p><p>绘制形状和文字所用函数中最后两个参数均为颜色和厚度(FILLED为填充)，不再重复说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建一个空白图像，512*512大小，8位3通道(CV_8UC3)，白色(255,255,255)</span></span><br><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">512</span>, <span class="number">512</span>, CV_8UC3, Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画圆 传入圆心，半径</span></span><br><span class="line"><span class="built_in">circle</span>(img, <span class="built_in">Point</span>(<span class="number">256</span>, <span class="number">256</span>), <span class="number">155</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),FILLED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画矩形 传入左上角与右下角点的坐标</span></span><br><span class="line"><span class="built_in">rectangle</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">226</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">286</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), FILLED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画线 传入起点和终点的坐标</span></span><br><span class="line"><span class="built_in">line</span>(img, <span class="built_in">Point</span>(<span class="number">130</span>, <span class="number">296</span>), <span class="built_in">Point</span>(<span class="number">382</span>, <span class="number">296</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文字 传入文字，左上角坐标，字体，比例</span></span><br><span class="line"><span class="built_in">putText</span>(img, <span class="string">&quot;OpenCV Learning&quot;</span>, <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">262</span>), FONT_HERSHEY_COMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122144678.png" alt="image-20220309122144678"></p><h2 id="5-透视变换"><a href="#5-透视变换" class="headerlink" title="5 透视变换"></a>5 透视变换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/cards.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用画图工具获取到点坐标，使用Point2f创建浮点数</span></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>,<span class="number">142</span>&#125;,&#123;<span class="number">771</span>,<span class="number">190</span>&#125;,&#123;<span class="number">405</span>,<span class="number">395</span>&#125;,&#123;<span class="number">674</span>,<span class="number">457</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变换后的大小</span></span><br><span class="line"><span class="keyword">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建变换矩阵</span></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视变换</span></span><br><span class="line">Mat imgWarp;</span><br><span class="line"><span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Size</span>(w, h));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示四个顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，成功将图形矫正</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309122100872.png" alt="image-20220309122100872"></p><h2 id="6-颜色识别"><a href="#6-颜色识别" class="headerlink" title="6 颜色识别"></a>6 颜色识别</h2><p>颜色识别需要设定选取好的hsv三个通道的最大值和最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/lambo.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">Mat imgHSV;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义选取好的六个值</span></span><br><span class="line"><span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line"><span class="keyword">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// 定义下限和上限</span></span><br><span class="line"><span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line"><span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建遮罩</span></span><br><span class="line">Mat mask;</span><br><span class="line"><span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行查看效果</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121922828.png" alt="image-20220309121922828"></p><p>上面的值可以使用Trackbar试出来，替换一张图片再次尝试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在HSV空间中查找颜色更加容易，所以先转化为HSV颜色空间</span></span><br><span class="line">Mat imgHSV;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定初始值</span></span><br><span class="line"><span class="keyword">int</span> hmin = <span class="number">0</span>, smin = <span class="number">0</span>, vmin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hmax = <span class="number">179</span>, smax = <span class="number">255</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建遮罩</span></span><br><span class="line">Mat mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义窗口名</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line"><span class="comment">// 创建Trackbar</span></span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line"><span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line"><span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始值是这样的</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121750288.png" alt="image-20220309121750288"></p><p>因为这张图里都是确定的颜色，所以只需要拖动前两行即可筛选出想要的颜色</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309121842503.png" alt="image-20220309121842503"></p><h2 id="7-形状识别"><a href="#7-形状识别" class="headerlink" title="7 形状识别"></a>7 形状识别</h2><p>本节将学习如何检测圆形、正方形、矩形、三角形这些形状，和识别出图像中的轮廓</p><h3 id="7-1-预处理"><a href="#7-1-预处理" class="headerlink" title="7.1 预处理"></a>7.1 预处理</h3><p>首先对图像进行预处理得到边缘，依次进行灰度处理、高斯模糊、边缘检测、膨胀、腐蚀。详见</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 原始图像</span></span><br><span class="line">string path = <span class="string">&quot;res/shapes.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在识别形状之前需要对图片进行一系列的预处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 灰度处理</span></span><br><span class="line">Mat imgGray;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯模糊</span></span><br><span class="line">Mat imgBlur;</span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边缘检测</span></span><br><span class="line">Mat imgCanny;</span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>,<span class="number">75</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 膨胀和腐蚀</span></span><br><span class="line">Mat imgDil, imgErode;</span><br><span class="line"><span class="comment">// 创建一个用于膨胀和腐蚀的内核，后面的数字越大膨胀的越多(数字要用奇数)</span></span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 膨胀</span></span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line"><span class="comment">// 腐蚀</span></span><br><span class="line"><span class="built_in">erode</span>(imgDil, imgErode, kernel);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//// 在这里进行边缘检测</span></span><br><span class="line"><span class="comment">//getContours(imgDil,img);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Gray&quot;</span>, imgGray);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Blur&quot;</span>, imgBlur);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Canny&quot;</span>, imgCanny);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Dil&quot;</span>, imgDil);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从处理后的图像可以看到，单单使用边缘检测，三角形的轮廓线断断续续，会对之后的识别造成影响。经过膨胀之后的图像轮廓线是实线，边缘特性更好。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309144348598.png" alt="image-20220309144348598"></p><p>关闭主函数中无用的输出，只留下<code>imshow(&quot;Image&quot;, img);</code>，然后去除<code>getContours(imgDil,img);</code>的注释，再进行下一步。</p><h3 id="7-2-找到轮廓"><a href="#7-2-找到轮廓" class="headerlink" title="7.2 找到轮廓"></a>7.2 找到轮廓</h3><p>根据边缘找到轮廓</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * contours是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素。</span></span><br><span class="line"><span class="comment"> * 相当于创建了这样一个向量&#123;&#123;Point(),Point()&#125;,&#123;&#125;,&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每个元素保存了一个包含4个int整型的数组。向量hiararchy内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同。</span></span><br><span class="line"><span class="comment"> * hierarchy向量内每一个元素的4个int型变量——hierarchy[i][0] ~ hierarchy[i][3]，分别表示第i个轮廓的后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号。</span></span><br><span class="line"><span class="comment"> * 如果当前轮廓没有对应的后一个轮廓、前一个轮廓、父轮廓或内嵌轮廓的话，则hierarchy[i][0] ~ hierarchy[i][3]的相应位被设置为默认值-1。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 找到轮廓</span></span><br><span class="line"><span class="comment"> * 第一个参数：单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像；</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours （前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第三个参数：hierarchy（前文介绍过）</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓的检索模式</span></span><br><span class="line"><span class="comment"> * 取值一：CV_RETR_EXTERNAL 只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略</span></span><br><span class="line"><span class="comment"> * 取值二：CV_RETR_LIST     检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1，具体下文会讲到</span></span><br><span class="line"><span class="comment"> * 取值三：CV_RETR_CCOMP    检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层</span></span><br><span class="line"><span class="comment"> * 取值四：CV_RETR_TREE     检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓的近似方法</span></span><br><span class="line"><span class="comment"> * 取值一：CV_CHAIN_APPROX_NONE   保存物体边界上所有连续的轮廓点到contours向量内</span></span><br><span class="line"><span class="comment"> * 取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</span></span><br><span class="line"><span class="comment"> * 取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment"> * 第六个参数：Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，且Point可以是负值。不填为默认不偏移Point()</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一个参数：指明在哪幅图像上绘制轮廓。image为三通道才能显示轮廓</span></span><br><span class="line"><span class="comment"> * 第二个参数：contours</span></span><br><span class="line"><span class="comment"> * 第三个参数：指定绘制哪条轮廓，如果是-1，则绘制其中的所有轮廓</span></span><br><span class="line"><span class="comment"> * 第四个参数：轮廓线颜色</span></span><br><span class="line"><span class="comment"> * 第五个参数：轮廓线的宽度，如果是-1（FILLED），则为填充</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">drawContours</span>(img_output, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，图像轮廓被正确地识别出来了。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309134724054.png" alt="image-20220309134724054"></p><h3 id="7-3-去除噪声"><a href="#7-3-去除噪声" class="headerlink" title="7.3 去除噪声"></a>7.3 去除噪声</h3><p>假设图像中最小的黑色圆圈为噪声，我们要将其滤除，所以需要判断轮廓大小并对其筛选。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设图像中有噪声，需要将其过滤</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//检测轮廓大小</span></span><br><span class="line"><span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">cout &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">drawContours</span>(img_output, contours, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，黑色噪声成功被滤除</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309135058081.png" alt="image-20220309135058081"></p><h3 id="7-4-识别形状"><a href="#7-4-识别形状" class="headerlink" title="7.4 识别形状"></a>7.4 识别形状</h3><p>下一步我们要找到这些轮廓的角点，并对角点的数量进行判断，例如三角形就是3，四边形就是4，圆形可能七八个，并同时绘制出边界框与形状名称。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getContours</span><span class="params">(Mat img_input, Mat img_output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">// 不全输出，在下文只输出角点</span></span><br><span class="line"><span class="comment">//drawContours(img_output, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义轮廓，大小与contours相同，但内层向量中只有角点（例如三角形就是3，四边形就是4，圆形可能七八个）</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义边界框，大小与contours相同</span></span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图形形状字符串</span></span><br><span class="line">string object_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算每个轮廓的周长</span></span><br><span class="line"><span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DP算法计算出轮廓点的个数，规则为周长*0.02</span></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出边界框</span></span><br><span class="line">bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过判断角点的数量来确定是什么形状</span></span><br><span class="line"><span class="keyword">int</span> object_corners = (<span class="keyword">int</span>)contours_corners[i].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(object_corners == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Triangle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(object_corners == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 通过计算宽高比来区分正方形和矩形</span></span><br><span class="line"><span class="keyword">float</span> aspect_ratio = (<span class="keyword">float</span>)bounding_box[i].width / (<span class="keyword">float</span>)bounding_box[i].height;</span><br><span class="line">cout &lt;&lt; aspect_ratio &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 宽高比在0.95~1.05范围内算作正方形</span></span><br><span class="line"><span class="keyword">if</span> (aspect_ratio &gt; <span class="number">0.95</span> &amp;&amp; aspect_ratio &lt; <span class="number">1.05</span>)</span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其余的算作矩形</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Rectangle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(object_corners &gt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">object_type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只绘制角点之间的边框线</span></span><br><span class="line"><span class="built_in">drawContours</span>(img_output, contours_corners, i, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 绘制矩形，bounding_box[i].tl()左上角，bounding_box[i].br()右下角</span></span><br><span class="line"><span class="built_in">rectangle</span>(img_output, bounding_box[i].<span class="built_in">tl</span>(), bounding_box[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 绘制文字（什么形状），绘制在边框的左上角再往上5像素</span></span><br><span class="line"><span class="built_in">putText</span>(img_output, object_type, <span class="built_in">Point</span>(bounding_box[i].x, bounding_box[i].y - <span class="number">5</span> ), FONT_HERSHEY_PLAIN, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不同形状的物体被成功识别出。</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309143927287.png" alt="image-20220309143927287"></p><h2 id="8-人脸检测"><a href="#8-人脸检测" class="headerlink" title="8 人脸检测"></a>8 人脸检测</h2><p>人脸检测需要包含<code>#include &lt;opencv2/objdetect.hpp&gt;</code>头文件</p><p>使用OpenCV自带的Haar特征分类器进行检测。Haar特征分类器就是一个XML文件，该文件中会描述人体各个部位的Haar特征值。包括人脸、眼睛、嘴唇等等。通常被放置在一个叫haarcascades的目录下（全盘搜索一下就能找到），有以下这些：</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309152132992.png" alt="image-20220309152132992"></p><p>根据命名可以知道各个分类器的用途。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;res/face.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写级联分类器</span></span><br><span class="line">CascadeClassifier faceCascade;</span><br><span class="line"><span class="comment">// 加载训练好的模型（族特征数据库）这里的路径请自行修改</span></span><br><span class="line">faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个矩形向量</span></span><br><span class="line">vector&lt;Rect&gt; faces;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 族检测算法</span></span><br><span class="line"><span class="comment"> * 参数1：image--待检测图片，一般为灰度图像加快检测速度；</span></span><br><span class="line"><span class="comment"> * 参数2：objects--被检测物体的矩形框向量组；</span></span><br><span class="line"><span class="comment"> * 参数3：scaleFactor--表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1即每次搜索窗口依次扩大10%;</span></span><br><span class="line"><span class="comment"> * 参数4：minNeighbors--表示构成检测目标的相邻矩形的最小个数(默认为3个)。</span></span><br><span class="line"><span class="comment"> * 如果组成检测目标的小矩形的个数和小于 min_neighbors - 1 都会被排除。</span></span><br><span class="line"><span class="comment"> * 如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框，</span></span><br><span class="line"><span class="comment"> * 这种设定值一般用在用户自定义对检测结果的组合程序上；</span></span><br><span class="line"><span class="comment"> * 参数5：flags--要么使用默认值，要么使用CV_HAAR_DO_CANNY_PRUNING</span></span><br><span class="line"><span class="comment"> * 如果设置为CV_HAAR_DO_CANNY_PRUNING，那么函数将会使用Canny边缘检测来排除边缘过多或过少的区域，因此这些区域通常不会是人脸所在区域；</span></span><br><span class="line"><span class="comment"> * 参数6、7：minSize和maxSize用来限制得到的目标区域的范围。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在脸四周画出矩形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到成功检测到人脸</p><p><img src="https://fan-ziqi.oss-cn-beijing.aliyuncs.com/img/image-20220309153539038.png" alt="image-20220309153539038"></p><p>同样地，可以对视频流进行同样的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">CascadeClassifier faceCascade;</span><br><span class="line">faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Rect&gt; faces;</span><br><span class="line">faceCascade.<span class="built_in">detectMultiScale</span>(img, faces, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(img, faces[i].<span class="built_in">tl</span>(), faces[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面演示三个应用</p><h2 id="应用1-空间绘图"><a href="#应用1-空间绘图" class="headerlink" title="应用1 空间绘图"></a>应用1 空间绘图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////  Project 1 - 虚拟绘图 //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints;  <span class="comment">// to store all points</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////  颜色定义 ////////////////////////////////</span></span><br><span class="line"><span class="comment">// 使用前面讲过的程序提取颜色</span></span><br><span class="line"><span class="comment">// hmin, smin, vmin hmax, smax, vmax</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; myColors&#123; &#123;<span class="number">95</span>,<span class="number">22</span>,<span class="number">49</span>,<span class="number">139</span>,<span class="number">138</span>,<span class="number">92</span>&#125;, <span class="comment">// Green</span></span><br><span class="line">  &#123;<span class="number">144</span>,<span class="number">76</span>,<span class="number">63</span>,<span class="number">179</span>,<span class="number">166</span>,<span class="number">154</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line">vector&lt;Scalar&gt; myColorValues&#123; &#123;<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>&#125;,<span class="comment">// Green</span></span><br><span class="line">  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>&#125; &#125;;<span class="comment">// Red</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">getContours</span><span class="params">(Mat img_input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(img_input, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">contours_corners</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">bounding_box</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义笔头位置</span></span><br><span class="line"><span class="function">Point <span class="title">myPoint</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> contour_area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line">cout &lt;&lt; contour_area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contour_area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> contour_perimeter = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], contours_corners[i], <span class="number">0.02</span> * contour_perimeter, <span class="literal">true</span>);</span><br><span class="line">cout &lt;&lt; contours_corners[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">bounding_box[i] = <span class="built_in">boundingRect</span>(contours_corners[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定笔头位置为设定点</span></span><br><span class="line">myPoint.x = bounding_box[i].x + bounding_box[i].width / <span class="number">2</span>;</span><br><span class="line">myPoint.y = bounding_box[i].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 显示角和边界框</span></span><br><span class="line"><span class="comment">//drawContours(img, contours_corners, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(img, bounding_box[i].tl(), bounding_box[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> myPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findColor</span>(Mat img)</span><br><span class="line">&#123;</span><br><span class="line">Mat imgHSV;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myColors.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Scalar <span class="title">lower</span><span class="params">(myColors[i][<span class="number">0</span>], myColors[i][<span class="number">1</span>], myColors[i][<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function">Scalar <span class="title">upper</span><span class="params">(myColors[i][<span class="number">3</span>], myColors[i][<span class="number">4</span>], myColors[i][<span class="number">5</span>])</span></span>;</span><br><span class="line">Mat mask;</span><br><span class="line"><span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="built_in">to_string</span>(i), mask);</span><br><span class="line">Point myPoint = <span class="built_in">getContours</span>(mask);</span><br><span class="line"><span class="keyword">if</span> (myPoint.x != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 每个myPoint都有三个值，xy和颜色序号</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(&#123; myPoint.x,myPoint.y,i &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawOnCanvas</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; newPoints, vector&lt;Scalar&gt; myColorValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newPoints.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(img, <span class="built_in">Point</span>(newPoints[i][<span class="number">0</span>],newPoints[i][<span class="number">1</span>]), <span class="number">10</span>, myColorValues[newPoints[i][<span class="number">2</span>]], FILLED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_WIDTH, <span class="number">640</span>);</span><br><span class="line">cap.<span class="built_in">set</span>(CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line">newPoints = <span class="built_in">findColor</span>(img);</span><br><span class="line"><span class="built_in">drawOnCanvas</span>(newPoints, myColorValues);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-应用2-文章扫描"><a href="#10-应用2-文章扫描" class="headerlink" title="10 应用2 文章扫描"></a>10 应用2 文章扫描</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 2 - Document Scanner  //////////////////////</span></span><br><span class="line"></span><br><span class="line">Mat imgOriginal, imgGray, imgBlur, imgCanny, imgThre, imgDil, imgErode, imgWarp, imgCrop;</span><br><span class="line">vector&lt;Point&gt; initialPoints,docPoints;</span><br><span class="line"><span class="keyword">float</span> w = <span class="number">420</span>, h = <span class="number">596</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">preProcessing</span><span class="params">(Mat img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, imgGray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">GaussianBlur</span>(imgGray, imgBlur, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Canny</span>(imgBlur, imgCanny, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line">Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">dilate</span>(imgCanny, imgDil, kernel);</span><br><span class="line"><span class="comment">//erode(imgDil, imgErode, kernel);</span></span><br><span class="line"><span class="keyword">return</span> imgDil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">getContours</span><span class="params">(Mat image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(image, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">//drawContours(img, contours, -1, Scalar(255, 0, 255), 2);</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; biggest;</span><br><span class="line"><span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> area = <span class="built_in">contourArea</span>(contours[i]);</span><br><span class="line"><span class="comment">//cout &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">string objectType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (area &gt; <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (area &gt; maxArea &amp;&amp; conPoly[i].<span class="built_in">size</span>()==<span class="number">4</span> ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 5);</span></span><br><span class="line">biggest = &#123; conPoly[i][<span class="number">0</span>],conPoly[i][<span class="number">1</span>] ,conPoly[i][<span class="number">2</span>] ,conPoly[i][<span class="number">3</span>] &#125;;</span><br><span class="line">maxArea = area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//drawContours(imgOriginal, conPoly, i, Scalar(255, 0, 255), 2);</span></span><br><span class="line"><span class="comment">//rectangle(imgOriginal, boundRect[i].tl(), boundRect[i].br(), Scalar(0, 255, 0), 5);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawPoints</span><span class="params">(vector&lt;Point&gt; points, Scalar color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">circle</span>(imgOriginal, points[i], <span class="number">10</span>, color, FILLED);</span><br><span class="line"><span class="built_in">putText</span>(imgOriginal, <span class="built_in">to_string</span>(i), points[i], FONT_HERSHEY_PLAIN, <span class="number">4</span>, color, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">reorder</span><span class="params">(vector&lt;Point&gt; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Point&gt; newPoints;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;  sumPoints, subPoints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">sumPoints.<span class="built_in">push_back</span>(points[i].x + points[i].y);</span><br><span class="line">subPoints.<span class="built_in">push_back</span>(points[i].x - points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//0</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//1</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">min_element</span>(subPoints.<span class="built_in">begin</span>(), subPoints.<span class="built_in">end</span>()) - subPoints.<span class="built_in">begin</span>()]); <span class="comment">//2</span></span><br><span class="line">newPoints.<span class="built_in">push_back</span>(points[<span class="built_in">max_element</span>(sumPoints.<span class="built_in">begin</span>(), sumPoints.<span class="built_in">end</span>()) - sumPoints.<span class="built_in">begin</span>()]); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">getWarp</span><span class="params">(Mat img, vector&lt;Point&gt; points, <span class="keyword">float</span> w, <span class="keyword">float</span> h )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; points[<span class="number">0</span>],points[<span class="number">1</span>],points[<span class="number">2</span>],points[<span class="number">3</span>] &#125;;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;,&#123;w,<span class="number">0.0f</span>&#125;,&#123;<span class="number">0.0f</span>,h&#125;,&#123;w,h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">Mat matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> imgWarp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">string path = <span class="string">&quot;res/paper.jpg&quot;</span>;</span><br><span class="line">imgOriginal = <span class="built_in">imread</span>(path);</span><br><span class="line"><span class="built_in">resize</span>(imgOriginal, imgOriginal, <span class="built_in">Size</span>(), <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preprpcessing - Step 1</span></span><br><span class="line">imgThre = <span class="built_in">preProcessing</span>(imgOriginal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Contours - Biggest  - Step 2</span></span><br><span class="line">initialPoints = <span class="built_in">getContours</span>(imgThre);</span><br><span class="line"><span class="comment">//drawPoints(initialPoints, Scalar(0, 0, 255));</span></span><br><span class="line">docPoints = <span class="built_in">reorder</span>(initialPoints);</span><br><span class="line"><span class="comment">//drawPoints(docPoints, Scalar(0, 255, 0));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Warp - Step 3</span></span><br><span class="line">imgWarp = <span class="built_in">getWarp</span>(imgOriginal, docPoints, w, h);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Crop - Step 4</span></span><br><span class="line"><span class="keyword">int</span> cropVal= <span class="number">5</span>;</span><br><span class="line"><span class="function">Rect <span class="title">roi</span><span class="params">(cropVal, cropVal, w - (<span class="number">2</span> * cropVal), h - (<span class="number">2</span> * cropVal))</span></span>;</span><br><span class="line">imgCrop = <span class="built_in">imgWarp</span>(roi);</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, imgOriginal);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Dilation&quot;</span>, imgThre);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Warp&quot;</span>, imgWarp);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image Crop&quot;</span>, imgCrop);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用3-车牌检测"><a href="#应用3-车牌检测" class="headerlink" title="应用3 车牌检测"></a>应用3 车牌检测</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////  Project 3 - 牌照检测 //////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat img;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">CascadeClassifier plateCascade;</span><br><span class="line">plateCascade.<span class="built_in">load</span>(<span class="string">&quot;Resources/haarcascade_russian_plate_number.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (plateCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;XML file not loaded&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Rect&gt; plates;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line">plateCascade.<span class="built_in">detectMultiScale</span>(img, plates, <span class="number">1.1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plates.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Mat imgCrop = <span class="built_in">img</span>(plates[i]);</span><br><span class="line"><span class="comment">//imshow(to_string(i), imgCrop);</span></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;Resources/Plates/&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;.png&quot;</span>, imgCrop);</span><br><span class="line"><span class="built_in">rectangle</span>(img, plates[i].<span class="built_in">tl</span>(), plates[i].<span class="built_in">br</span>(), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="https://www.robotsfan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04安装OpenCV并配置Clion工程</title>
    <link href="https://www.robotsfan.com/posts/eb0a41f8.html"/>
    <id>https://www.robotsfan.com/posts/eb0a41f8.html</id>
    <published>2022-02-27T02:30:00.000Z</published>
    <updated>2022-02-27T02:37:46.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Ubuntu20-04安装OpenCV并配置Clion工程"><a href="#Ubuntu20-04安装OpenCV并配置Clion工程" class="headerlink" title="Ubuntu20.04安装OpenCV并配置Clion工程"></a>Ubuntu20.04安装OpenCV并配置Clion工程</h1><h2 id="1-OpenCV安装"><a href="#1-OpenCV安装" class="headerlink" title="1 OpenCV安装"></a>1 OpenCV安装</h2><h3 id="1-1-二进制安装"><a href="#1-1-二进制安装" class="headerlink" title="1.1 二进制安装"></a>1.1 二进制安装</h3><p>Ubuntu20.04支持apt二进制安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libopencv-dev python3-opencv</span><br></pre></td></tr></table></figure><p>查看版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import cv2; print(cv2.__version__)&quot;</span></span><br></pre></td></tr></table></figure><p>安装成功返回<code>4.2.0</code></p><h3 id="1-2-源码安装"><a href="#1-2-源码安装" class="headerlink" title="1.2 源码安装"></a>1.2 源码安装</h3><h4 id="1-2-1-安装编译环境和依赖"><a href="#1-2-1-安装编译环境和依赖" class="headerlink" title="1.2.1 安装编译环境和依赖"></a>1.2.1 安装编译环境和依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential cmake git pkg-config libgtk-3-dev \</span><br><span class="line">    libavcodec-dev libavformat-dev libswscale-dev libv4l-dev \</span><br><span class="line">    libxvidcore-dev libx264-dev libjpeg-dev libpng-dev libtiff-dev \</span><br><span class="line">    gfortran openexr libatlas-base-dev python3-dev python3-numpy \</span><br><span class="line">    libtbb2 libtbb-dev libdc1394-22-dev libopenexr-dev \</span><br><span class="line">    libgstreamer-plugins-base1.0-dev libgstreamer1.0-dev</span><br></pre></td></tr></table></figure><h4 id="1-2-2-Clone最新的OpenCV源码"><a href="#1-2-2-Clone最新的OpenCV源码" class="headerlink" title="1.2.2 Clone最新的OpenCV源码"></a>1.2.2 Clone最新的OpenCV源码</h4><p>截止2022.02.27，GitHub更新到OpenCV4.5.5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/opencv_build &amp;&amp; <span class="built_in">cd</span> ~/opencv_build</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure><h4 id="1-2-3-Cmake编译"><a href="#1-2-3-Cmake编译" class="headerlink" title="1.2.3 Cmake编译"></a>1.2.3 Cmake编译</h4><h5 id="1-2-3-1-创建临时目录"><a href="#1-2-3-1-创建临时目录" class="headerlink" title="1.2.3.1 创建临时目录"></a>1.2.3.1 创建临时目录</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv_build/opencv</span><br><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><h5 id="1-2-3-2-设置编译选项"><a href="#1-2-3-2-设置编译选项" class="headerlink" title="1.2.3.2 设置编译选项"></a>1.2.3.2 设置编译选项</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=ON \</span><br><span class="line">    -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">    -D OPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">    -D OPENCV_EXTRA_MODULES_PATH=~/opencv_build/opencv_contrib/modules \</span><br><span class="line">    -D BUILD_EXAMPLES=ON ..</span><br></pre></td></tr></table></figure><p>正常应该出现以下提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/vagrant/opencv_build/opencv/build</span><br></pre></td></tr></table></figure><h5 id="1-2-3-3-开始Cmake编译"><a href="#1-2-3-3-开始Cmake编译" class="headerlink" title="1.2.3.3 开始Cmake编译"></a>1.2.3.3 开始Cmake编译</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>注：j后面的数字为处理器内核数，可以使用<code>nproc</code>来查询</p><h4 id="1-2-4-安装OpenCV"><a href="#1-2-4-安装OpenCV" class="headerlink" title="1.2.4 安装OpenCV"></a>1.2.4 安装OpenCV</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="1-2-5-验证安装"><a href="#1-2-5-验证安装" class="headerlink" title="1.2.5 验证安装"></a>1.2.5 验证安装</h4><p>C++</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv4</span><br></pre></td></tr></table></figure><p>返回<code>4.3.0</code></p><p>Python</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import cv2; print(cv2.__version__)&quot;</span></span><br></pre></td></tr></table></figure><p>返回<code>4.3.0-dev</code></p><h2 id="2-Clion工程配置"><a href="#2-Clion工程配置" class="headerlink" title="2 Clion工程配置"></a>2 Clion工程配置</h2><p>新建工程，本文选择C++11标准</p><p>编辑<code>CmakeList.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br><span class="line"><span class="keyword">project</span>(OpenCV_Test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(OpenCV_Test main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(OpenCV_Test <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>到运行调试配置中修改工作目录为<script type="math/tex">ProjectFileDir</script>（或手动输入当前main.cpp所在目录）</p><p>在工作目录下放置一个图片命名为<code>test.jpg</code></p><p>编写测试程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">Mat image = <span class="built_in">imread</span>(<span class="string">&quot;./test.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;OpenCV-Test&quot;</span>,image);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，若配置无误即可显示出图片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技能" scheme="https://www.robotsfan.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
    <category term="Ubuntu" scheme="https://www.robotsfan.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——34关键词const</title>
    <link href="https://www.robotsfan.com/posts/4307fde0.html"/>
    <id>https://www.robotsfan.com/posts/4307fde0.html</id>
    <published>2022-02-20T13:20:00.000Z</published>
    <updated>2022-02-20T13:24:46.767Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——34关键词const"><a href="#深入学习C-——34关键词const" class="headerlink" title="深入学习C++——34关键词const"></a>深入学习C++——34关键词const</h1><p>const是一种“伪”关键词，他不像void int，const对代码的生成不会造成什么影响。它类似于private、public这样的关键词，它是对开发人员写代码强制特定的规则。const是你做出的承诺，它承诺某些东西将是不变的。（这种承诺是可以打破的，你是否遵守承诺取决于你自己，但是请遵守你自己的承诺）</p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>下面演示const最基础的应用场景，const在程序中一般修饰一个需要保持不变的数字，比如<code>MAX_AGE</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line">MAX_AGE = <span class="number">100</span>; <span class="comment">//正确，a的值可以被修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_AGE = <span class="number">90</span>;</span><br><span class="line">MAX_AGE = <span class="number">100</span>; <span class="comment">//错误，const常量不能被修改</span></span><br></pre></td></tr></table></figure><h2 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h2><p>再来讨论一下指针的问题。首先声明一个未被const修饰的整形指针a：（定义<code>int MAX_AGE = 90;</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*a = <span class="number">2</span>;<span class="comment">//可以改变指针指向的内容</span></span><br><span class="line">a = &amp;MAX_AGE;<span class="comment">//可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *a &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure><p>此时在<code>*</code>前加上<code>const</code>，就变成了<strong>常量指针</strong>，意味着不能修改指针指向的内容：</p><p>常量指针有两种写法，<code>const int *</code>和<code>int const *</code>都是可以的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*b = <span class="number">2</span>;<span class="comment">//错误。不可以改变指针指向的内容</span></span><br><span class="line">b = &amp;MAX_AGE;<span class="comment">//可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *b &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure><p>如果在<code>*</code>后加上<code>const</code>，就变成了<strong>指针常量</strong>，意味着指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化：</p><p>指针常量只能写成<code>int * const</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*c = <span class="number">2</span>;<span class="comment">//可以改变指针指向的内容</span></span><br><span class="line">c = &amp;MAX_AGE;<span class="comment">//错误。不可以改变指针变量指向的地址</span></span><br><span class="line">std::cout &lt;&lt; *c &lt;&lt; std::endl;<span class="comment">//可以读取指针指向的内容</span></span><br></pre></td></tr></table></figure><p>同理，如果写成<code>const int* const d = new int;</code>，即意味着不能改变指针指向的内容，也不能改变指针变量指向的地址。</p><h2 id="类内方法中使用const"><a href="#类内方法中使用const" class="headerlink" title="类内方法中使用const"></a>类内方法中使用const</h2><p>在类中的方法名后加上const，表示方法不会修改任何实际的类，因此不能修改类成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_x, m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        m_x = <span class="number">2</span>;<span class="comment">//错误，不能修改类成员变量</span></span><br><span class="line"><span class="keyword">return</span> m_x;<span class="comment">//只能读不能写</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假如此时有一个函数，使用了常量引用，它保证了函数内不会对这个类做任何的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但此时将<code>GetX()</code>方法后的<code>const</code>去掉，上面函数内就不能调用GetX了。因为GetX函数已经不能保证它不会写入Entity了。<strong>常对象只能调用常函数</strong>。所以我们常常会见到函数的两个版本，此时常对象就会调用带有const的那个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所诉，如果你的方法实际上没有修改类或者他们不应该修改类，那就把他们标记成const。否则在有常量引用的情况下就用不了你的方法了。</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——7链接器</title>
    <link href="https://www.robotsfan.com/posts/9823ae96.html"/>
    <id>https://www.robotsfan.com/posts/9823ae96.html</id>
    <published>2022-02-10T07:00:00.000Z</published>
    <updated>2022-02-20T13:24:46.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——7链接器"><a href="#深入学习C-——7链接器" class="headerlink" title="深入学习C++——7链接器"></a>深入学习C++——7链接器</h1><p>从文本形式的源文件到可执行文件中间其实经过了编译和链接两个步骤，本文来讨论一下C++链接器是如何工作的。</p><h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><p>当我们编译好源文件，我们需要通过一个叫做链接的过程。链接的任务是找到每个符号和函数所在的地方，并把它们链接起来。多个翻译单元（一个CPP文件可以理解为一个翻译单元）之间并不互通，我们需要一种方法把这些文件连接起来成一个项目。即使只有一个翻译单元，也需要将main函数连接起来，这就是链接器的主要目的和要做的事情。</p><h2 id="一些常见的链接错误"><a href="#一些常见的链接错误" class="headerlink" title="一些常见的链接错误"></a>一些常见的链接错误</h2><h3 id="未解决的外部符号"><a href="#未解决的外部符号" class="headerlink" title="未解决的外部符号"></a>未解决的外部符号</h3><p>当链接器找不到确切定义时会发生。来看一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;Multiply&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，Multiply函数没有被任何函数调用，其中的Log函数虽然被声明了但是并没有并定义。这样依然会报错。虽然我们没有使用Multiply函数，但是在技术上来讲，我们有可能会用到Log函数，所以链接器需要链接到它，所以会报错。但是如果使用static将Multiply函数限制在该文件中使用<code>static void Multiply(int a, int b)</code>，由于我们没有使用该函数，所以不再报错。</p><p>如果一个函数的声明和定义中的输入和返回的数据类型不对应，也会报错。</p><h3 id="有重复的符号"><a href="#有重复的符号" class="headerlink" title="有重复的符号"></a>有重复的符号</h3><p>如果我们的函数或变量具有相同的名字或签名，链接器会不知道该链接哪一个。即使没有申明，两个相同的函数放在不同的文件中，依然会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，如果一个函数需要在其它文件中使用，则要将函数的定义写在cpp中，然后在对应的hpp文件中写上该函数的声明，最后在需要用它的文件中#include这个hpp文件即可避免链接错误。</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——6编译器</title>
    <link href="https://www.robotsfan.com/posts/dac51109.html"/>
    <id>https://www.robotsfan.com/posts/dac51109.html</id>
    <published>2022-02-10T02:00:00.000Z</published>
    <updated>2022-02-20T13:24:46.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——6编译器"><a href="#深入学习C-——6编译器" class="headerlink" title="深入学习C++——6编译器"></a>深入学习C++——6编译器</h1><p>从文本形式的源文件到可执行文件中间其实经过了编译和链接两个步骤，本文来讨论一下C++编译器是如何工作的。</p><p>C++编译器只负责一件事，将文本文件（我们写的代码）转换成称为目标文件的中间格式。这些目标文件可以传递到链接，链接可以做它所有要链接的事情。</p><p>编译器在生成这些目标文件时，首先会预处理代码，这意味着所有的预处理器语句都会先处理。然后进行记号化和解析，将文本转换为编译器真正能够理解和推理的格式。这创建了所谓的抽象语法树。语法树一旦被创建，编译器就可以开始实际生成代码。目标文件中都是机器码，如果进行反汇编，就可以看到相对应的汇编语句。</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入学习C++——5C++工作原理</title>
    <link href="https://www.robotsfan.com/posts/a6a7cea1.html"/>
    <id>https://www.robotsfan.com/posts/a6a7cea1.html</id>
    <published>2022-02-10T00:00:00.000Z</published>
    <updated>2022-02-20T13:24:46.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入学习C-——5C-工作原理"><a href="#深入学习C-——5C-工作原理" class="headerlink" title="深入学习C++——5C++工作原理"></a>深入学习C++——5C++工作原理</h1><h2 id="分析main-cpp"><a href="#分析main-cpp" class="headerlink" title="分析main.cpp"></a>分析main.cpp</h2><p>对于一个后缀为<code>.cpp</code>的C++源文件，先来分析一下文件的结构</p><p><code>#</code>符号之后的都是预处理语句（叫预处理的原因为它实际上在编译之前就发生了）。<code>#include</code>的含义是找到&lt;&gt;中的文件，然后将该文件中的所有内容拷贝到现在的文件内。这些被包含的文件称为头文件，在C++中通常以<code>.hpp</code>为后缀。</p><p>来看一个预处理的神奇操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*file2.hpp*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*file1.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;file2.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>这个程序能否成功编译？可以看到main函数是没有右花括号的，但是<code>#include &quot;file2.hpp&quot;</code>这一句将file2中的文件原封不动拷贝到了当前的地方，即补上了一个花括号，所以可以编译成功。</p><p>除了#include，常用的预处理命令还有<code>#if #endif</code>，这一对是这么用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int a = 1;会被编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 1;不会被编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来是main函数。<code>main</code>函数是程序的入口，当运行程序时计算机从这个函数开始执行代码。在这里，main函数的返回类型是int，但是代码中没有返回任何东西，这是因为main函数是特殊的，它不一定需要返回值。没有写return进行返回的话，它会默认返回了0。注意，这只对main函数适用！</p><p><code>&lt;&lt;</code> 符号叫做重载运算符，可以理解为一个函数。</p><h2 id="代码如何编译为二进制文件"><a href="#代码如何编译为二进制文件" class="headerlink" title="代码如何编译为二进制文件"></a>代码如何编译为二进制文件</h2><p>项目中的每一个cpp文件都会被编译，但是头文件不会被编译，头文件的内容在预处理时全部拷贝到了到了cpp中。每一个cpp文件都被编译为object file（目标文件），我们需要将这些文件合并成一个执行文件，链接（Link）会将所有的目标文件合并成一个.exe文件。</p><p>如果在一个文件（比如main.cpp）中使用了另一个文件中的函数，编译会报错，需要在main.cpp中声明那个函数的存在。声明表示这个符号、函数是存在的，去掉函数的结构体后加分号就是函数的声明。声明与定义不同，定义是说明这个函数到底是什么，是函数的函数体。<code>void Log(const char* message);</code>这就是一个声明，其实<code>void Log(const char*);</code>这样写也可以，但习惯上使用前者，会更加清晰。在构建整个项目时，所有.cpp文件都会被编译，链接器会找到正确的Log函数的定义在哪里，如果找不到定义，会报链接错误。</p><p>关于编译器和链接器会单独讲解</p><hr><p><strong>文章作者:</strong> <a href="https://github.com/fan-ziqi">范子琦</a></p><p><strong>文章链接:</strong> <a href="https://www.fanziqi.site/categories/C/">https://www.fanziqi.site/categories/C/</a></p><p><strong>版权声明:</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.fanziqi.site/">范子琦的博客</a>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="https://www.robotsfan.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.robotsfan.com/tags/C/"/>
    
  </entry>
  
</feed>
